<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Cell-free-rna-2024 - 3&nbsp; Cross Validation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./SI_select_quant_method.html" rel="next">
<link href="./quant.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="stylesheet" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./sample.html">Methods</a></li><li class="breadcrumb-item"><a href="./cross_validation.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Cross Validation</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Cell-free-rna-2024</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Methods</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./sample.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Sample Information</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./quant.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">RNA-seq data processing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./cross_validation.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Cross Validation</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Supplementary Text</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SI_select_quant_method.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Selection of RNA-seq quantification method</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./SI_trimming.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Assessing the effect of trimming the adaptor sequences</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./figure.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Figures</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./main_figure.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">6</span>&nbsp; <span class="chapter-title">Main Figures</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./suppl_figure.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">7</span>&nbsp; <span class="chapter-title">Supplementary Text Figures</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-cv-prep" id="toc-sec-cv-prep" class="nav-link active" data-scroll-target="#sec-cv-prep"><span class="header-section-number">3.1</span> Data preparation</a>
  <ul class="collapse">
  <li><a href="#sec-cv-prep-int-val" id="toc-sec-cv-prep-int-val" class="nav-link" data-scroll-target="#sec-cv-prep-int-val"><span class="header-section-number">3.1.1</span> Internal validation cohort</a></li>
  <li><a href="#sec-cv-prep-ext-val" id="toc-sec-cv-prep-ext-val" class="nav-link" data-scroll-target="#sec-cv-prep-ext-val"><span class="header-section-number">3.1.2</span> External validation dataset</a></li>
  </ul></li>
  <li><a href="#sec-cv-split" id="toc-sec-cv-split" class="nav-link" data-scroll-target="#sec-cv-split"><span class="header-section-number">3.2</span> Data split for 5-fold CV</a></li>
  <li><a href="#sec-cv-11ML" id="toc-sec-cv-11ML" class="nav-link" data-scroll-target="#sec-cv-11ML"><span class="header-section-number">3.3</span> 11 machine learning methods</a>
  <ul class="collapse">
  <li><a href="#sec-cv-glParallel" id="toc-sec-cv-glParallel" class="nav-link" data-scroll-target="#sec-cv-glParallel"><span class="header-section-number">3.3.1</span> <code>glParallel</code></a></li>
  <li><a href="#sec-cv-svm-rfe" id="toc-sec-cv-svm-rfe" class="nav-link" data-scroll-target="#sec-cv-svm-rfe"><span class="header-section-number">3.3.2</span> <code>mSVM-RFE</code></a></li>
  </ul></li>
  <li><a href="#sec-5fold-cv" id="toc-sec-5fold-cv" class="nav-link" data-scroll-target="#sec-5fold-cv"><span class="header-section-number">3.4</span> 5-Fold cross validation</a></li>
  <li><a href="#sec-validation" id="toc-sec-validation" class="nav-link" data-scroll-target="#sec-validation"><span class="header-section-number">3.5</span> Internal and external validation</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./sample.html">Methods</a></li><li class="breadcrumb-item"><a href="./cross_validation.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Cross Validation</span></a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title"><span id="sec-cv" class="quarto-section-identifier"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Cross Validation</span></span></h1><button type="button" class="btn code-tools-button dropdown-toggle" id="quarto-code-tools-menu" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi"></i> Code</button><ul class="dropdown-menu dropdown-menu-end" aria-labelelledby="quarto-code-tools-menu"><li><a id="quarto-show-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Show All Code</a></li><li><a id="quarto-hide-all-code" class="dropdown-item" href="javascript:void(0)" role="button">Hide All Code</a></li><li><hr class="dropdown-divider"></li><li><a id="quarto-view-source" class="dropdown-item" href="javascript:void(0)" role="button">View Source</a></li></ul></div></div>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-cv-prep" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="sec-cv-prep"><span class="header-section-number">3.1</span> Data preparation</h2>
<section id="sec-cv-prep-int-val" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="sec-cv-prep-int-val"><span class="header-section-number">3.1.1</span> Internal validation cohort</h3>
<p>Internal validation dataset was from the <code>Validation</code> dataset shown in <a href="main_figure.html#fig-fig1" class="quarto-xref">Figure&nbsp;<span>6.1</span></a> C.</p>
<p>Now we set up the <code>Salmon</code> quant files of the validation (i.e.&nbsp;term) dataset. NB, <code>dt.colllDataAll</code> (shown from the code below) was set up from <a href="quant.html#lst-prep-quant-sf" class="quarto-xref">Listing&nbsp;<span>2.4</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to set the <code>Salmon</code> quant files of the term dataset (i.e.&nbsp;Validation dataset)</summary>
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># remove these two samples as both of them flagged as "failed" by illumina (it is a 28wk control sample)</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>dt.colDataTerm<span class="ot">&lt;-</span>dt.colDataAll[Type<span class="sc">==</span><span class="st">"term"</span> <span class="sc">&amp;</span> <span class="sc">!</span>names <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"GS-B-374-UW"</span>,<span class="st">"GS-B-374-UW-b"</span>)] </span>
<span id="cb1-3"><a href="#cb1-3"></a>li.GA.term<span class="ot">&lt;-</span><span class="fu">split</span>(dt.colDataTerm, dt.colDataTerm<span class="sc">$</span>GA)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>We are ready to read the <code>Salmon</code> quant files via <code>tximeta</code> R package. NB, the code below is equivalent to <a href="quant.html#lst-prep-dds" class="quarto-xref">Listing&nbsp;<span>2.5</span></a> and <a href="quant.html#lst-set-dds" class="quarto-xref">Listing&nbsp;<span>2.6</span></a> from the discovery cohort (see <a href="quant.html#sec-mtd-deg-deseq2" class="quarto-xref"><span>Section 2.2.1</span></a>).</p>
<div class="cell">
<details class="code-fold">
<summary>Code to read the <code>Salmon</code> quant files of the term dataset and make <code>dds</code> object.</summary>
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a>my.dds.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dds.term."</span>,my.salmon.index,<span class="st">".RData"</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.dds.RData)){</span>
<span id="cb2-3"><a href="#cb2-3"></a>  <span class="fu">load</span>(my.dds.RData)</span>
<span id="cb2-4"><a href="#cb2-4"></a>  <span class="fu">message</span>(<span class="st">"loading dds..."</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a>}<span class="cf">else</span>{</span>
<span id="cb2-6"><a href="#cb2-6"></a>  gse.term<span class="ot">&lt;-</span>tximeta<span class="sc">::</span><span class="fu">tximeta</span>(dt.colDataTerm,<span class="at">skipMeta=</span>T,<span class="at">tx2gene=</span>dt.tx2gene[,.(transcript_id,gene_id)],<span class="at">txOut=</span>F)</span>
<span id="cb2-7"><a href="#cb2-7"></a>  <span class="co"># set up `dds` at gene-level</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>  my.design <span class="ot">&lt;-</span> <span class="fu">formula</span>(<span class="sc">~</span> Batch <span class="sc">+</span> GA <span class="sc">+</span> Sex <span class="sc">+</span> Condition)      <span class="co"># isa 'formula'</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>  dds.term <span class="ot">&lt;-</span> <span class="fu">DESeqDataSet</span>(<span class="at">se=</span>gse.term, <span class="at">design=</span>my.design) </span>
<span id="cb2-10"><a href="#cb2-10"></a></span>
<span id="cb2-11"><a href="#cb2-11"></a>  dds.term<span class="sc">$</span>Group<span class="ot">&lt;-</span><span class="fu">factor</span>(<span class="fu">paste0</span>(dds.term<span class="sc">$</span>GA,dds.term<span class="sc">$</span>Condition)) <span class="co"># add 'Group'</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>  <span class="fu">design</span>(dds.term) <span class="ot">&lt;-</span> <span class="fu">formula</span>(<span class="sc">~</span> Batch <span class="sc">+</span> Sex <span class="sc">+</span> Group)        <span class="co"># isa 'formula'</span></span>
<span id="cb2-13"><a href="#cb2-13"></a></span>
<span id="cb2-14"><a href="#cb2-14"></a>  <span class="co">#</span></span>
<span id="cb2-15"><a href="#cb2-15"></a>  dds.term<span class="ot">&lt;-</span> <span class="fu">DESeq</span>(dds.term, <span class="at">parallel=</span><span class="cn">TRUE</span>) <span class="co"># isa 'DESeqDataSet'</span></span>
<span id="cb2-16"><a href="#cb2-16"></a>  <span class="fu">save</span>(dds.term,<span class="at">file=</span>my.dds.RData)</span>
<span id="cb2-17"><a href="#cb2-17"></a>}</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="co"># use 15150 genes considered in this study</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>dds.f2.term<span class="ot">&lt;-</span><span class="fu">DESeq</span>(dds.term[<span class="fu">rownames</span>(dds.f2)], <span class="at">parallel=</span>T)</span>
<span id="cb2-21"><a href="#cb2-21"></a></span>
<span id="cb2-22"><a href="#cb2-22"></a>my.dl.resLFC.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dl.resLFC.term."</span>,my.salmon.index,<span class="st">".RData"</span>)</span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.dl.resLFC.RData)){</span>
<span id="cb2-24"><a href="#cb2-24"></a>  <span class="fu">load</span>(my.dl.resLFC.RData)</span>
<span id="cb2-25"><a href="#cb2-25"></a>}<span class="cf">else</span>{</span>
<span id="cb2-26"><a href="#cb2-26"></a>  <span class="co"># apply shink</span></span>
<span id="cb2-27"><a href="#cb2-27"></a>  li.resLFC.term<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.GA.term),<span class="cf">function</span>(my.GA){</span>
<span id="cb2-28"><a href="#cb2-28"></a>    my.res<span class="ot">&lt;-</span><span class="fu">results</span>(dds.f2.term, </span>
<span id="cb2-29"><a href="#cb2-29"></a>            <span class="co">#alpha=.05, # by default independant filtering at FDR (alpha) 0.1 (10%) </span></span>
<span id="cb2-30"><a href="#cb2-30"></a>            <span class="at">independentFiltering=</span><span class="cn">FALSE</span>,</span>
<span id="cb2-31"><a href="#cb2-31"></a>            <span class="at">lfcThreshold=</span><span class="fu">log2</span>(minFC), </span>
<span id="cb2-32"><a href="#cb2-32"></a>            <span class="at">contrast=</span><span class="fu">c</span>(<span class="st">"Group"</span>,<span class="fu">paste0</span>(my.GA,<span class="fu">c</span>(<span class="st">"Case"</span>,<span class="st">"Control"</span>))),</span>
<span id="cb2-33"><a href="#cb2-33"></a>            <span class="at">parallel=</span><span class="cn">TRUE</span>)  </span>
<span id="cb2-34"><a href="#cb2-34"></a>    <span class="fu">lfcShrink</span>(dds.f2.term, </span>
<span id="cb2-35"><a href="#cb2-35"></a>              <span class="co">#contrast=c("Group",paste0(my.GA,c("Case","Control"))), # not necessary for 'ashr'</span></span>
<span id="cb2-36"><a href="#cb2-36"></a>              <span class="at">res=</span>my.res, <span class="co">#li.res[[my.GA]],</span></span>
<span id="cb2-37"><a href="#cb2-37"></a>              <span class="at">lfcThreshold=</span><span class="fu">log2</span>(minFC), <span class="co"># not applicable for 'asher' </span></span>
<span id="cb2-38"><a href="#cb2-38"></a>              <span class="at">type=</span><span class="st">"ashr"</span>,</span>
<span id="cb2-39"><a href="#cb2-39"></a>              <span class="at">parallel=</span><span class="cn">TRUE</span>)  </span>
<span id="cb2-40"><a href="#cb2-40"></a>  })</span>
<span id="cb2-41"><a href="#cb2-41"></a>  <span class="fu">names</span>(li.resLFC.term)<span class="ot">&lt;-</span><span class="fu">names</span>(li.GA.term)</span>
<span id="cb2-42"><a href="#cb2-42"></a></span>
<span id="cb2-43"><a href="#cb2-43"></a>  dl.resLFC.term<span class="ot">&lt;-</span><span class="fu">lapply</span>(li.resLFC.term, <span class="cf">function</span>(i)</span>
<span id="cb2-44"><a href="#cb2-44"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">gene_id</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(i), <span class="fu">as.data.frame</span>(i))[<span class="fu">order</span>(pvalue)][,<span class="st">`</span><span class="at">:=</span><span class="st">`</span>(<span class="st">"BH"</span><span class="ot">=</span><span class="fu">p.adjust</span>(pvalue,<span class="st">"BH"</span>),<span class="st">"BY"</span><span class="ot">=</span><span class="fu">p.adjust</span>(pvalue,<span class="st">"BY"</span>),<span class="st">"bf"</span><span class="ot">=</span><span class="fu">p.adjust</span>(pvalue,<span class="st">"bonferroni"</span>))]</span>
<span id="cb2-45"><a href="#cb2-45"></a>  )</span>
<span id="cb2-46"><a href="#cb2-46"></a>  <span class="fu">save</span>(dl.resLFC.term, <span class="at">file=</span>my.dl.resLFC.RData)</span>
<span id="cb2-47"><a href="#cb2-47"></a>  <span class="co">#fwrite(dl.resLFC[["28wk"]], file=paste0("data/DEG.DSeq2.28wk.",my.type,".",my.salmon.index,".csv"))</span></span>
<span id="cb2-48"><a href="#cb2-48"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Now we use <code>edgeR</code>. NB, this is equivalent to <a href="quant.html#lst-set-edger" class="quarto-xref">Listing&nbsp;<span>2.8</span></a> shown in <a href="quant.html#sec-mtd-deg-edger" class="quarto-xref"><span>Section 2.2.2</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to find DEGs by <code>edgeR</code> from the term dataset</summary>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>gse2 <span class="ot">&lt;-</span>gse.term[<span class="fu">rownames</span>(dds.f2.term),]</span>
<span id="cb3-2"><a href="#cb3-2"></a>d2<span class="ot">&lt;-</span>tximeta<span class="sc">::</span><span class="fu">makeDGEList</span>(gse2)</span>
<span id="cb3-3"><a href="#cb3-3"></a>d2<span class="sc">$</span>samples<span class="ot">&lt;-</span><span class="fu">cbind</span>(d2<span class="sc">$</span>samples,<span class="fu">colData</span>(gse2))</span>
<span id="cb3-4"><a href="#cb3-4"></a>d2<span class="sc">$</span>samples<span class="sc">$</span>group<span class="ot">&lt;-</span><span class="fu">factor</span>(<span class="fu">paste0</span>(d2<span class="sc">$</span>samples<span class="sc">$</span>GA,d2<span class="sc">$</span>samples<span class="sc">$</span>Condition)) <span class="co"># add 'group'</span></span>
<span id="cb3-5"><a href="#cb3-5"></a>d2<span class="sc">$</span>samples<span class="sc">$</span>GA<span class="ot">&lt;-</span><span class="fu">droplevels</span>(d2<span class="sc">$</span>samples<span class="sc">$</span>GA) <span class="co"># 36wk removed - really? 2023-03-21</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>d2<span class="sc">$</span>samples<span class="sc">$</span>Batch<span class="ot">&lt;-</span><span class="fu">droplevels</span>(d2<span class="sc">$</span>samples<span class="sc">$</span>Batch) <span class="co"># some batches removed</span></span>
<span id="cb3-7"><a href="#cb3-7"></a></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co"># TMM normalisation (default). It adds `norm.factors` d2$samples</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co"># NB, we have `offsets`, which take precedence over lib.size and norm.factors</span></span>
<span id="cb3-10"><a href="#cb3-10"></a>d2<span class="ot">&lt;-</span><span class="fu">calcNormFactors</span>(d2,<span class="at">method=</span><span class="st">"TMM"</span>) </span>
<span id="cb3-11"><a href="#cb3-11"></a></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co"># design</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co"># my.design &lt;- model.matrix(~ Batch + Sex + group, data=d2$samples)         # isa 'matrix'</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#my.design &lt;- model.matrix(~ 0 + group,  data=d2$samples)       # isa 'matrix'</span></span>
<span id="cb3-15"><a href="#cb3-15"></a>my.design <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(<span class="sc">~</span> <span class="dv">0</span> <span class="sc">+</span> group <span class="sc">+</span> Sex <span class="sc">+</span> Batch , <span class="at">data=</span>d2<span class="sc">$</span>samples)      <span class="co"># isa 'matrix'</span></span>
<span id="cb3-16"><a href="#cb3-16"></a>(my.contrasts <span class="ot">&lt;-</span> <span class="fu">makeContrasts</span>(<span class="st">`</span><span class="at">12wk</span><span class="st">`</span><span class="ot">=</span>group12wkCase<span class="sc">-</span>group12wkControl, </span>
<span id="cb3-17"><a href="#cb3-17"></a>                              <span class="st">`</span><span class="at">20wk</span><span class="st">`</span><span class="ot">=</span>group20wkCase<span class="sc">-</span>group20wkControl, </span>
<span id="cb3-18"><a href="#cb3-18"></a>                              <span class="st">`</span><span class="at">28wk</span><span class="st">`</span><span class="ot">=</span>group28wkCase<span class="sc">-</span>group28wkControl, </span>
<span id="cb3-19"><a href="#cb3-19"></a>                              <span class="at">levels=</span>my.design)</span>
<span id="cb3-20"><a href="#cb3-20"></a>)</span>
<span id="cb3-21"><a href="#cb3-21"></a></span>
<span id="cb3-22"><a href="#cb3-22"></a><span class="co"># dispersion</span></span>
<span id="cb3-23"><a href="#cb3-23"></a><span class="co">#dp2 = estimateDisp(d2, design=my.design, verbose=T)</span></span>
<span id="cb3-24"><a href="#cb3-24"></a>dp2 <span class="ot">=</span> <span class="fu">estimateGLMCommonDisp</span>(d2, <span class="at">design=</span>my.design, <span class="at">verbose=</span>T) </span>
<span id="cb3-25"><a href="#cb3-25"></a>dp2 <span class="ot">=</span> <span class="fu">estimateGLMTrendedDisp</span>(dp2, <span class="at">design=</span>my.design, <span class="at">verbose=</span>T)</span>
<span id="cb3-26"><a href="#cb3-26"></a>dp2 <span class="ot">=</span> <span class="fu">estimateGLMTagwiseDisp</span>(dp2, <span class="at">design=</span>my.design)</span>
<span id="cb3-27"><a href="#cb3-27"></a></span>
<span id="cb3-28"><a href="#cb3-28"></a><span class="co">#f = glmFit(dp2, design=my.design) # </span></span>
<span id="cb3-29"><a href="#cb3-29"></a>f <span class="ot">=</span> <span class="fu">glmQLFit</span>(dp2, <span class="at">design=</span>my.design) <span class="co"># QL(Quasi-like) pipeline</span></span>
<span id="cb3-30"><a href="#cb3-30"></a><span class="fu">colnames</span>(f)</span>
<span id="cb3-31"><a href="#cb3-31"></a>f<span class="sc">$</span>coefficients <span class="sc">%&gt;%</span> head</span>
<span id="cb3-32"><a href="#cb3-32"></a></span>
<span id="cb3-33"><a href="#cb3-33"></a><span class="co"># get the edgeR results</span></span>
<span id="cb3-34"><a href="#cb3-34"></a>li.res.edgeR.term<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.GA.term), <span class="cf">function</span>(i){</span>
<span id="cb3-35"><a href="#cb3-35"></a>  te <span class="ot">&lt;-</span> <span class="fu">glmTreat</span>(f, <span class="at">contrast=</span>my.contrasts[,i], <span class="at">lfc=</span><span class="fu">log2</span>(minFC))</span>
<span id="cb3-36"><a href="#cb3-36"></a>  <span class="fu">topTags</span>(te, <span class="at">n=</span><span class="fu">nrow</span>(te))    <span class="co"># default sort by pvalue</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>})</span>
<span id="cb3-38"><a href="#cb3-38"></a><span class="fu">names</span>(li.res.edgeR.term) <span class="ot">&lt;-</span><span class="fu">names</span>(li.GA.term)</span>
<span id="cb3-39"><a href="#cb3-39"></a></span>
<span id="cb3-40"><a href="#cb3-40"></a>dl.res.edgeR.term<span class="ot">&lt;-</span><span class="fu">lapply</span>(li.res.edgeR.term, <span class="cf">function</span>(i)</span>
<span id="cb3-41"><a href="#cb3-41"></a>  <span class="fu">data.table</span>(<span class="st">`</span><span class="at">gene_id</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(i),i<span class="sc">$</span>table)[<span class="fu">order</span>(PValue)][,<span class="st">`</span><span class="at">:=</span><span class="st">`</span>(<span class="st">"BH"</span><span class="ot">=</span><span class="fu">p.adjust</span>(PValue,<span class="st">"BH"</span>),<span class="st">"BY"</span><span class="ot">=</span><span class="fu">p.adjust</span>(PValue,<span class="st">"BY"</span>),<span class="st">"bf"</span><span class="ot">=</span><span class="fu">p.adjust</span>(PValue,<span class="st">"bonferroni"</span>))]</span>
<span id="cb3-42"><a href="#cb3-42"></a>)</span>
<span id="cb3-43"><a href="#cb3-43"></a></span>
<span id="cb3-44"><a href="#cb3-44"></a>my.dl.res.edgeR.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dl.res.edgeR.term."</span>,my.salmon.index,<span class="st">".RData"</span>)</span>
<span id="cb3-45"><a href="#cb3-45"></a><span class="fu">save</span>(dl.res.edgeR.term, <span class="at">file=</span>my.dl.res.edgeR.RData)</span>
<span id="cb3-46"><a href="#cb3-46"></a><span class="co">#fwrite(dl.res.edgeR[["28wk"]], file=paste0("data/DEG.edgeR.28wk.",my.type,".",my.salmon.index,".csv"))</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>The gene-level count matrix was converted as the unit of CPM (Count Per Million), in log2-scale, via the “cpm” function of edgeR and it was further transformed into a matrix of the z-score using the mean and standard deviation of logCPM from the control samples of each corresponding gestational age group. NB, this is equivalent to <a href="quant.html#lst-cnt-cpm" class="quarto-xref">Listing&nbsp;<span>2.9</span></a> shown in <a href="quant.html#sec-zscore-mat" class="quarto-xref"><span>Section 2.2.3</span></a>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to make the count matrix from the validation dataset</summary>
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="co"># based on genes from dds.f2.term</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co"># CPM based on edgeR TMM  (NB, d isa "DGEList")</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>my.cnt.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dt.count2.term."</span>,my.salmon.index,<span class="st">".RData"</span>)</span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.cnt.RData)){</span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="fu">load</span>(my.cnt.RData)</span>
<span id="cb4-6"><a href="#cb4-6"></a>}<span class="cf">else</span>{</span>
<span id="cb4-7"><a href="#cb4-7"></a>  dt.count<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb4-8"><a href="#cb4-8"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(dds.f2.term),<span class="fu">counts</span>(dds.f2.term,<span class="at">normalized=</span>T)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-9"><a href="#cb4-9"></a>      <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"Count"</span>),</span>
<span id="cb4-10"><a href="#cb4-10"></a>    dt.samples[Type<span class="sc">==</span><span class="st">"term"</span>,.(SampleID,GA,Condition,<span class="at">Group=</span><span class="fu">paste</span>(GA,Condition,<span class="at">sep=</span><span class="st">"-"</span>))]</span>
<span id="cb4-11"><a href="#cb4-11"></a>  )</span>
<span id="cb4-12"><a href="#cb4-12"></a></span>
<span id="cb4-13"><a href="#cb4-13"></a>  <span class="co"># CPM based on DESeq2 `fpm`</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>  dt.cpm<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(dds.f2.term),<span class="fu">fpm</span>(dds.f2.term)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-16"><a href="#cb4-16"></a>      <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"CPM"</span>),</span>
<span id="cb4-17"><a href="#cb4-17"></a>    dt.samples[Type<span class="sc">==</span><span class="st">"term"</span>,.(SampleID,GA,Condition,<span class="at">Group=</span><span class="fu">paste</span>(GA,Condition,<span class="at">sep=</span><span class="st">"-"</span>))]</span>
<span id="cb4-18"><a href="#cb4-18"></a>  )</span>
<span id="cb4-19"><a href="#cb4-19"></a></span>
<span id="cb4-20"><a href="#cb4-20"></a>  dt.tpm<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb4-21"><a href="#cb4-21"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(dds.f2.term), <span class="fu">assays</span>(dds.f2.term)[[<span class="st">"abundance"</span>]]) <span class="sc">%&gt;%</span> </span>
<span id="cb4-22"><a href="#cb4-22"></a>      <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"TPM"</span>),</span>
<span id="cb4-23"><a href="#cb4-23"></a>    dt.samples[Type<span class="sc">==</span><span class="st">"term"</span>,.(SampleID,GA,Condition,<span class="at">Group=</span><span class="fu">paste</span>(GA,Condition,<span class="at">sep=</span><span class="st">"-"</span>))]</span>
<span id="cb4-24"><a href="#cb4-24"></a>  )</span>
<span id="cb4-25"><a href="#cb4-25"></a></span>
<span id="cb4-26"><a href="#cb4-26"></a>  <span class="co"># CPM based on edgeR TMM  (NB, d isa "DGEList")</span></span>
<span id="cb4-27"><a href="#cb4-27"></a>  dt.cpm2<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb4-28"><a href="#cb4-28"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(d2),<span class="fu">cpm</span>(d2)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-29"><a href="#cb4-29"></a>      <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"CPM"</span>),</span>
<span id="cb4-30"><a href="#cb4-30"></a>    dt.samples[Type<span class="sc">==</span><span class="st">"term"</span>,.(SampleID,GA,Condition,<span class="at">Group=</span><span class="fu">paste</span>(GA,Condition,<span class="at">sep=</span><span class="st">"-"</span>))]</span>
<span id="cb4-31"><a href="#cb4-31"></a>    )</span>
<span id="cb4-32"><a href="#cb4-32"></a></span>
<span id="cb4-33"><a href="#cb4-33"></a>  dt.logcpm2<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb4-34"><a href="#cb4-34"></a>    <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(d2),<span class="fu">cpm</span>(d2,<span class="at">log=</span>T)) <span class="sc">%&gt;%</span> </span>
<span id="cb4-35"><a href="#cb4-35"></a>      <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"logCPM"</span>),</span>
<span id="cb4-36"><a href="#cb4-36"></a>    dt.samples[Type<span class="sc">==</span><span class="st">"term"</span>,.(SampleID,GA,Condition,<span class="at">Group=</span><span class="fu">paste</span>(GA,Condition,<span class="at">sep=</span><span class="st">"-"</span>))]</span>
<span id="cb4-37"><a href="#cb4-37"></a>    )</span>
<span id="cb4-38"><a href="#cb4-38"></a></span>
<span id="cb4-39"><a href="#cb4-39"></a>  <span class="fu">save</span>(dt.count, dt.cpm, dt.tpm, dt.cpm2, dt.logcpm2, <span class="at">file=</span>my.cnt.RData)</span>
<span id="cb4-40"><a href="#cb4-40"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="cell">
<details class="code-fold">
<summary>Code to make the z-score matrix from the validation dataset</summary>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>my.cpmZ.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dt.cpmZ.term."</span>,my.salmon.index,<span class="st">".RData"</span>)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.cpmZ.RData)){</span>
<span id="cb5-3"><a href="#cb5-3"></a>  <span class="fu">load</span>(my.cpmZ.RData)</span>
<span id="cb5-4"><a href="#cb5-4"></a>}<span class="cf">else</span>{</span>
<span id="cb5-5"><a href="#cb5-5"></a>  dt.cpmZ.term<span class="ot">=</span><span class="fu">merge</span>(dt.logcpm2,</span>
<span id="cb5-6"><a href="#cb5-6"></a>                dt.logcpm2[Condition<span class="sc">==</span><span class="st">"Control"</span>,.(<span class="at">Mean=</span><span class="fu">mean</span>(logCPM),<span class="at">SD=</span><span class="fu">sd</span>(logCPM)),.(GA,geneName)]</span>
<span id="cb5-7"><a href="#cb5-7"></a>        ,<span class="at">by=</span><span class="fu">c</span>(<span class="st">"GA"</span>,<span class="st">"geneName"</span>)</span>
<span id="cb5-8"><a href="#cb5-8"></a>        )[,.(Group,GA,Condition,SampleID,geneName,logCPM,<span class="at">logCPMZ=</span>(logCPM<span class="sc">-</span>Mean)<span class="sc">/</span>SD)]</span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="fu">save</span>(dt.cpmZ.term,<span class="at">file=</span>my.cpmZ.RData)</span>
<span id="cb5-10"><a href="#cb5-10"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-cv-prep-ext-val" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="sec-cv-prep-ext-val"><span class="header-section-number">3.1.2</span> External validation dataset</h3>
<p>For an external validation, we downloaded the raw sequencing counts file (<a href="https://www.science.org/doi/suppl/10.1126/scitranslmed.aaz0131/suppl_file/aaz0131_data_file_s2.xlsx">Data File S2</a>: Raw whole-transcriptome sequencing counts for iPEC cohort; n=113) from <a href="https://pubmed.ncbi.nlm.nih.gov/32611681/">Munchel et al.</a>. The Data File (in the excel file format) was read and parsed by using <a href="https://readxl.tidyverse.org/"><code>readxl</code></a> (v1.3.1) and <a href="https://rdatatable.gitlab.io/data.table/"><code>data.table</code></a> (v1.13.6) R packages, respectively.</p>
<p>For downstream processing, we only considered those genes in the final set of 15,150 genes that were used in the differentially expressed gene analysis of the discovery and the validation cohort (see <a href="quant.html#sec-mtd-deg-deseq2" class="quarto-xref"><span>Section 2.2.1</span></a>).</p>
<div class="cell">
<details class="code-fold">
<summary>Code to import Munchel dataset and make <code>dds</code> object by <code>DESeq2</code></summary>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a>my.dds.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dds.munchel.RData"</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.dds.RData)){</span>
<span id="cb6-3"><a href="#cb6-3"></a>  <span class="fu">load</span>(my.dds.RData)</span>
<span id="cb6-4"><a href="#cb6-4"></a>  <span class="fu">message</span>(<span class="st">"loading dds..."</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a>}<span class="cf">else</span>{</span>
<span id="cb6-6"><a href="#cb6-6"></a>  <span class="co"># import</span></span>
<span id="cb6-7"><a href="#cb6-7"></a>  dt.foo<span class="ot">&lt;-</span>readxl<span class="sc">::</span><span class="fu">read_excel</span>(<span class="st">"~/data/Munchel/SciTrMed.2020/aaz0131_data_file_s2.xlsx"</span>,<span class="at">skip=</span><span class="dv">3</span>) <span class="sc">%&gt;%</span> as.data.table</span>
<span id="cb6-8"><a href="#cb6-8"></a>  dt.foo[,<span class="sc">-</span><span class="fu">c</span>(<span class="st">"Chr"</span>,<span class="st">"Start"</span>,<span class="st">"End"</span>,<span class="st">"Strand"</span>)][<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-9"><a href="#cb6-9"></a></span>
<span id="cb6-10"><a href="#cb6-10"></a>  <span class="co"># sample info with GA of sample collection</span></span>
<span id="cb6-11"><a href="#cb6-11"></a>  dt.munchel.meta<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb6-12"><a href="#cb6-12"></a>                            <span class="at">names=</span>dt.foo[<span class="fu">is.na</span>(Geneid),<span class="sc">-</span><span class="fu">c</span>(<span class="st">"Geneid"</span>,<span class="st">"Chr"</span>,<span class="st">"Start"</span>,<span class="st">"End"</span>,<span class="st">"Strand"</span>,<span class="st">"Length"</span>)] <span class="sc">%&gt;%</span> </span>
<span id="cb6-13"><a href="#cb6-13"></a>                              colnames <span class="sc">%&gt;%</span> </span>
<span id="cb6-14"><a href="#cb6-14"></a>                              stringr<span class="sc">::</span><span class="fu">str_replace</span>(<span class="st">"</span><span class="sc">\\</span><span class="st">.</span><span class="sc">\\</span><span class="st">.</span><span class="sc">\\</span><span class="st">."</span>,<span class="st">""</span>),</span>
<span id="cb6-15"><a href="#cb6-15"></a>                            <span class="at">GA=</span>dt.foo[<span class="fu">is.na</span>(Geneid),<span class="sc">-</span><span class="fu">c</span>(<span class="st">"Geneid"</span>,<span class="st">"Chr"</span>,<span class="st">"Start"</span>,<span class="st">"End"</span>,<span class="st">"Strand"</span>,<span class="st">"Length"</span>)] <span class="sc">%&gt;%</span> unlist </span>
<span id="cb6-16"><a href="#cb6-16"></a>                            )</span>
<span id="cb6-17"><a href="#cb6-17"></a>  dt.munchel.meta[,Condition<span class="sc">:</span><span class="er">=</span><span class="fu">ifelse</span>(<span class="fu">grepl</span>(<span class="st">"PE"</span>,names),<span class="st">"Case"</span>,<span class="st">"Control"</span>)]</span>
<span id="cb6-18"><a href="#cb6-18"></a>  dt.munchel.meta<span class="sc">$</span>GA <span class="sc">%&gt;%</span> summary</span>
<span id="cb6-19"><a href="#cb6-19"></a>  dt.munchel.meta[,.N,Condition]</span>
<span id="cb6-20"><a href="#cb6-20"></a>  dt.munchel.meta[Condition<span class="sc">==</span><span class="st">"Control"</span>]<span class="sc">$</span>GA <span class="sc">%&gt;%</span> summary</span>
<span id="cb6-21"><a href="#cb6-21"></a>  dt.munchel.meta[Condition<span class="sc">==</span><span class="st">"Case"</span>]<span class="sc">$</span>GA <span class="sc">%&gt;%</span> summary</span>
<span id="cb6-22"><a href="#cb6-22"></a>  df.munchel.meta<span class="ot">&lt;-</span><span class="fu">data.frame</span>(dt.munchel.meta, <span class="at">row.names=</span>dt.munchel.meta<span class="sc">$</span>names)</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a>  <span class="co"># cnt </span></span>
<span id="cb6-25"><a href="#cb6-25"></a>  dt.munchel.cnt<span class="ot">&lt;-</span>dt.foo[<span class="sc">!</span><span class="fu">is.na</span>(Geneid),<span class="sc">-</span><span class="fu">c</span>(<span class="st">"Chr"</span>,<span class="st">"Start"</span>,<span class="st">"End"</span>,<span class="st">"Strand"</span>,<span class="st">"Length"</span>)]</span>
<span id="cb6-26"><a href="#cb6-26"></a>  dt.munchel.cnt <span class="sc">%&gt;%</span> dim <span class="co"># 26708 genes x 114 samples</span></span>
<span id="cb6-27"><a href="#cb6-27"></a>  dt.munchel.cnt[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-28"><a href="#cb6-28"></a>  <span class="fu">colnames</span>(dt.munchel.cnt)<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"gene_name"</span>,dt.munchel.meta<span class="sc">$</span>names) <span class="co"># update the sample names</span></span>
<span id="cb6-29"><a href="#cb6-29"></a>  dt.munchel.cnt[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-30"><a href="#cb6-30"></a>  dt.munchel.cnt[,.N,gene_name][N<span class="sc">&gt;</span><span class="dv">1</span>][<span class="fu">order</span>(<span class="sc">-</span>N)] <span class="co"># 0 duplicated gene names </span></span>
<span id="cb6-31"><a href="#cb6-31"></a></span>
<span id="cb6-32"><a href="#cb6-32"></a>  dt.munchel.cnt[<span class="fu">grepl</span>(<span class="st">"_dup"</span>,gene_name)][,.N,gene_name] <span class="co"># 1355 such gene names</span></span>
<span id="cb6-33"><a href="#cb6-33"></a>  dt.munchel.cnt[<span class="fu">grepl</span>(<span class="st">"_dup"</span>,gene_name)][<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-34"><a href="#cb6-34"></a></span>
<span id="cb6-35"><a href="#cb6-35"></a>  dt.munchel.cnt[,gene_name<span class="sc">:</span><span class="er">=</span><span class="fu">tstrsplit</span>(gene_name,<span class="st">"_dup"</span>,<span class="at">fixed=</span>T,<span class="at">keep=</span><span class="dv">1</span>L)]</span>
<span id="cb6-36"><a href="#cb6-36"></a>  dt.munchel.cnt[<span class="fu">grepl</span>(<span class="st">"_dup"</span>,gene_name)]</span>
<span id="cb6-37"><a href="#cb6-37"></a>  dt.munchel.cnt[,.N,gene_name][N<span class="sc">&gt;</span><span class="dv">1</span>][<span class="fu">order</span>(<span class="sc">-</span>N)] <span class="co"># 491 duplicated gene names</span></span>
<span id="cb6-38"><a href="#cb6-38"></a>  dt.munchel.cnt[gene_name<span class="sc">==</span><span class="st">"REXO1L2P"</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-39"><a href="#cb6-39"></a>  dt.munchel.cnt[,.N,gene_name <span class="sc">%in%</span> <span class="fu">rownames</span>(dds.f2)] <span class="co"># genes only in the dds.f2 (15150 genes)</span></span>
<span id="cb6-40"><a href="#cb6-40"></a>                                                      <span class="co"># TRUE 13555; FALSE 13153</span></span>
<span id="cb6-41"><a href="#cb6-41"></a>  <span class="fu">rownames</span>(dds.f2) <span class="sc">%in%</span> dt.munchel.cnt<span class="sc">$</span>gene_name <span class="sc">%&gt;%</span> table <span class="co"># from 15150 genesin dds.f2, 13469 genes in Munchel; 1681 genes not in Munchel</span></span>
<span id="cb6-42"><a href="#cb6-42"></a>  dds.f2[<span class="sc">!</span><span class="fu">rownames</span>(dds.f2) <span class="sc">%in%</span> dt.munchel.cnt<span class="sc">$</span>gene_name] <span class="sc">%&gt;%</span> names</span>
<span id="cb6-43"><a href="#cb6-43"></a></span>
<span id="cb6-44"><a href="#cb6-44"></a>  dt.munchel.cnt2<span class="ot">&lt;-</span> (dt.munchel.cnt[gene_name <span class="sc">%in%</span> <span class="fu">rownames</span>(dds.f2)] <span class="sc">%&gt;%</span> </span>
<span id="cb6-45"><a href="#cb6-45"></a>                     <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"gene_name"</span>), <span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"Cnt"</span>))[,.(<span class="at">Cnt=</span><span class="fu">sum</span>(Cnt)),.(SampleID,gene_name)] <span class="sc">%&gt;%</span> </span>
<span id="cb6-46"><a href="#cb6-46"></a>                      <span class="fu">dcast.data.table</span>(gene_name <span class="sc">~</span> SampleID, <span class="at">value.var=</span><span class="st">"Cnt"</span>)</span>
<span id="cb6-47"><a href="#cb6-47"></a>  <span class="fu">dim</span>(dt.munchel.cnt2) <span class="co"># 13469 genes x 114 samples</span></span>
<span id="cb6-48"><a href="#cb6-48"></a>  dt.munchel.cnt2[,.N,gene_name][N<span class="sc">&gt;</span><span class="dv">1</span>][<span class="fu">order</span>(<span class="sc">-</span>N)] <span class="co"># no duplicated genes</span></span>
<span id="cb6-49"><a href="#cb6-49"></a>  <span class="fu">all.equal</span>(<span class="fu">colnames</span>(dt.munchel.cnt),<span class="fu">colnames</span>(dt.munchel.cnt2))</span>
<span id="cb6-50"><a href="#cb6-50"></a></span>
<span id="cb6-51"><a href="#cb6-51"></a>  mat.munchel.cnt2<span class="ot">&lt;-</span>dt.munchel.cnt2 <span class="sc">%&gt;%</span> <span class="fu">as.matrix</span>(<span class="at">rownames=</span><span class="st">"gene_name"</span>)</span>
<span id="cb6-52"><a href="#cb6-52"></a>  <span class="fu">dim</span>(mat.munchel.cnt2) <span class="co"># 13469 x 113</span></span>
<span id="cb6-53"><a href="#cb6-53"></a>  mat.munchel.cnt2[<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>]</span>
<span id="cb6-54"><a href="#cb6-54"></a></span>
<span id="cb6-55"><a href="#cb6-55"></a>  <span class="fu">all.equal</span>(<span class="fu">colnames</span>(mat.munchel.cnt2), <span class="fu">rownames</span>(df.munchel.meta))</span>
<span id="cb6-56"><a href="#cb6-56"></a></span>
<span id="cb6-57"><a href="#cb6-57"></a>  dds.munchel<span class="ot">&lt;-</span><span class="fu">DESeqDataSetFromMatrix</span>(mat.munchel.cnt2, df.munchel.meta, <span class="at">design=</span><span class="fu">formula</span>(<span class="sc">~</span>Condition) )</span>
<span id="cb6-58"><a href="#cb6-58"></a></span>
<span id="cb6-59"><a href="#cb6-59"></a>  dds.munchel<span class="ot">&lt;-</span> <span class="fu">DESeq</span>(dds.munchel, <span class="at">parallel=</span><span class="cn">TRUE</span>) <span class="co"># isa 'DESeqDataSet'</span></span>
<span id="cb6-60"><a href="#cb6-60"></a>  <span class="fu">save</span>(dt.munchel.meta,dds.munchel,<span class="at">file=</span>my.dds.RData)</span>
<span id="cb6-61"><a href="#cb6-61"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Using the filtered gene-level raw count matrix, we ran edgeR and constructed a matrix of CPM, in log2-scale, via the “cpm” function of edgeR. The matrix was further transformed into a matrix of the z-score using the mean and standard deviation of logCPM from the 73 control samples.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to make the z-score matrix from the Munchel dataset</summary>
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a>my.cpmZ.RData<span class="ot">&lt;-</span><span class="fu">paste0</span>(<span class="st">"RData/dt.cpmZ.munchel.RData"</span>)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.cpmZ.RData)){</span>
<span id="cb7-3"><a href="#cb7-3"></a>  <span class="fu">load</span>(my.cpmZ.RData)</span>
<span id="cb7-4"><a href="#cb7-4"></a>}<span class="cf">else</span>{</span>
<span id="cb7-5"><a href="#cb7-5"></a>  <span class="fu">load</span>(<span class="st">"RData/dds.munchel.RData"</span>)</span>
<span id="cb7-6"><a href="#cb7-6"></a>  dds.munchel <span class="co"># samples from Discovery &amp; Validation1</span></span>
<span id="cb7-7"><a href="#cb7-7"></a></span>
<span id="cb7-8"><a href="#cb7-8"></a>  d.munchel <span class="ot">=</span> DEFormats<span class="sc">::</span><span class="fu">as.DGEList</span>(dds.munchel)</span>
<span id="cb7-9"><a href="#cb7-9"></a>  d.munchel<span class="ot">&lt;-</span><span class="fu">calcNormFactors</span>(d.munchel,<span class="at">method=</span><span class="st">"TMM"</span>) </span>
<span id="cb7-10"><a href="#cb7-10"></a></span>
<span id="cb7-11"><a href="#cb7-11"></a>  dt.logcpm2<span class="ot">&lt;-</span><span class="fu">merge</span>(</span>
<span id="cb7-12"><a href="#cb7-12"></a>      <span class="fu">data.table</span>(<span class="st">`</span><span class="at">geneName</span><span class="st">`</span><span class="ot">=</span><span class="fu">rownames</span>(d.munchel),<span class="fu">cpm</span>(d.munchel,<span class="at">log=</span>T)) <span class="sc">%&gt;%</span> </span>
<span id="cb7-13"><a href="#cb7-13"></a>        <span class="fu">melt.data.table</span>(<span class="at">id.vars=</span><span class="fu">c</span>(<span class="st">"geneName"</span>),<span class="at">variable.name=</span><span class="st">"SampleID"</span>,<span class="at">value.name=</span><span class="st">"logCPM"</span>),</span>
<span id="cb7-14"><a href="#cb7-14"></a>      df.munchel.meta,<span class="at">by.x=</span><span class="st">"SampleID"</span>,<span class="at">by.y=</span><span class="st">"names"</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>      )</span>
<span id="cb7-16"><a href="#cb7-16"></a></span>
<span id="cb7-17"><a href="#cb7-17"></a>  dt.cpmZ.munchel<span class="ot">=</span><span class="fu">merge</span>(dt.logcpm2,</span>
<span id="cb7-18"><a href="#cb7-18"></a>                dt.logcpm2[Condition<span class="sc">==</span><span class="st">"Control"</span>,.(<span class="at">Mean=</span><span class="fu">mean</span>(logCPM),<span class="at">SD=</span><span class="fu">sd</span>(logCPM)),.(geneName)]</span>
<span id="cb7-19"><a href="#cb7-19"></a>        ,<span class="at">by=</span><span class="fu">c</span>(<span class="st">"geneName"</span>)</span>
<span id="cb7-20"><a href="#cb7-20"></a>        )[,.(Condition,SampleID,geneName,logCPM,<span class="at">logCPMZ=</span>(logCPM<span class="sc">-</span>Mean)<span class="sc">/</span>SD)]</span>
<span id="cb7-21"><a href="#cb7-21"></a>  <span class="fu">save</span>(dt.cpmZ.munchel,<span class="at">file=</span>my.cpmZ.RData)</span>
<span id="cb7-22"><a href="#cb7-22"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
</section>
<section id="sec-cv-split" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="sec-cv-split"><span class="header-section-number">3.2</span> Data split for 5-fold CV</h2>
<p>We randomly split the samples into 5 strata by distributing the number of case and control outcomes as even as possible across the 5 folds. This stratified 5-fold splitting was repeated 5 times by changing a seed number in each repetition, and the 11 ML models (see below #sec-cv-11ML) were trained to choose a desired number of predictors from 2 to 6.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to split 5-fold with 5 repetitions</summary>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="fu">load</span>(<span class="st">"RData/dt.cpmZ.preterm.POPS-2022.GRCh38.88.RData"</span>) <span class="co"># dt.cpmZ (preterm)</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="fu">load</span>(<span class="st">"RData/dt.cpmZ.term.POPS-2022.GRCh38.88.RData"</span>) <span class="co"># dt.cpmZ.term (term)</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="fu">load</span>(<span class="st">"RData/dt.cpmZ.munchel.RData"</span>) <span class="co"># dt.cpmZ.munchel (Munchel)</span></span>
<span id="cb8-4"><a href="#cb8-4"></a></span>
<span id="cb8-5"><a href="#cb8-5"></a>li.mat<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co"># set the train dataset, i.e. preterm-28wk</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>li.mat[[<span class="st">"train"</span>]]<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">list</span>(<span class="st">`</span><span class="at">12wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"12wk"</span>,<span class="st">`</span><span class="at">20wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"20wk"</span>,<span class="st">`</span><span class="at">28wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"28wk"</span>), <span class="cf">function</span>(my.GA) {</span>
<span id="cb8-8"><a href="#cb8-8"></a>  dt.cpmZ[GA<span class="sc">==</span>my.GA <span class="sc">&amp;</span> geneName <span class="sc">%in%</span> core17,.(SampleID,geneName,logCPMZ,<span class="at">y=</span><span class="fu">ifelse</span>(Condition<span class="sc">==</span><span class="st">"Case"</span>,<span class="dv">1</span>,<span class="dv">0</span>))] <span class="sc">%&gt;%</span> <span class="fu">dcast.data.table</span>(SampleID<span class="sc">+</span>y<span class="sc">~</span>geneName,<span class="at">value.var=</span><span class="st">"logCPMZ"</span>) <span class="sc">%&gt;%</span> <span class="fu">as.matrix</span>(<span class="at">rownames=</span><span class="st">"SampleID"</span>) <span class="co"># isa 'list'</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>  })</span>
<span id="cb8-10"><a href="#cb8-10"></a></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="co"># set the test dataset, i.e. term</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>li.mat[[<span class="st">"test"</span>]]<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">list</span>(<span class="st">`</span><span class="at">12wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"12wk"</span>,<span class="st">`</span><span class="at">20wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"20wk"</span>,<span class="st">`</span><span class="at">28wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"28wk"</span>,<span class="st">`</span><span class="at">36wk</span><span class="st">`</span><span class="ot">=</span><span class="st">"36wk"</span>), <span class="cf">function</span>(my.GA) {</span>
<span id="cb8-13"><a href="#cb8-13"></a>    dt.cpmZ.term[GA<span class="sc">==</span>my.GA <span class="sc">&amp;</span> geneName <span class="sc">%in%</span> core17,.(SampleID,geneName,logCPMZ,<span class="at">y=</span><span class="fu">ifelse</span>(Condition<span class="sc">==</span><span class="st">"Case"</span>,<span class="dv">1</span>,<span class="dv">0</span>))] <span class="sc">%&gt;%</span> <span class="fu">dcast.data.table</span>(SampleID<span class="sc">+</span>y<span class="sc">~</span>geneName,<span class="at">value.var=</span><span class="st">"logCPMZ"</span>) <span class="sc">%&gt;%</span> <span class="fu">as.matrix</span>(<span class="at">rownames=</span><span class="st">"SampleID"</span>) <span class="co"># isa 'list'</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>  })</span>
<span id="cb8-15"><a href="#cb8-15"></a></span>
<span id="cb8-16"><a href="#cb8-16"></a>li.mat[[<span class="st">"munchel"</span>]]<span class="ot">&lt;-</span>dt.cpmZ.munchel[geneName <span class="sc">%in%</span> core17,.(SampleID,geneName,logCPMZ,<span class="at">y=</span><span class="fu">ifelse</span>(Condition<span class="sc">==</span><span class="st">"Case"</span>,<span class="dv">1</span>,<span class="dv">0</span>))] <span class="sc">%&gt;%</span> <span class="fu">dcast.data.table</span>(SampleID<span class="sc">+</span>y<span class="sc">~</span>geneName,<span class="at">value.var=</span><span class="st">"logCPMZ"</span>) <span class="sc">%&gt;%</span> <span class="fu">as.matrix</span>(<span class="at">rownames=</span><span class="st">"SampleID"</span>) <span class="co"># isa 'matrix'</span></span>
<span id="cb8-17"><a href="#cb8-17"></a></span>
<span id="cb8-18"><a href="#cb8-18"></a><span class="do">##############################################</span></span>
<span id="cb8-19"><a href="#cb8-19"></a><span class="co"># Set the 5-fold with 5 rep for 28wk preterm #</span></span>
<span id="cb8-20"><a href="#cb8-20"></a><span class="do">##############################################</span></span>
<span id="cb8-21"><a href="#cb8-21"></a><span class="co"># set stratified folds</span></span>
<span id="cb8-22"><a href="#cb8-22"></a><span class="co"># such that the numbers of cases and controls in each fold are the same for each fold (or, at least, as close to this as possible)</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>nFold<span class="ot">&lt;-</span><span class="dv">5</span>; nRep<span class="ot">&lt;-</span><span class="dv">5</span>; li.fold<span class="ot">&lt;-</span><span class="fu">list</span>() <span class="co"># index of training in </span></span>
<span id="cb8-24"><a href="#cb8-24"></a><span class="cf">for</span>(iRep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nRep){</span>
<span id="cb8-25"><a href="#cb8-25"></a>  caseInds <span class="ot">&lt;-</span> <span class="fu">which</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb8-26"><a href="#cb8-26"></a>  ctrlInds <span class="ot">&lt;-</span> <span class="fu">which</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb8-27"><a href="#cb8-27"></a></span>
<span id="cb8-28"><a href="#cb8-28"></a>  <span class="co">#Randomise for good measure:</span></span>
<span id="cb8-29"><a href="#cb8-29"></a>  <span class="fu">set.seed</span>(<span class="dv">123</span><span class="sc">+</span>iRep)</span>
<span id="cb8-30"><a href="#cb8-30"></a>  caseInds <span class="ot">&lt;-</span> caseInds[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(caseInds))]</span>
<span id="cb8-31"><a href="#cb8-31"></a>  ctrlInds <span class="ot">&lt;-</span> ctrlInds[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ctrlInds))]</span>
<span id="cb8-32"><a href="#cb8-32"></a></span>
<span id="cb8-33"><a href="#cb8-33"></a>  approximatelyEqualParts_Cases <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">cut_interval</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(caseInds), nFold)</span>
<span id="cb8-34"><a href="#cb8-34"></a>  approximatelyEqualParts_Ctrls <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">cut_interval</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ctrlInds), nFold)</span>
<span id="cb8-35"><a href="#cb8-35"></a></span>
<span id="cb8-36"><a href="#cb8-36"></a>  quintiles_Cases <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">length</span>(caseInds))</span>
<span id="cb8-37"><a href="#cb8-37"></a>  quintiles_Ctrls <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">length</span>(ctrlInds))</span>
<span id="cb8-38"><a href="#cb8-38"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">levels</span>(approximatelyEqualParts_Cases))){</span>
<span id="cb8-39"><a href="#cb8-39"></a>    currentLevel <span class="ot">&lt;-</span> <span class="fu">levels</span>(approximatelyEqualParts_Cases)[i]</span>
<span id="cb8-40"><a href="#cb8-40"></a>    quintiles_Cases[approximatelyEqualParts_Cases <span class="sc">==</span> currentLevel] <span class="ot">&lt;-</span> i</span>
<span id="cb8-41"><a href="#cb8-41"></a>  }</span>
<span id="cb8-42"><a href="#cb8-42"></a></span>
<span id="cb8-43"><a href="#cb8-43"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">levels</span>(approximatelyEqualParts_Ctrls))){</span>
<span id="cb8-44"><a href="#cb8-44"></a>    currentLevel <span class="ot">&lt;-</span> <span class="fu">levels</span>(approximatelyEqualParts_Ctrls)[i]</span>
<span id="cb8-45"><a href="#cb8-45"></a>    quintiles_Ctrls[approximatelyEqualParts_Ctrls <span class="sc">==</span> currentLevel] <span class="ot">&lt;-</span> i</span>
<span id="cb8-46"><a href="#cb8-46"></a>  }</span>
<span id="cb8-47"><a href="#cb8-47"></a></span>
<span id="cb8-48"><a href="#cb8-48"></a>  quintiles <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">nrow</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]]))</span>
<span id="cb8-49"><a href="#cb8-49"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nFold){</span>
<span id="cb8-50"><a href="#cb8-50"></a>    quintiles[<span class="fu">c</span>(caseInds[quintiles_Cases <span class="sc">==</span> i], ctrlInds[quintiles_Ctrls <span class="sc">==</span> i])] <span class="ot">&lt;-</span> i</span>
<span id="cb8-51"><a href="#cb8-51"></a>  }</span>
<span id="cb8-52"><a href="#cb8-52"></a></span>
<span id="cb8-53"><a href="#cb8-53"></a>    <span class="co"># Split the data into training and testing sets for this fold</span></span>
<span id="cb8-54"><a href="#cb8-54"></a>  <span class="cf">for</span>(iFold <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nFold){</span>
<span id="cb8-55"><a href="#cb8-55"></a>    li.fold[[<span class="fu">paste0</span>(<span class="st">"Fold"</span>,iFold,<span class="st">".Rep"</span>,iRep)]]<span class="ot">&lt;-</span><span class="fu">which</span>(quintiles <span class="sc">!=</span> iFold)</span>
<span id="cb8-56"><a href="#cb8-56"></a>  }</span>
<span id="cb8-57"><a href="#cb8-57"></a>} <span class="co"># end of iRep</span></span>
<span id="cb8-58"><a href="#cb8-58"></a></span>
<span id="cb8-59"><a href="#cb8-59"></a><span class="do">########################################</span></span>
<span id="cb8-60"><a href="#cb8-60"></a><span class="co"># Set the final 5-fold to use all_28wk #</span></span>
<span id="cb8-61"><a href="#cb8-61"></a><span class="do">########################################</span></span>
<span id="cb8-62"><a href="#cb8-62"></a>nFold<span class="ot">&lt;-</span><span class="dv">5</span>; nRep<span class="ot">&lt;-</span><span class="dv">1</span>; li.fold.final<span class="ot">&lt;-</span><span class="fu">list</span>() <span class="co"># index of training in </span></span>
<span id="cb8-63"><a href="#cb8-63"></a><span class="cf">for</span>(iRep <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nRep){</span>
<span id="cb8-64"><a href="#cb8-64"></a>  caseInds <span class="ot">&lt;-</span> <span class="fu">which</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">1</span>)</span>
<span id="cb8-65"><a href="#cb8-65"></a>  ctrlInds <span class="ot">&lt;-</span> <span class="fu">which</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">0</span>)</span>
<span id="cb8-66"><a href="#cb8-66"></a></span>
<span id="cb8-67"><a href="#cb8-67"></a>  <span class="co">#Randomise for good measure:</span></span>
<span id="cb8-68"><a href="#cb8-68"></a>  <span class="fu">set.seed</span>(<span class="dv">333</span>)</span>
<span id="cb8-69"><a href="#cb8-69"></a>  caseInds <span class="ot">&lt;-</span> caseInds[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(caseInds))]</span>
<span id="cb8-70"><a href="#cb8-70"></a>  ctrlInds <span class="ot">&lt;-</span> ctrlInds[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ctrlInds))]</span>
<span id="cb8-71"><a href="#cb8-71"></a></span>
<span id="cb8-72"><a href="#cb8-72"></a>  approximatelyEqualParts_Cases <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">cut_interval</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(caseInds), nFold)</span>
<span id="cb8-73"><a href="#cb8-73"></a>  approximatelyEqualParts_Ctrls <span class="ot">&lt;-</span> ggplot2<span class="sc">::</span><span class="fu">cut_interval</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ctrlInds), nFold)</span>
<span id="cb8-74"><a href="#cb8-74"></a></span>
<span id="cb8-75"><a href="#cb8-75"></a>  quintiles_Cases <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">length</span>(caseInds))</span>
<span id="cb8-76"><a href="#cb8-76"></a>  quintiles_Ctrls <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">length</span>(ctrlInds))</span>
<span id="cb8-77"><a href="#cb8-77"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">levels</span>(approximatelyEqualParts_Cases))){</span>
<span id="cb8-78"><a href="#cb8-78"></a>    currentLevel <span class="ot">&lt;-</span> <span class="fu">levels</span>(approximatelyEqualParts_Cases)[i]</span>
<span id="cb8-79"><a href="#cb8-79"></a>    quintiles_Cases[approximatelyEqualParts_Cases <span class="sc">==</span> currentLevel] <span class="ot">&lt;-</span> i</span>
<span id="cb8-80"><a href="#cb8-80"></a>  }</span>
<span id="cb8-81"><a href="#cb8-81"></a></span>
<span id="cb8-82"><a href="#cb8-82"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">levels</span>(approximatelyEqualParts_Ctrls))){</span>
<span id="cb8-83"><a href="#cb8-83"></a>    currentLevel <span class="ot">&lt;-</span> <span class="fu">levels</span>(approximatelyEqualParts_Ctrls)[i]</span>
<span id="cb8-84"><a href="#cb8-84"></a>    quintiles_Ctrls[approximatelyEqualParts_Ctrls <span class="sc">==</span> currentLevel] <span class="ot">&lt;-</span> i</span>
<span id="cb8-85"><a href="#cb8-85"></a>  }</span>
<span id="cb8-86"><a href="#cb8-86"></a></span>
<span id="cb8-87"><a href="#cb8-87"></a>  quintiles <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="at">mode =</span> <span class="st">"integer"</span>, <span class="at">length =</span> <span class="fu">nrow</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]]))</span>
<span id="cb8-88"><a href="#cb8-88"></a>  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nFold){</span>
<span id="cb8-89"><a href="#cb8-89"></a>    quintiles[<span class="fu">c</span>(caseInds[quintiles_Cases <span class="sc">==</span> i], ctrlInds[quintiles_Ctrls <span class="sc">==</span> i])] <span class="ot">&lt;-</span> i</span>
<span id="cb8-90"><a href="#cb8-90"></a>  }</span>
<span id="cb8-91"><a href="#cb8-91"></a></span>
<span id="cb8-92"><a href="#cb8-92"></a>    <span class="co"># Split the data into training and testing sets for this fold</span></span>
<span id="cb8-93"><a href="#cb8-93"></a>  <span class="cf">for</span>(iFold <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>nFold){</span>
<span id="cb8-94"><a href="#cb8-94"></a>    li.fold.final[[<span class="fu">paste0</span>(<span class="st">"Fold"</span>,iFold,<span class="st">".Rep"</span>,iRep)]]<span class="ot">&lt;-</span><span class="fu">which</span>(quintiles <span class="sc">!=</span> iFold)</span>
<span id="cb8-95"><a href="#cb8-95"></a>  }</span>
<span id="cb8-96"><a href="#cb8-96"></a>} <span class="co"># end of iRep</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-cv-11ML" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="sec-cv-11ML"><span class="header-section-number">3.3</span> 11 machine learning methods</h2>
<p>We considered a total of 11 ML methods to select the best performing method based on the 5-fold cross-validation (CV) with 5 repetitions.</p>
<div id="fig-11ML" class="quarto-figure quarto-figure-center quarto-float anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-11ML-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="static/figure/cfRNA.11ML.png" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-11ML-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;3.1: 11 machine-learning methods considered in this study
</figcaption>
</figure>
</div>
<p>For the three penalised regression methods (ENet1, ENet2 and LASSO), they were firstly fitted by using the <a href="https://topepo.github.io/caret/model-training-and-tuning.html">train</a> function for the two Elastic net methods (ENet1 and ENet2) and the <a href="https://glmnet.stanford.edu/reference/cv.glmnet.html">cv.glmnet</a> function for LASSO, from <a href="https://topepo.github.io/caret/">the caret</a> (v6.0.94) and <a href="https://glmnet.stanford.edu/">the glmnet</a> (v.4.1.2) R package, respectively. For ENet1, both the parameter <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\lambda\)</span> were tuned by the <code>caret::train</code>, whereas the parameter <span class="math inline">\(\lambda\)</span> was further tuned by the <code>glmnet::cv.glmnet</code> for ENet2.</p>
<p>Next, based on the best fitted penalised regression models, a matrix of the <span class="math inline">\(\beta\)</span> coefficient was examined to find the first set of predictors with non-zero <span class="math inline">\(\beta\)</span> coefficients that satisfied a desired number of predictors. If the number of predictors with non-zero coefficients exceeded the desired number, the absolute values of coefficients were sorted in their decreasing order and only the desired number of predictors were selected with their highest absolute scores.</p>
<p>For the remaining methods, except <a href="https://github.com/johncolby/SVM-RFE">mSVM-RFE</a> (see also <a href="#sec-cv-svm-rfe" class="quarto-xref"><span>Section 3.3.2</span></a>) which embedded a Recursive Feature Elimination (RFE) algorithm internally, we used the <a href="https://topepo.github.io/caret/recursive-feature-elimination.html#recursive-feature-elimination-via-caret"><code>caret::rfe</code></a> function by controlling the “sizes” parameter to have the corresponding models with the desired number of predictors.</p>
<section id="sec-cv-glParallel" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="sec-cv-glParallel"><span class="header-section-number">3.3.1</span> <code>glParallel</code></h3>
<p>In <a href="https://gitlab.developers.cam.ac.uk/ssg29/glparallel">glParallel</a>, a brute-force exhaustive search method, for a given number of predictors, it searched all possible combinations of predictors in multivariate regression models and picked the best model based on the highest predictive performance.</p>
<p>For example, glParallel trained a total of 2,380 models, which is the possible number of combinations having 4 predictors out of 17, and chose the best model based on the highest <a href="https://pubmed.ncbi.nlm.nih.gov/24966219/">Leave Pair Out Cross Validated (LPOCV)</a> Area Under the ROC Curve (AUC), a version of optimism-corrected AUC.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Install `glParallel`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Install <code>glParallel</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>You need to download and install <code>glParallel</code> locally via the following <code>git</code> command:</p>
<div id="lst-clone-glParallel" class="bash listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-clone-glParallel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;3.1: Code to download <code>glParallel</code>
</figcaption>
<div aria-describedby="lst-clone-glParallel-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-clone-glParallel"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="lst-clone-glParallel-1"><a href="#lst-clone-glParallel-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://gitlab.developers.cam.ac.uk/ssg29/glparallel.git static/R/glParallel</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
</div>
</div>
<p>Then, prepare dataset to run <code>glParallel</code>.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to prepare dataset for <code>glParallel</code></summary>
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="do">#####################################################</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co"># make training dataset files for the CV glParallel #</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="do">#####################################################</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="fu">lapply</span>(<span class="fu">names</span>(li.fold), <span class="cf">function</span>(i){</span>
<span id="cb9-5"><a href="#cb9-5"></a>  <span class="fu">message</span>(<span class="st">"fold="</span>,i)</span>
<span id="cb9-6"><a href="#cb9-6"></a>  <span class="co"># training set</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>  my.index<span class="ot">=</span>li.fold[[i]]</span>
<span id="cb9-8"><a href="#cb9-8"></a>  my.file.name<span class="ot">=</span><span class="fu">file.path</span>(<span class="st">"glParallel/data"</span>,<span class="fu">paste</span>(<span class="st">"core17"</span>,i,<span class="st">"csv"</span>,<span class="at">sep=</span><span class="st">"."</span>))</span>
<span id="cb9-9"><a href="#cb9-9"></a>  <span class="fu">fwrite</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][my.index,], <span class="at">file=</span>my.file.name)</span>
<span id="cb9-10"><a href="#cb9-10"></a>})</span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co"># then run glParallel (see glParallel/RUN)</span></span>
<span id="cb9-12"><a href="#cb9-12"></a></span>
<span id="cb9-13"><a href="#cb9-13"></a><span class="do">####################################################</span></span>
<span id="cb9-14"><a href="#cb9-14"></a><span class="co"># make training dataset files for final glParallel #</span></span>
<span id="cb9-15"><a href="#cb9-15"></a><span class="do">####################################################</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="fu">fwrite</span>(li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]], <span class="at">file=</span><span class="st">"glParallel/data/core17.final.csv"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="LPOCV-AUC">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
LPOCV-AUC
</div>
</div>
<div class="callout-body-container callout-body">
<p>In LPOCV-AUC, a model was fitted based on a given set of training samples except one pair of case-and-control, then the model was used to predict the outcome of the remaining pair. The LPOCV-AUC was calculated as the proportion of all pairwise combinations in which the predicted probability was greater for the case than for the control. There is a helper function to calculate the LPOCV-AUC in <a href="https://gitlab.developers.cam.ac.uk/ssg29/glparallel/-/blob/main/lib/local.R?ref_type=heads#L68"><code>glParallel</code></a></p>
</div>
</div>
</section>
<section id="sec-cv-svm-rfe" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="sec-cv-svm-rfe"><span class="header-section-number">3.3.2</span> <code>mSVM-RFE</code></h3>
<p>This method is from the (multiple) Support Vector Machine Recursive Feature Elimination <a href="https://github.com/johncolby/SVM-RFE">(mSVM-RFE)</a>.</p>
<div class="callout callout-style-default callout-note callout-titled" title="Install `SVM-RFE`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Install <code>SVM-RFE</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>You need to download nad install <code>SVM-RFE</code> locally via the following <code>git</code> command:</p>
<div id="lst-clone-svm-rfe" class="bash listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-lst" id="lst-clone-svm-rfe-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;3.2: Code to download <code>SVM-RFE</code>
</figcaption>
<div aria-describedby="lst-clone-svm-rfe-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="sourceCode" id="lst-clone-svm-rfe"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="lst-clone-svm-rfe-1"><a href="#lst-clone-svm-rfe-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> clone https://github.com/johncolby/SVM-RFE.git static/R/SVM-RFE</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-5fold-cv" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="sec-5fold-cv"><span class="header-section-number">3.4</span> 5-Fold cross validation</h2>
<p>We defined a series of helper functions to facilitate the whole process of CV more efficient.</p>
<div class="callout callout-style-default callout-tip callout-titled" title="`R` function `get_lasso_coef`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>R</code> function <code>get_lasso_coef</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This helper function runs <a href="https://en.wikipedia.org/wiki/Lasso_(statistics)">LASSO</a> and ranks features by their importance.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to run Lasso and get non-zero coefficient</summary>
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="co"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>get_lasso_coef<span class="ot">&lt;-</span><span class="cf">function</span>(x,my.fold,<span class="at">my.num=</span><span class="dv">4</span>){</span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="co">#x isa `matrix` and should contain 'y' column</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  all.features<span class="ot">&lt;-</span><span class="fu">colnames</span>(x)[<span class="fu">colnames</span>(x)<span class="sc">!=</span><span class="st">"y"</span>]</span>
<span id="cb10-5"><a href="#cb10-5"></a></span>
<span id="cb10-6"><a href="#cb10-6"></a>  <span class="do">#############</span></span>
<span id="cb10-7"><a href="#cb10-7"></a>  <span class="co"># run Lasso #</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="do">#############</span></span>
<span id="cb10-9"><a href="#cb10-9"></a>  <span class="fu">set.seed</span>(<span class="dv">333</span>) <span class="co"># set a random seed for a reproducibility</span></span>
<span id="cb10-10"><a href="#cb10-10"></a>  <span class="fu">system.time</span>(</span>
<span id="cb10-11"><a href="#cb10-11"></a>      cv.fit<span class="ot">&lt;-</span><span class="fu">cv.glmnet</span>(</span>
<span id="cb10-12"><a href="#cb10-12"></a>                  <span class="at">x=</span> x[,all.features], </span>
<span id="cb10-13"><a href="#cb10-13"></a>                  <span class="at">y=</span> x[,<span class="st">'y'</span>], </span>
<span id="cb10-14"><a href="#cb10-14"></a>                  <span class="at">family=</span><span class="st">"binomial"</span>,</span>
<span id="cb10-15"><a href="#cb10-15"></a>                  <span class="at">alpha=</span><span class="dv">1</span>, <span class="co"># default (i.e. lasso)</span></span>
<span id="cb10-16"><a href="#cb10-16"></a>                  <span class="at">keep=</span>T, <span class="co"># FALSE by default</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>                  <span class="at">type.measure =</span> <span class="st">"auc"</span> <span class="co">#type.measure="class" # default for 'binomial'</span></span>
<span id="cb10-18"><a href="#cb10-18"></a>      )</span>
<span id="cb10-19"><a href="#cb10-19"></a>  )</span>
<span id="cb10-20"><a href="#cb10-20"></a></span>
<span id="cb10-21"><a href="#cb10-21"></a>  <span class="do">############################################</span></span>
<span id="cb10-22"><a href="#cb10-22"></a>  <span class="co"># 1. select by lambda.min  &amp; 2. lambda.1se #</span></span>
<span id="cb10-23"><a href="#cb10-23"></a>  <span class="do">############################################</span></span>
<span id="cb10-24"><a href="#cb10-24"></a>  dt.foo<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"lambda.min"</span>,<span class="st">"lambda.1se"</span>), <span class="cf">function</span>(my.lambda){</span>
<span id="cb10-25"><a href="#cb10-25"></a>    coeff1<span class="ot">&lt;-</span><span class="fu">coef</span>(cv.fit, <span class="at">s =</span> my.lambda) <span class="sc">%&gt;%</span> as.matrix <span class="co">#Extract coefficients from this glmnet object</span></span>
<span id="cb10-26"><a href="#cb10-26"></a>    nZero1<span class="ot">&lt;-</span>coeff1[coeff1[,<span class="st">"s1"</span>]<span class="sc">!=</span><span class="dv">0</span>,,drop<span class="ot">=</span>F][<span class="sc">-</span><span class="dv">1</span>,,drop<span class="ot">=</span>F] <span class="sc">%&gt;%</span> nrow <span class="co"># the number of non-zero coeff</span></span>
<span id="cb10-27"><a href="#cb10-27"></a>    <span class="cf">if</span>(nZero1<span class="sc">==</span><span class="dv">0</span>){</span>
<span id="cb10-28"><a href="#cb10-28"></a>      dt.foo<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb10-29"><a href="#cb10-29"></a>                        <span class="at">method=</span>my.lambda,</span>
<span id="cb10-30"><a href="#cb10-30"></a>                        <span class="at">fold=</span>my.fold,</span>
<span id="cb10-31"><a href="#cb10-31"></a>                        <span class="st">`</span><span class="at">feature</span><span class="st">`</span><span class="ot">=</span><span class="cn">NA</span>,</span>
<span id="cb10-32"><a href="#cb10-32"></a>                        <span class="at">score=</span><span class="cn">NA</span>)</span>
<span id="cb10-33"><a href="#cb10-33"></a>    }<span class="cf">else</span>{</span>
<span id="cb10-34"><a href="#cb10-34"></a>      coeff1[coeff1[,<span class="st">"s1"</span>]<span class="sc">!=</span><span class="dv">0</span>,,drop<span class="ot">=</span>F][<span class="sc">-</span><span class="dv">1</span>,,drop<span class="ot">=</span>F] </span>
<span id="cb10-35"><a href="#cb10-35"></a>      coeff1[coeff1[,<span class="st">"s1"</span>]<span class="sc">!=</span><span class="dv">0</span>,,drop<span class="ot">=</span>F][<span class="sc">-</span><span class="dv">1</span>,,drop<span class="ot">=</span>F] <span class="sc">%&gt;%</span> <span class="fu">as.data.table</span>(<span class="at">keep.rownames=</span>T) <span class="co"># return DT(rn,s1)</span></span>
<span id="cb10-36"><a href="#cb10-36"></a>      dt.foo<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb10-37"><a href="#cb10-37"></a>                        <span class="at">method=</span>my.lambda,</span>
<span id="cb10-38"><a href="#cb10-38"></a>                        <span class="at">fold=</span>my.fold,</span>
<span id="cb10-39"><a href="#cb10-39"></a>                        coeff1[coeff1[,<span class="st">"s1"</span>]<span class="sc">!=</span><span class="dv">0</span>,,<span class="at">drop=</span>F][<span class="sc">-</span><span class="dv">1</span>,,<span class="at">drop=</span>F] <span class="sc">%&gt;%</span> <span class="fu">as.data.table</span>(<span class="at">keep.rownames=</span>T))</span>
<span id="cb10-40"><a href="#cb10-40"></a>    }</span>
<span id="cb10-41"><a href="#cb10-41"></a>    <span class="fu">setnames</span>(dt.foo,<span class="fu">c</span>(<span class="st">"method"</span>,<span class="st">"fold"</span>,<span class="st">"feature"</span>,<span class="st">"score"</span>))</span>
<span id="cb10-42"><a href="#cb10-42"></a>    dt.foo</span>
<span id="cb10-43"><a href="#cb10-43"></a>  }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb10-44"><a href="#cb10-44"></a></span>
<span id="cb10-45"><a href="#cb10-45"></a>  <span class="do">####################</span></span>
<span id="cb10-46"><a href="#cb10-46"></a>  <span class="co"># 3. Lasso-pathway #</span></span>
<span id="cb10-47"><a href="#cb10-47"></a>  <span class="do">####################</span></span>
<span id="cb10-48"><a href="#cb10-48"></a>  mat.beta <span class="ot">&lt;-</span> cv.fit<span class="sc">$</span>glmnet.fit<span class="sc">$</span>beta <span class="sc">%&gt;%</span> as.matrix</span>
<span id="cb10-49"><a href="#cb10-49"></a>  <span class="fu">apply</span>(mat.beta, <span class="dv">2</span>, <span class="cf">function</span>(i){<span class="fu">table</span>(i<span class="sc">!=</span><span class="dv">0</span>)[<span class="st">"TRUE"</span>]})</span>
<span id="cb10-50"><a href="#cb10-50"></a>  my.lambdas<span class="ot">&lt;-</span><span class="fu">apply</span>(mat.beta, <span class="dv">2</span>, <span class="cf">function</span>(i){<span class="fu">table</span>(i<span class="sc">!=</span><span class="dv">0</span>)[<span class="st">"TRUE"</span>]})<span class="sc">&gt;=</span>my.num</span>
<span id="cb10-51"><a href="#cb10-51"></a>  this.index<span class="ot">&lt;-</span>my.lambdas[my.lambdas <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(my.lambdas)][<span class="dv">1</span>] <span class="sc">%&gt;%</span> names <span class="co"># the first index &gt;=my.num</span></span>
<span id="cb10-52"><a href="#cb10-52"></a>  <span class="cf">if</span>(<span class="fu">is.na</span>(this.index)){</span>
<span id="cb10-53"><a href="#cb10-53"></a>    <span class="cn">NULL</span></span>
<span id="cb10-54"><a href="#cb10-54"></a>  }<span class="cf">else</span>{</span>
<span id="cb10-55"><a href="#cb10-55"></a>    this.index.num <span class="ot">&lt;-</span> (<span class="fu">strsplit</span>(this.index,<span class="st">"s"</span>)[[<span class="dv">1</span>]][<span class="dv">2</span>] <span class="sc">%&gt;%</span> as.integer) <span class="sc">+</span><span class="dv">1</span></span>
<span id="cb10-56"><a href="#cb10-56"></a>    nZero<span class="ot">&lt;-</span><span class="fu">sum</span>(mat.beta[,this.index]<span class="sc">!=</span><span class="dv">0</span>, <span class="at">na.rm=</span>T) <span class="co"># number of non-zero coefficient</span></span>
<span id="cb10-57"><a href="#cb10-57"></a>    <span class="co">#mat.beta[mat.beta[,this.index]!=0,this.index,drop=F]</span></span>
<span id="cb10-58"><a href="#cb10-58"></a>    dt.bar<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb10-59"><a href="#cb10-59"></a>                      <span class="at">method=</span><span class="st">"LASSO"</span>,</span>
<span id="cb10-60"><a href="#cb10-60"></a>                      <span class="at">fold=</span>my.fold,</span>
<span id="cb10-61"><a href="#cb10-61"></a>                      mat.beta[mat.beta[,this.index.num]<span class="sc">!=</span><span class="dv">0</span>,this.index.num,<span class="at">drop=</span>F] <span class="sc">%&gt;%</span> <span class="fu">as.data.table</span>(<span class="at">keep.rownames=</span>T)</span>
<span id="cb10-62"><a href="#cb10-62"></a>    ) <span class="co"># save as the above</span></span>
<span id="cb10-63"><a href="#cb10-63"></a>    <span class="fu">setnames</span>(dt.bar,<span class="fu">c</span>(<span class="st">"method"</span>,<span class="st">"fold"</span>,<span class="st">"feature"</span>,<span class="st">"score"</span>))</span>
<span id="cb10-64"><a href="#cb10-64"></a></span>
<span id="cb10-65"><a href="#cb10-65"></a>    <span class="cf">if</span>(<span class="fu">nrow</span>(dt.bar)<span class="sc">&gt;</span>my.num){</span>
<span id="cb10-66"><a href="#cb10-66"></a>      dt.bar<span class="ot">&lt;-</span>dt.bar[<span class="fu">order</span>(method,fold,<span class="sc">-</span><span class="fu">abs</span>(score))][<span class="dv">1</span><span class="sc">:</span>my.num]</span>
<span id="cb10-67"><a href="#cb10-67"></a>    }</span>
<span id="cb10-68"><a href="#cb10-68"></a></span>
<span id="cb10-69"><a href="#cb10-69"></a>    dt.baz<span class="ot">&lt;-</span><span class="fu">rbind</span>(dt.foo, dt.bar)</span>
<span id="cb10-70"><a href="#cb10-70"></a>    dt.baz<span class="ot">&lt;-</span>dt.baz[<span class="fu">order</span>(method,fold,<span class="sc">-</span><span class="fu">abs</span>(score))][,rank<span class="sc">:</span><span class="er">=</span><span class="dv">1</span><span class="sc">:</span>.N,.(method,fold)]</span>
<span id="cb10-71"><a href="#cb10-71"></a>    <span class="fu">return</span>(dt.baz)</span>
<span id="cb10-72"><a href="#cb10-72"></a>  }</span>
<span id="cb10-73"><a href="#cb10-73"></a>} <span class="co"># end of get_lasso_coef</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="`R` function `get_enet_coef`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>R</code> function <code>get_enet_coef</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This helper function runs <a href="https://en.wikipedia.org/wiki/Elastic_net_regularization">Elastic net</a> and rank features by their importance.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to run ENet1 and ENet2 and get non-zero coefficients</summary>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a><span class="co"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>get_enet_coef<span class="ot">&lt;-</span><span class="cf">function</span>(x,my.fold,<span class="at">my.num=</span><span class="dv">4</span>){</span>
<span id="cb11-3"><a href="#cb11-3"></a>  <span class="co">#x isa `matrix` and should contain 'y' column</span></span>
<span id="cb11-4"><a href="#cb11-4"></a>  all.features<span class="ot">&lt;-</span><span class="fu">colnames</span>(x)[<span class="fu">colnames</span>(x)<span class="sc">!=</span><span class="st">"y"</span>]</span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a>  cv.fit<span class="ot">&lt;-</span><span class="fu">list</span>()</span>
<span id="cb11-7"><a href="#cb11-7"></a>  <span class="do">##########</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>  <span class="co"># E: EN1 #</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>  <span class="do">##########</span></span>
<span id="cb11-10"><a href="#cb11-10"></a>  cl <span class="ot">&lt;-</span> <span class="fu">makePSOCKcluster</span>(<span class="dv">8</span>) <span class="co"># No. of cores to use</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>  <span class="fu">registerDoParallel</span>(cl)</span>
<span id="cb11-12"><a href="#cb11-12"></a>  <span class="fu">set.seed</span>(<span class="dv">333</span>) <span class="co"># set a random seed for a reproducibility</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>  <span class="fu">system.time</span>(</span>
<span id="cb11-14"><a href="#cb11-14"></a>      cv.fit[[<span class="st">"E"</span>]]<span class="ot">&lt;-</span>caret<span class="sc">::</span><span class="fu">train</span>(</span>
<span id="cb11-15"><a href="#cb11-15"></a>                              <span class="at">x=</span> x[,all.features], </span>
<span id="cb11-16"><a href="#cb11-16"></a>                              <span class="at">y=</span><span class="fu">factor</span>(<span class="fu">ifelse</span>(x[,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">1</span>,<span class="st">'case'</span>,<span class="st">'non_case'</span>),<span class="at">levels=</span><span class="fu">c</span>(<span class="st">"non_case"</span>,<span class="st">"case"</span>)),</span>
<span id="cb11-17"><a href="#cb11-17"></a>                              <span class="at">method=</span><span class="st">"glmnet"</span>,</span>
<span id="cb11-18"><a href="#cb11-18"></a>                              <span class="at">family=</span><span class="st">"binomial"</span>,</span>
<span id="cb11-19"><a href="#cb11-19"></a>                              <span class="at">trControl =</span> <span class="fu">trainControl</span>(<span class="at">method =</span> <span class="st">"cv"</span>,</span>
<span id="cb11-20"><a href="#cb11-20"></a>                                                        <span class="at">summaryFunction =</span> twoClassSummary,</span>
<span id="cb11-21"><a href="#cb11-21"></a>                                                        <span class="at">classProbs =</span> <span class="cn">TRUE</span>,</span>
<span id="cb11-22"><a href="#cb11-22"></a>                                                        <span class="at">savePredictions =</span> T,</span>
<span id="cb11-23"><a href="#cb11-23"></a>                                                        <span class="at">verboseIter =</span> T,</span>
<span id="cb11-24"><a href="#cb11-24"></a>                                                        ),  <span class="co"># number =10 by default for "cv"</span></span>
<span id="cb11-25"><a href="#cb11-25"></a>                              <span class="at">tuneLength=</span><span class="dv">10</span>, <span class="co"># grid size: 10(alpha) * 10(lambda) </span></span>
<span id="cb11-26"><a href="#cb11-26"></a>      )</span>
<span id="cb11-27"><a href="#cb11-27"></a>  )</span>
<span id="cb11-28"><a href="#cb11-28"></a>  <span class="fu">stopCluster</span>(cl)</span>
<span id="cb11-29"><a href="#cb11-29"></a></span>
<span id="cb11-30"><a href="#cb11-30"></a>  <span class="cf">if</span>(F){</span>
<span id="cb11-31"><a href="#cb11-31"></a>  <span class="fu">varImp</span>(cv.fit[[<span class="st">"E"</span>]], <span class="at">useModel=</span>T)</span>
<span id="cb11-32"><a href="#cb11-32"></a>  <span class="fu">varImp</span>(cv.fit[[<span class="st">"E"</span>]], <span class="at">useModel=</span>F, <span class="at">nonpara=</span>F, <span class="at">scale=</span>T)</span>
<span id="cb11-33"><a href="#cb11-33"></a>  <span class="fu">predictors</span>(cv.fit<span class="sc">$</span>E) <span class="co"># features used in the model</span></span>
<span id="cb11-34"><a href="#cb11-34"></a>  }</span>
<span id="cb11-35"><a href="#cb11-35"></a></span>
<span id="cb11-36"><a href="#cb11-36"></a>  mat.beta<span class="ot">&lt;-</span> cv.fit<span class="sc">$</span>E<span class="sc">$</span>finalModel<span class="sc">$</span>beta <span class="sc">%&gt;%</span> as.matrix</span>
<span id="cb11-37"><a href="#cb11-37"></a>  my.lambdas<span class="ot">&lt;-</span><span class="fu">apply</span>(mat.beta, <span class="dv">2</span>, <span class="cf">function</span>(i){<span class="fu">table</span>(i<span class="sc">!=</span><span class="dv">0</span>)[<span class="st">"TRUE"</span>]})<span class="sc">&gt;=</span>my.num</span>
<span id="cb11-38"><a href="#cb11-38"></a>  this.index<span class="ot">&lt;-</span>my.lambdas[my.lambdas <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(my.lambdas)][<span class="dv">1</span>] <span class="sc">%&gt;%</span> names</span>
<span id="cb11-39"><a href="#cb11-39"></a>  <span class="cf">if</span>(<span class="fu">is.na</span>(this.index)){</span>
<span id="cb11-40"><a href="#cb11-40"></a>    dt.foo<span class="ot">&lt;-</span><span class="cn">NULL</span></span>
<span id="cb11-41"><a href="#cb11-41"></a>  }<span class="cf">else</span>{</span>
<span id="cb11-42"><a href="#cb11-42"></a>    this.index.num <span class="ot">&lt;-</span> (<span class="fu">strsplit</span>(this.index,<span class="st">"s"</span>)[[<span class="dv">1</span>]][<span class="dv">2</span>] <span class="sc">%&gt;%</span> as.integer) <span class="sc">+</span><span class="dv">1</span></span>
<span id="cb11-43"><a href="#cb11-43"></a>    <span class="co">#mat.beta[mat.beta[,this.index.num]!=0,this.index.num,drop=F] %&gt;% as.data.table(keep.rownames=T)</span></span>
<span id="cb11-44"><a href="#cb11-44"></a>    dt.foo<span class="ot">&lt;-</span><span class="fu">data.table</span>(<span class="at">method=</span><span class="st">"ENet1"</span>,</span>
<span id="cb11-45"><a href="#cb11-45"></a>                      <span class="at">fold=</span>my.fold,</span>
<span id="cb11-46"><a href="#cb11-46"></a>                      mat.beta[mat.beta[,this.index.num]<span class="sc">!=</span><span class="dv">0</span>,this.index.num,<span class="at">drop=</span>F] <span class="sc">%&gt;%</span> <span class="fu">as.data.table</span>(<span class="at">keep.rownames=</span>T)) <span class="co"># save as the above</span></span>
<span id="cb11-47"><a href="#cb11-47"></a>    <span class="fu">setnames</span>(dt.foo,<span class="fu">c</span>(<span class="st">"method"</span>,<span class="st">"fold"</span>,<span class="st">"feature"</span>,<span class="st">"score"</span>))</span>
<span id="cb11-48"><a href="#cb11-48"></a>    <span class="cf">if</span>(<span class="fu">nrow</span>(dt.foo)<span class="sc">&gt;</span>my.num){</span>
<span id="cb11-49"><a href="#cb11-49"></a>      dt.foo<span class="ot">&lt;-</span>dt.foo[<span class="fu">order</span>(method,fold,<span class="sc">-</span><span class="fu">abs</span>(score))][<span class="dv">1</span><span class="sc">:</span>my.num]</span>
<span id="cb11-50"><a href="#cb11-50"></a>    }</span>
<span id="cb11-51"><a href="#cb11-51"></a>  }</span>
<span id="cb11-52"><a href="#cb11-52"></a></span>
<span id="cb11-53"><a href="#cb11-53"></a>  <span class="do">##########</span></span>
<span id="cb11-54"><a href="#cb11-54"></a>  <span class="co"># F: EN2 #</span></span>
<span id="cb11-55"><a href="#cb11-55"></a>  <span class="do">##########</span></span>
<span id="cb11-56"><a href="#cb11-56"></a>  <span class="fu">set.seed</span>(<span class="dv">333</span>)</span>
<span id="cb11-57"><a href="#cb11-57"></a>  <span class="fu">system.time</span>(</span>
<span id="cb11-58"><a href="#cb11-58"></a>      cv.fit[[<span class="st">"F"</span>]]<span class="ot">&lt;-</span><span class="fu">cv.glmnet</span>(</span>
<span id="cb11-59"><a href="#cb11-59"></a>                  <span class="at">x=</span> x[,all.features], </span>
<span id="cb11-60"><a href="#cb11-60"></a>                  <span class="at">y=</span> x[,<span class="st">"y"</span>], <span class="co"># will be coerced to a factor if not (for binomial)</span></span>
<span id="cb11-61"><a href="#cb11-61"></a>                  <span class="at">family=</span><span class="st">"binomial"</span>,</span>
<span id="cb11-62"><a href="#cb11-62"></a>                  <span class="at">alpha=</span>cv.fit<span class="sc">$</span>E<span class="sc">$</span>bestTune<span class="sc">$</span>alpha,</span>
<span id="cb11-63"><a href="#cb11-63"></a>                  <span class="at">keep=</span>T, <span class="co"># FALSE by default</span></span>
<span id="cb11-64"><a href="#cb11-64"></a>                  <span class="at">type.measure =</span> <span class="st">"auc"</span> <span class="co">#type.measure="class" # default for 'binomial'</span></span>
<span id="cb11-65"><a href="#cb11-65"></a>      )</span>
<span id="cb11-66"><a href="#cb11-66"></a>  )</span>
<span id="cb11-67"><a href="#cb11-67"></a>  <span class="co">#cv.fit$F$nzero</span></span>
<span id="cb11-68"><a href="#cb11-68"></a>  mat.beta2 <span class="ot">&lt;-</span> cv.fit<span class="sc">$</span>F<span class="sc">$</span>glmnet.fit<span class="sc">$</span>beta <span class="sc">%&gt;%</span> as.matrix</span>
<span id="cb11-69"><a href="#cb11-69"></a>  my.lambdas<span class="ot">&lt;-</span><span class="fu">apply</span>(mat.beta2, <span class="dv">2</span>, <span class="cf">function</span>(i){<span class="fu">table</span>(i<span class="sc">!=</span><span class="dv">0</span>)[<span class="st">"TRUE"</span>]})<span class="sc">&gt;=</span>my.num</span>
<span id="cb11-70"><a href="#cb11-70"></a>  this.index<span class="ot">&lt;-</span>my.lambdas[my.lambdas <span class="sc">&amp;</span> <span class="sc">!</span><span class="fu">is.na</span>(my.lambdas)][<span class="dv">1</span>] <span class="sc">%&gt;%</span> names</span>
<span id="cb11-71"><a href="#cb11-71"></a>  <span class="cf">if</span>(<span class="fu">is.na</span>(this.index)){</span>
<span id="cb11-72"><a href="#cb11-72"></a>    dt.bar<span class="ot">&lt;-</span><span class="cn">NULL</span></span>
<span id="cb11-73"><a href="#cb11-73"></a>  }<span class="cf">else</span>{</span>
<span id="cb11-74"><a href="#cb11-74"></a>    this.index.num <span class="ot">&lt;-</span> (<span class="fu">strsplit</span>(this.index,<span class="st">"s"</span>)[[<span class="dv">1</span>]][<span class="dv">2</span>] <span class="sc">%&gt;%</span> as.integer) <span class="sc">+</span><span class="dv">1</span></span>
<span id="cb11-75"><a href="#cb11-75"></a>    dt.bar<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb11-76"><a href="#cb11-76"></a>                        <span class="at">method=</span><span class="st">"ENet2"</span>,</span>
<span id="cb11-77"><a href="#cb11-77"></a>                        <span class="at">fold=</span>my.fold,</span>
<span id="cb11-78"><a href="#cb11-78"></a>                        mat.beta2[mat.beta2[,this.index.num]<span class="sc">!=</span><span class="dv">0</span>,this.index.num,<span class="at">drop=</span>F] <span class="sc">%&gt;%</span> <span class="fu">as.data.table</span>(<span class="at">keep.rownames=</span>T)) <span class="co"># save as the above</span></span>
<span id="cb11-79"><a href="#cb11-79"></a>    <span class="fu">setnames</span>(dt.bar,<span class="fu">c</span>(<span class="st">"method"</span>,<span class="st">"fold"</span>,<span class="st">"feature"</span>,<span class="st">"score"</span>))</span>
<span id="cb11-80"><a href="#cb11-80"></a>    <span class="cf">if</span>(<span class="fu">nrow</span>(dt.bar)<span class="sc">&gt;</span>my.num){</span>
<span id="cb11-81"><a href="#cb11-81"></a>      dt.bar<span class="ot">&lt;-</span>dt.bar[<span class="fu">order</span>(method,fold,<span class="sc">-</span><span class="fu">abs</span>(score))][<span class="dv">1</span><span class="sc">:</span>my.num]</span>
<span id="cb11-82"><a href="#cb11-82"></a>    }</span>
<span id="cb11-83"><a href="#cb11-83"></a>  }</span>
<span id="cb11-84"><a href="#cb11-84"></a></span>
<span id="cb11-85"><a href="#cb11-85"></a>  dt.baz<span class="ot">&lt;-</span><span class="fu">rbind</span>(dt.foo,dt.bar)</span>
<span id="cb11-86"><a href="#cb11-86"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(dt.baz)){</span>
<span id="cb11-87"><a href="#cb11-87"></a>    dt.baz<span class="ot">&lt;-</span>dt.baz[<span class="fu">order</span>(method,fold,<span class="sc">-</span><span class="fu">abs</span>(score))][,rank<span class="sc">:</span><span class="er">=</span><span class="dv">1</span><span class="sc">:</span>.N,.(method,fold)]</span>
<span id="cb11-88"><a href="#cb11-88"></a>  }</span>
<span id="cb11-89"><a href="#cb11-89"></a>  <span class="fu">return</span>(dt.baz)</span>
<span id="cb11-90"><a href="#cb11-90"></a>} <span class="co"># end of get_enet_coef</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="`R` function `runRFE2`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>R</code> function <code>runRFE2</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This helper function select desired number of features by using recursive feature elimination method via <a href="https://topepo.github.io/caret/recursive-feature-elimination.html"><code>caret::rfe()</code></a></p>
<div class="cell" data-lable="def-rfe">
<details class="code-fold">
<summary>Code to run recursive feature elimination</summary>
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a><span class="co"># x: data matrix</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="co"># my.method: </span></span>
<span id="cb12-3"><a href="#cb12-3"></a><span class="co"># my.num: number of desired features</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="co"># my.index: a list with elements for each external resampling iteration.</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="co"># is.final: the final selected features if set true; oterwise at each fold level</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="co"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>runRFE2 <span class="ot">&lt;-</span><span class="cf">function</span>(x, <span class="at">my.method=</span><span class="st">"svmRadial"</span>, <span class="at">my.num=</span><span class="dv">4</span>, my.index, <span class="at">is.final=</span>F){</span>
<span id="cb12-8"><a href="#cb12-8"></a>  <span class="co">#x isa `matrix` and should contain 'y' column</span></span>
<span id="cb12-9"><a href="#cb12-9"></a>  all.features<span class="ot">&lt;-</span><span class="fu">colnames</span>(x)[<span class="fu">colnames</span>(x)<span class="sc">!=</span><span class="st">"y"</span>]</span>
<span id="cb12-10"><a href="#cb12-10"></a></span>
<span id="cb12-11"><a href="#cb12-11"></a>  li.methods<span class="ot">&lt;-</span><span class="fu">list</span>(</span>
<span id="cb12-12"><a href="#cb12-12"></a>    <span class="st">`</span><span class="at">svmLinear</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmLinear"</span>,</span>
<span id="cb12-13"><a href="#cb12-13"></a>    <span class="st">`</span><span class="at">svmRadial</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmRadial"</span>,</span>
<span id="cb12-14"><a href="#cb12-14"></a>    <span class="st">`</span><span class="at">nnet</span><span class="st">`</span><span class="ot">=</span><span class="st">"nnet"</span>,</span>
<span id="cb12-15"><a href="#cb12-15"></a>    <span class="st">`</span><span class="at">pcaNNet</span><span class="st">`</span><span class="ot">=</span><span class="st">"pcaNNet"</span>,</span>
<span id="cb12-16"><a href="#cb12-16"></a>    <span class="st">`</span><span class="at">rfFuncs</span><span class="st">`</span><span class="ot">=</span>rfFuncs,</span>
<span id="cb12-17"><a href="#cb12-17"></a>    <span class="st">`</span><span class="at">nbFuncs</span><span class="st">`</span><span class="ot">=</span>nbFuncs,</span>
<span id="cb12-18"><a href="#cb12-18"></a>    )</span>
<span id="cb12-19"><a href="#cb12-19"></a></span>
<span id="cb12-20"><a href="#cb12-20"></a>  my.fun<span class="ot">&lt;-</span>li.methods[[my.method]]</span>
<span id="cb12-21"><a href="#cb12-21"></a>  <span class="cf">if</span>(<span class="fu">is.list</span>(my.fun)){</span>
<span id="cb12-22"><a href="#cb12-22"></a>    myFuncs<span class="ot">&lt;-</span>my.fun</span>
<span id="cb12-23"><a href="#cb12-23"></a>  }<span class="cf">else</span>{</span>
<span id="cb12-24"><a href="#cb12-24"></a>    myFuncs<span class="ot">&lt;-</span>caretFuncs</span>
<span id="cb12-25"><a href="#cb12-25"></a>  }</span>
<span id="cb12-26"><a href="#cb12-26"></a>  myFuncs<span class="sc">$</span>summary <span class="ot">&lt;-</span> twoClassSummary</span>
<span id="cb12-27"><a href="#cb12-27"></a></span>
<span id="cb12-28"><a href="#cb12-28"></a>  rfe.ctrl <span class="ot">&lt;-</span> <span class="fu">rfeControl</span>(<span class="at">functions=</span>myFuncs,</span>
<span id="cb12-29"><a href="#cb12-29"></a>                         <span class="at">method =</span> <span class="st">"cv"</span>,</span>
<span id="cb12-30"><a href="#cb12-30"></a>                         <span class="co">#repeats =1, number = 10, # NB, index below</span></span>
<span id="cb12-31"><a href="#cb12-31"></a>                         <span class="co">#returnResamp="all", # "final" by default</span></span>
<span id="cb12-32"><a href="#cb12-32"></a>                         <span class="at">saveDetails=</span>T,</span>
<span id="cb12-33"><a href="#cb12-33"></a>                         <span class="at">verbose =</span> <span class="cn">TRUE</span>,</span>
<span id="cb12-34"><a href="#cb12-34"></a>                         <span class="at">index =</span> my.index <span class="co">#a list with elements for each external resampling iteration.</span></span>
<span id="cb12-35"><a href="#cb12-35"></a>                                          <span class="co">#Each list element is the sample rows used for training at</span></span>
<span id="cb12-36"><a href="#cb12-36"></a>                                          <span class="co">#that iteration.</span></span>
<span id="cb12-37"><a href="#cb12-37"></a>  )</span>
<span id="cb12-38"><a href="#cb12-38"></a></span>
<span id="cb12-39"><a href="#cb12-39"></a>  tr.ctrl <span class="ot">&lt;-</span> <span class="fu">trainControl</span>(<span class="at">method =</span> <span class="st">"cv"</span>,</span>
<span id="cb12-40"><a href="#cb12-40"></a>                          <span class="co">#repeats =1, number = 10, # NB, index below</span></span>
<span id="cb12-41"><a href="#cb12-41"></a>                          <span class="at">summaryFunction =</span> twoClassSummary,</span>
<span id="cb12-42"><a href="#cb12-42"></a>                          <span class="at">classProbs =</span> <span class="cn">TRUE</span>,</span>
<span id="cb12-43"><a href="#cb12-43"></a>                          <span class="at">savePredictions =</span> T,</span>
<span id="cb12-44"><a href="#cb12-44"></a>                          <span class="at">verboseIter =</span> T,</span>
<span id="cb12-45"><a href="#cb12-45"></a>                          <span class="at">index =</span> my.index <span class="co">#a list with elements for each external resampling iteration.</span></span>
<span id="cb12-46"><a href="#cb12-46"></a>                                            <span class="co">#Each list element is the sample rows used for training at</span></span>
<span id="cb12-47"><a href="#cb12-47"></a>                                            <span class="co">#that iteration.</span></span>
<span id="cb12-48"><a href="#cb12-48"></a>  )</span>
<span id="cb12-49"><a href="#cb12-49"></a></span>
<span id="cb12-50"><a href="#cb12-50"></a>  <span class="co"># run REF via caret::ref #</span></span>
<span id="cb12-51"><a href="#cb12-51"></a>  cl <span class="ot">&lt;-</span> <span class="fu">makePSOCKcluster</span>(<span class="dv">8</span>) <span class="co"># No. of cores to use</span></span>
<span id="cb12-52"><a href="#cb12-52"></a>  <span class="fu">registerDoParallel</span>(cl)</span>
<span id="cb12-53"><a href="#cb12-53"></a>  <span class="fu">set.seed</span>(<span class="dv">333</span>) <span class="co"># set a random seed for a reproducibility</span></span>
<span id="cb12-54"><a href="#cb12-54"></a>  cv.rfe<span class="ot">&lt;-</span>caret<span class="sc">::</span><span class="fu">rfe</span>(</span>
<span id="cb12-55"><a href="#cb12-55"></a>                     <span class="at">x=</span><span class="fu">as.data.frame</span>(x[,all.features]),</span>
<span id="cb12-56"><a href="#cb12-56"></a>                     <span class="at">y=</span><span class="fu">factor</span>(<span class="fu">ifelse</span>(x[,<span class="st">"y"</span>]<span class="sc">==</span><span class="dv">1</span>,<span class="st">'case'</span>,<span class="st">'non_case'</span>),<span class="at">levels=</span><span class="fu">c</span>(<span class="st">"non_case"</span>,<span class="st">"case"</span>)),</span>
<span id="cb12-57"><a href="#cb12-57"></a>                     <span class="at">sizes =</span> my.num, <span class="co">#2^(2:4), # default </span></span>
<span id="cb12-58"><a href="#cb12-58"></a>                     <span class="at">metric=</span><span class="st">"ROC"</span>,</span>
<span id="cb12-59"><a href="#cb12-59"></a>                     <span class="at">rfeControl=</span>rfe.ctrl,</span>
<span id="cb12-60"><a href="#cb12-60"></a>                     <span class="at">method=</span>my.method, <span class="co"># feed it to 'train'</span></span>
<span id="cb12-61"><a href="#cb12-61"></a>                     <span class="at">tuneLength =</span> <span class="dv">5</span>, <span class="co">#ifelse(trControl$method == "none", 1, 3)</span></span>
<span id="cb12-62"><a href="#cb12-62"></a>                     <span class="at">trControl=</span>tr.ctrl <span class="co"># feed it to 'train'</span></span>
<span id="cb12-63"><a href="#cb12-63"></a>  )</span>
<span id="cb12-64"><a href="#cb12-64"></a>  <span class="fu">stopCluster</span>(cl)</span>
<span id="cb12-65"><a href="#cb12-65"></a></span>
<span id="cb12-66"><a href="#cb12-66"></a>  dt.foo<span class="ot">&lt;-</span><span class="fu">data.table</span>(<span class="st">`</span><span class="at">method</span><span class="st">`</span><span class="ot">=</span>my.method,cv.rfe<span class="sc">$</span>variables)</span>
<span id="cb12-67"><a href="#cb12-67"></a>  <span class="cf">if</span>(is.final){</span>
<span id="cb12-68"><a href="#cb12-68"></a>    dt.bar<span class="ot">&lt;-</span><span class="fu">data.table</span>(<span class="st">`</span><span class="at">method</span><span class="st">`</span><span class="ot">=</span>my.method,</span>
<span id="cb12-69"><a href="#cb12-69"></a>                       <span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span><span class="st">"final"</span>,</span>
<span id="cb12-70"><a href="#cb12-70"></a>                       <span class="st">`</span><span class="at">feature</span><span class="st">`</span><span class="ot">=</span>cv.rfe<span class="sc">$</span>optVariables[<span class="dv">1</span><span class="sc">:</span>my.num],</span>
<span id="cb12-71"><a href="#cb12-71"></a>                       <span class="st">`</span><span class="at">score</span><span class="st">`</span><span class="ot">=</span><span class="cn">NA</span>,</span>
<span id="cb12-72"><a href="#cb12-72"></a>                       <span class="st">`</span><span class="at">rank</span><span class="st">`</span><span class="ot">=</span><span class="dv">1</span><span class="sc">:</span>my.num)</span>
<span id="cb12-73"><a href="#cb12-73"></a>  }<span class="cf">else</span>{</span>
<span id="cb12-74"><a href="#cb12-74"></a>    dt.bar<span class="ot">&lt;-</span>dt.foo[Variables<span class="sc">==</span>cv.rfe<span class="sc">$</span>optsize][<span class="fu">order</span>(Resample,<span class="sc">-</span>Overall)][,.SD[<span class="dv">1</span><span class="sc">:</span>my.num],.(method,Resample)][,rank<span class="sc">:</span><span class="er">=</span><span class="dv">1</span><span class="sc">:</span>.N,.(method,Resample)][,.(method,<span class="at">fold=</span>Resample,<span class="at">feature=</span>var,<span class="at">score=</span>Overall,rank)]</span>
<span id="cb12-75"><a href="#cb12-75"></a>  }</span>
<span id="cb12-76"><a href="#cb12-76"></a></span>
<span id="cb12-77"><a href="#cb12-77"></a>  <span class="fu">return</span>(dt.bar)</span>
<span id="cb12-78"><a href="#cb12-78"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="`R` function `get_cv_glm`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>R</code> function <code>get_cv_glm</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This helper function extracts the predictive performance of the training model from a given fold tested using held-out samples during kCV.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to extract the stat of the training model given the fold ID from the 5-fold CV with 5 repetitions</summary>
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1"></a><span class="co"># x: matrix dataset (train/test at the same time, separated by my.index which is the training)</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="co"># my.fold: fold ID</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co"># my.index: the training index of `x` to subset where the model should be built</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="co"># my.feature: features of interests</span></span>
<span id="cb13-5"><a href="#cb13-5"></a>get_cv_glm<span class="ot">&lt;-</span><span class="cf">function</span>(<span class="at">x=</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]],my.fold,my.index,my.feature){</span>
<span id="cb13-6"><a href="#cb13-6"></a>  mat.tr<span class="ot">&lt;-</span>x[my.index,] <span class="co"># index of the training</span></span>
<span id="cb13-7"><a href="#cb13-7"></a>  df.mat.tr<span class="ot">&lt;-</span>mat.tr[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame  <span class="co"># training set</span></span>
<span id="cb13-8"><a href="#cb13-8"></a></span>
<span id="cb13-9"><a href="#cb13-9"></a>  <span class="do">############################################</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>  <span class="co"># fit the model using the training dataset #</span></span>
<span id="cb13-11"><a href="#cb13-11"></a>  <span class="do">############################################</span></span>
<span id="cb13-12"><a href="#cb13-12"></a>  my.model<span class="ot">&lt;-</span><span class="fu">glm</span>(y<span class="sc">~</span>. , <span class="at">data =</span> df.mat.tr, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb13-13"><a href="#cb13-13"></a></span>
<span id="cb13-14"><a href="#cb13-14"></a>  <span class="co"># ROC from the training fold</span></span>
<span id="cb13-15"><a href="#cb13-15"></a>  my.roc <span class="ot">&lt;-</span>pROC<span class="sc">::</span><span class="fu">roc</span>(<span class="at">response=</span>df.mat.tr<span class="sc">$</span>y, <span class="at">predictor=</span><span class="fu">fitted</span>(my.model),<span class="at">quite=</span>T,<span class="at">ci=</span>T)</span>
<span id="cb13-16"><a href="#cb13-16"></a></span>
<span id="cb13-17"><a href="#cb13-17"></a>  <span class="co"># LPOCV from the training fold</span></span>
<span id="cb13-18"><a href="#cb13-18"></a>  LPOCV.boot<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot</span>(<span class="at">data=</span>df.mat.tr, <span class="at">statistic=</span>get_LPOCV_boot,<span class="at">R=</span><span class="dv">100</span>,<span class="at">parallel=</span><span class="st">"multicore"</span>,<span class="at">ncpus=</span><span class="dv">10</span>)</span>
<span id="cb13-19"><a href="#cb13-19"></a>  LPOCV.ci<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot.ci</span>(LPOCV.boot,<span class="at">type=</span><span class="st">"perc"</span>)</span>
<span id="cb13-20"><a href="#cb13-20"></a></span>
<span id="cb13-21"><a href="#cb13-21"></a>  <span class="co"># the whole dataset were training set, i.e. no test</span></span>
<span id="cb13-22"><a href="#cb13-22"></a>  <span class="cf">if</span>(<span class="fu">length</span>(my.index)<span class="sc">==</span><span class="fu">nrow</span>(x)){</span>
<span id="cb13-23"><a href="#cb13-23"></a>    <span class="fu">cbind</span>(</span>
<span id="cb13-24"><a href="#cb13-24"></a>      <span class="fu">data.table</span>(</span>
<span id="cb13-25"><a href="#cb13-25"></a>                <span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span>my.fold,</span>
<span id="cb13-26"><a href="#cb13-26"></a>                <span class="st">`</span><span class="at">predictor</span><span class="st">`</span><span class="ot">=</span><span class="fu">paste</span>(my.feature,<span class="at">collapse=</span><span class="st">","</span>)</span>
<span id="cb13-27"><a href="#cb13-27"></a>                ),</span>
<span id="cb13-28"><a href="#cb13-28"></a>      <span class="fu">data.table</span>(</span>
<span id="cb13-29"><a href="#cb13-29"></a>                <span class="st">`</span><span class="at">AIC</span><span class="st">`</span><span class="ot">=</span>my.model<span class="sc">$</span>aic,</span>
<span id="cb13-30"><a href="#cb13-30"></a>                <span class="st">`</span><span class="at">BIC</span><span class="st">`</span><span class="ot">=</span><span class="fu">BIC</span>(my.model),</span>
<span id="cb13-31"><a href="#cb13-31"></a>                <span class="st">`</span><span class="at">AUC</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-32"><a href="#cb13-32"></a>                <span class="st">`</span><span class="at">AUC_lo</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">1</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-33"><a href="#cb13-33"></a>                <span class="st">`</span><span class="at">AUC_hi</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">3</span>]<span class="sc">*</span><span class="dv">100</span>,</span>
<span id="cb13-34"><a href="#cb13-34"></a>                <span class="st">`</span><span class="at">LPOCV</span><span class="st">`</span><span class="ot">=</span>LPOCV.boot<span class="sc">$</span>t0,</span>
<span id="cb13-35"><a href="#cb13-35"></a>                <span class="st">`</span><span class="at">LPOCV_lo</span><span class="st">`</span><span class="ot">=</span>LPOCV.ci<span class="sc">$</span>percent[<span class="dv">4</span>],</span>
<span id="cb13-36"><a href="#cb13-36"></a>                <span class="st">`</span><span class="at">LPOCV_hi</span><span class="st">`</span><span class="ot">=</span>LPOCV.ci<span class="sc">$</span>percent[<span class="dv">5</span>]</span>
<span id="cb13-37"><a href="#cb13-37"></a>                )</span>
<span id="cb13-38"><a href="#cb13-38"></a>    )</span>
<span id="cb13-39"><a href="#cb13-39"></a>  }<span class="cf">else</span>{</span>
<span id="cb13-40"><a href="#cb13-40"></a>    <span class="do">#################################################</span></span>
<span id="cb13-41"><a href="#cb13-41"></a>    <span class="co"># now, predict the outcome of the held-out data #</span></span>
<span id="cb13-42"><a href="#cb13-42"></a>    <span class="co"># using the model from the training dataset     #</span></span>
<span id="cb13-43"><a href="#cb13-43"></a>    <span class="do">#################################################</span></span>
<span id="cb13-44"><a href="#cb13-44"></a>    mat.test<span class="ot">&lt;-</span>x[<span class="sc">-</span>my.index,]  </span>
<span id="cb13-45"><a href="#cb13-45"></a>    df.mat.test<span class="ot">&lt;-</span>mat.test[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame <span class="co"># held-out</span></span>
<span id="cb13-46"><a href="#cb13-46"></a></span>
<span id="cb13-47"><a href="#cb13-47"></a>    my.prob<span class="ot">&lt;-</span><span class="fu">predict.glm</span>(my.model, <span class="at">newdata=</span>df.mat.test, <span class="at">type=</span><span class="st">"response"</span>) </span>
<span id="cb13-48"><a href="#cb13-48"></a>    my.roc.test <span class="ot">&lt;-</span> pROC<span class="sc">::</span><span class="fu">roc</span>(<span class="at">response=</span>df.mat.test<span class="sc">$</span>y, <span class="at">predictor=</span>my.prob,<span class="at">quiet=</span>T,<span class="at">ci=</span>T)</span>
<span id="cb13-49"><a href="#cb13-49"></a>    LPOCV.boot.test<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot</span>(<span class="at">data=</span>df.mat.test, <span class="at">statistic=</span>get_LPOCV_boot,<span class="at">R=</span><span class="dv">100</span>,<span class="at">parallel=</span><span class="st">"multicore"</span>,<span class="at">ncpus=</span><span class="dv">20</span>)</span>
<span id="cb13-50"><a href="#cb13-50"></a>    <span class="co"># deal with failed boot result</span></span>
<span id="cb13-51"><a href="#cb13-51"></a>    <span class="cf">if</span>(<span class="fu">is.numeric</span>(LPOCV.boot.test<span class="sc">$</span>t)){</span>
<span id="cb13-52"><a href="#cb13-52"></a>      LPOCV.ci.test<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot.ci</span>(LPOCV.boot.test,<span class="at">type=</span><span class="st">"perc"</span>)</span>
<span id="cb13-53"><a href="#cb13-53"></a>      LPOCV_test_lo<span class="ot">=</span>LPOCV.ci.test<span class="sc">$</span>percent[<span class="dv">4</span>]</span>
<span id="cb13-54"><a href="#cb13-54"></a>      LPOCV_test_hi<span class="ot">=</span>LPOCV.ci.test<span class="sc">$</span>percent[<span class="dv">5</span>]</span>
<span id="cb13-55"><a href="#cb13-55"></a>    }<span class="cf">else</span>{</span>
<span id="cb13-56"><a href="#cb13-56"></a>      LPOCV_test_lo<span class="ot">=</span><span class="cn">NA</span></span>
<span id="cb13-57"><a href="#cb13-57"></a>      LPOCV_test_hi<span class="ot">=</span><span class="cn">NA</span></span>
<span id="cb13-58"><a href="#cb13-58"></a>    }</span>
<span id="cb13-59"><a href="#cb13-59"></a>    <span class="co"># return the following table</span></span>
<span id="cb13-60"><a href="#cb13-60"></a>    <span class="fu">cbind</span>(</span>
<span id="cb13-61"><a href="#cb13-61"></a>      <span class="fu">data.table</span>(</span>
<span id="cb13-62"><a href="#cb13-62"></a>                <span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span>my.fold,</span>
<span id="cb13-63"><a href="#cb13-63"></a>                <span class="st">`</span><span class="at">predictor</span><span class="st">`</span><span class="ot">=</span><span class="fu">paste</span>(my.feature,<span class="at">collapse=</span><span class="st">","</span>)</span>
<span id="cb13-64"><a href="#cb13-64"></a>                ),</span>
<span id="cb13-65"><a href="#cb13-65"></a>      <span class="fu">data.table</span>(</span>
<span id="cb13-66"><a href="#cb13-66"></a>                <span class="st">`</span><span class="at">AIC</span><span class="st">`</span><span class="ot">=</span>my.model<span class="sc">$</span>aic,</span>
<span id="cb13-67"><a href="#cb13-67"></a>                <span class="st">`</span><span class="at">BIC</span><span class="st">`</span><span class="ot">=</span><span class="fu">BIC</span>(my.model),</span>
<span id="cb13-68"><a href="#cb13-68"></a>                <span class="st">`</span><span class="at">AUC</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-69"><a href="#cb13-69"></a>                <span class="st">`</span><span class="at">AUC_lo</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">1</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-70"><a href="#cb13-70"></a>                <span class="st">`</span><span class="at">AUC_hi</span><span class="st">`</span><span class="ot">=</span>my.roc<span class="sc">$</span>ci[<span class="dv">3</span>]<span class="sc">*</span><span class="dv">100</span>,</span>
<span id="cb13-71"><a href="#cb13-71"></a>                <span class="st">`</span><span class="at">LPOCV</span><span class="st">`</span><span class="ot">=</span>LPOCV.boot<span class="sc">$</span>t0,</span>
<span id="cb13-72"><a href="#cb13-72"></a>                <span class="st">`</span><span class="at">LPOCV_lo</span><span class="st">`</span><span class="ot">=</span>LPOCV.ci<span class="sc">$</span>percent[<span class="dv">4</span>],</span>
<span id="cb13-73"><a href="#cb13-73"></a>                <span class="st">`</span><span class="at">LPOCV_hi</span><span class="st">`</span><span class="ot">=</span>LPOCV.ci<span class="sc">$</span>percent[<span class="dv">5</span>],</span>
<span id="cb13-74"><a href="#cb13-74"></a>                <span class="st">`</span><span class="at">AUC_test</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-75"><a href="#cb13-75"></a>                <span class="st">`</span><span class="at">AUC_test_lo</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">1</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb13-76"><a href="#cb13-76"></a>                <span class="st">`</span><span class="at">AUC_test_hi</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">3</span>]<span class="sc">*</span><span class="dv">100</span>,</span>
<span id="cb13-77"><a href="#cb13-77"></a>                <span class="st">`</span><span class="at">LPOCV_test</span><span class="st">`</span><span class="ot">=</span>LPOCV.boot.test<span class="sc">$</span>t0,</span>
<span id="cb13-78"><a href="#cb13-78"></a>                <span class="st">`</span><span class="at">LPOCV_test_lo</span><span class="st">`</span><span class="ot">=</span>LPOCV_test_lo,</span>
<span id="cb13-79"><a href="#cb13-79"></a>                <span class="st">`</span><span class="at">LPOCV_test_hi</span><span class="st">`</span><span class="ot">=</span>LPOCV_test_hi</span>
<span id="cb13-80"><a href="#cb13-80"></a>                )</span>
<span id="cb13-81"><a href="#cb13-81"></a>    )</span>
<span id="cb13-82"><a href="#cb13-82"></a>  }</span>
<span id="cb13-83"><a href="#cb13-83"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<div class="callout callout-style-default callout-tip callout-titled" title="`R` function `get_cv_glm2`">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<code>R</code> function <code>get_cv_glm2</code>
</div>
</div>
<div class="callout-body-container callout-body">
<p>This helper function extracts the basic statistic (e.g.&nbsp;AIC, BIC, and AUC etc) of the training model for a given fold during kCV.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to extract the predictive performance of the training model given the fold ID from the 5-fold CV with 5 repetitions</summary>
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co"># x: the dataset where the model should be tested on (i.e. the test set)</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="co"># my.model: the model from the training </span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="co"># my.feature: features of interests</span></span>
<span id="cb14-4"><a href="#cb14-4"></a>get_cv_glm2<span class="ot">&lt;-</span><span class="cf">function</span>(<span class="at">x=</span>li.mat[[<span class="st">"test"</span>]][[<span class="st">"28wk"</span>]],my.fold, my.model,my.feature){</span>
<span id="cb14-5"><a href="#cb14-5"></a>    df.mat.test<span class="ot">&lt;-</span>x[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame <span class="co"># test (validation) dataset</span></span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a>    <span class="co">#my.prob&lt;-predict.glm(my.model, newdata=df.mat.test, type="response") </span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    my.prob<span class="ot">&lt;-</span><span class="fu">predict</span>(my.model, <span class="at">newdata=</span>df.mat.test, <span class="at">type=</span><span class="st">"response"</span>) </span>
<span id="cb14-9"><a href="#cb14-9"></a>    my.roc.test <span class="ot">&lt;-</span> pROC<span class="sc">::</span><span class="fu">roc</span>(<span class="at">response=</span>df.mat.test<span class="sc">$</span>y, <span class="at">predictor=</span>my.prob,<span class="at">quiet=</span>T,<span class="at">ci=</span>T)</span>
<span id="cb14-10"><a href="#cb14-10"></a>    LPOCV.boot.test<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot</span>(<span class="at">data=</span>df.mat.test, <span class="at">statistic=</span>get_LPOCV_boot,<span class="at">R=</span><span class="dv">100</span>,<span class="at">parallel=</span><span class="st">"multicore"</span>,<span class="at">ncpus=</span><span class="dv">20</span>)</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="co"># deal with failed boot result</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>    <span class="cf">if</span>(<span class="fu">is.numeric</span>(LPOCV.boot.test<span class="sc">$</span>t)){</span>
<span id="cb14-13"><a href="#cb14-13"></a>      LPOCV.ci.test<span class="ot">&lt;-</span>boot<span class="sc">::</span><span class="fu">boot.ci</span>(LPOCV.boot.test,<span class="at">type=</span><span class="st">"perc"</span>)</span>
<span id="cb14-14"><a href="#cb14-14"></a>      LPOCV_test_lo<span class="ot">=</span>LPOCV.ci.test<span class="sc">$</span>percent[<span class="dv">4</span>]</span>
<span id="cb14-15"><a href="#cb14-15"></a>      LPOCV_test_hi<span class="ot">=</span>LPOCV.ci.test<span class="sc">$</span>percent[<span class="dv">5</span>]</span>
<span id="cb14-16"><a href="#cb14-16"></a>    }<span class="cf">else</span>{</span>
<span id="cb14-17"><a href="#cb14-17"></a>      LPOCV_test_lo<span class="ot">=</span><span class="cn">NA</span></span>
<span id="cb14-18"><a href="#cb14-18"></a>      LPOCV_test_hi<span class="ot">=</span><span class="cn">NA</span></span>
<span id="cb14-19"><a href="#cb14-19"></a>    }</span>
<span id="cb14-20"><a href="#cb14-20"></a></span>
<span id="cb14-21"><a href="#cb14-21"></a>    <span class="co"># return the following table</span></span>
<span id="cb14-22"><a href="#cb14-22"></a>    <span class="fu">cbind</span>(</span>
<span id="cb14-23"><a href="#cb14-23"></a>      <span class="fu">data.table</span>(</span>
<span id="cb14-24"><a href="#cb14-24"></a>                <span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span>my.fold,</span>
<span id="cb14-25"><a href="#cb14-25"></a>                <span class="st">`</span><span class="at">predictor</span><span class="st">`</span><span class="ot">=</span><span class="fu">paste</span>(my.feature,<span class="at">collapse=</span><span class="st">","</span>)</span>
<span id="cb14-26"><a href="#cb14-26"></a>                ),</span>
<span id="cb14-27"><a href="#cb14-27"></a>      <span class="fu">data.table</span>(</span>
<span id="cb14-28"><a href="#cb14-28"></a>                <span class="st">`</span><span class="at">AUC_test</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">2</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb14-29"><a href="#cb14-29"></a>                <span class="st">`</span><span class="at">AUC_test_lo</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">1</span>]<span class="sc">*</span><span class="dv">100</span>, </span>
<span id="cb14-30"><a href="#cb14-30"></a>                <span class="st">`</span><span class="at">AUC_test_hi</span><span class="st">`</span><span class="ot">=</span>my.roc.test<span class="sc">$</span>ci[<span class="dv">3</span>]<span class="sc">*</span><span class="dv">100</span>,</span>
<span id="cb14-31"><a href="#cb14-31"></a>                <span class="st">`</span><span class="at">LPOCV_test</span><span class="st">`</span><span class="ot">=</span>LPOCV.boot.test<span class="sc">$</span>t0,</span>
<span id="cb14-32"><a href="#cb14-32"></a>                <span class="st">`</span><span class="at">LPOCV_test_lo</span><span class="st">`</span><span class="ot">=</span>LPOCV_test_lo,</span>
<span id="cb14-33"><a href="#cb14-33"></a>                <span class="st">`</span><span class="at">LPOCV_test_hi</span><span class="st">`</span><span class="ot">=</span>LPOCV_test_hi,</span>
<span id="cb14-34"><a href="#cb14-34"></a>                 <span class="st">`</span><span class="at">AIC</span><span class="st">`</span><span class="ot">=</span>my.model<span class="sc">$</span>aic,</span>
<span id="cb14-35"><a href="#cb14-35"></a>                 <span class="st">`</span><span class="at">BIC</span><span class="st">`</span><span class="ot">=</span><span class="fu">BIC</span>(my.model)</span>
<span id="cb14-36"><a href="#cb14-36"></a>                )</span>
<span id="cb14-37"><a href="#cb14-37"></a>    )</span>
<span id="cb14-38"><a href="#cb14-38"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</div>
</div>
<p>Having defined those helper functions, we are now ready to proceed 5-fold CV with 5 repetitions.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to run 11 ML methods in 5-fold CV with 5-repetitions</summary>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="do">## </span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="do">## Training on based on 5-fold CV</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="do">##</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.kcv.core17.RData"</span>)</span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb15-6"><a href="#cb15-6"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb15-7"><a href="#cb15-7"></a>}<span class="cf">else</span>{</span>
<span id="cb15-8"><a href="#cb15-8"></a>  <span class="fu">library</span>(e1071)</span>
<span id="cb15-9"><a href="#cb15-9"></a>  <span class="fu">source</span>(<span class="st">'SVM-RFE/msvmRFE.R'</span>)</span>
<span id="cb15-10"><a href="#cb15-10"></a></span>
<span id="cb15-11"><a href="#cb15-11"></a>  li.methods<span class="ot">&lt;-</span><span class="fu">list</span>(</span>
<span id="cb15-12"><a href="#cb15-12"></a>    <span class="st">`</span><span class="at">svmLinear</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmLinear"</span>,</span>
<span id="cb15-13"><a href="#cb15-13"></a>    <span class="st">`</span><span class="at">svmRadial</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmRadial"</span>,</span>
<span id="cb15-14"><a href="#cb15-14"></a>    <span class="st">`</span><span class="at">nnet</span><span class="st">`</span><span class="ot">=</span><span class="st">"nnet"</span>,</span>
<span id="cb15-15"><a href="#cb15-15"></a>    <span class="st">`</span><span class="at">pcaNNet</span><span class="st">`</span><span class="ot">=</span><span class="st">"pcaNNet"</span>,</span>
<span id="cb15-16"><a href="#cb15-16"></a>    <span class="st">`</span><span class="at">rfFuncs</span><span class="st">`</span><span class="ot">=</span>rfFuncs,</span>
<span id="cb15-17"><a href="#cb15-17"></a>    <span class="st">`</span><span class="at">nbFuncs</span><span class="st">`</span><span class="ot">=</span>nbFuncs</span>
<span id="cb15-18"><a href="#cb15-18"></a>    )</span>
<span id="cb15-19"><a href="#cb15-19"></a></span>
<span id="cb15-20"><a href="#cb15-20"></a>  <span class="co">#|Num: 6 Method: LASSO</span></span>
<span id="cb15-21"><a href="#cb15-21"></a>  <span class="co"># Fold5.Rep5</span></span>
<span id="cb15-22"><a href="#cb15-22"></a>  <span class="co">#Error in mat.beta[, this.index] : subscript out of bounds</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>  li.num<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">`</span><span class="at">F2</span><span class="st">`</span><span class="ot">=</span><span class="dv">2</span>,<span class="st">`</span><span class="at">F3</span><span class="st">`</span><span class="ot">=</span><span class="dv">3</span>,<span class="st">`</span><span class="at">F4</span><span class="st">`</span><span class="ot">=</span><span class="dv">4</span>,<span class="st">`</span><span class="at">F5</span><span class="st">`</span><span class="ot">=</span><span class="dv">5</span>,<span class="st">`</span><span class="at">F6</span><span class="st">`</span><span class="ot">=</span><span class="dv">6</span>)</span>
<span id="cb15-24"><a href="#cb15-24"></a>  dl.kcv<span class="ot">&lt;-</span><span class="fu">lapply</span>(li.num, <span class="cf">function</span>(my.num){</span>
<span id="cb15-25"><a href="#cb15-25"></a>    <span class="co"># 1. glParallel</span></span>
<span id="cb15-26"><a href="#cb15-26"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: glParallel"</span>))</span>
<span id="cb15-27"><a href="#cb15-27"></a>    my.pattern<span class="ot">=</span><span class="fu">paste0</span>(<span class="st">"^core17</span><span class="sc">\\</span><span class="st">.Fold[[:alnum:]]</span><span class="sc">\\</span><span class="st">.Rep[[:alnum:]]</span><span class="sc">\\</span><span class="st">.best"</span>,my.num)</span>
<span id="cb15-28"><a href="#cb15-28"></a>    dt.input<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb15-29"><a href="#cb15-29"></a>                    <span class="at">foo=</span><span class="fu">list.files</span>(<span class="st">"glParallel/result"</span>,<span class="at">pattern=</span>my.pattern),</span>
<span id="cb15-30"><a href="#cb15-30"></a>                    <span class="at">files=</span><span class="fu">list.files</span>(<span class="st">"glParallel/result"</span>,<span class="at">pattern=</span>my.pattern,<span class="at">full.names=</span>T)</span>
<span id="cb15-31"><a href="#cb15-31"></a>                    )[,<span class="fu">c</span>(<span class="st">"foo1"</span>,<span class="st">"bar1"</span>)<span class="sc">:</span><span class="er">=</span><span class="fu">tstrsplit</span>(foo,<span class="st">"</span><span class="sc">\\</span><span class="st">."</span>,<span class="at">keep=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>))][,fold<span class="sc">:</span><span class="er">=</span><span class="fu">paste</span>(foo1,bar1,<span class="at">sep=</span><span class="st">"."</span>)][,<span class="fu">c</span>(<span class="st">"foo"</span>,<span class="st">"foo1"</span>,<span class="st">"bar1"</span>)<span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]</span>
<span id="cb15-32"><a href="#cb15-32"></a></span>
<span id="cb15-33"><a href="#cb15-33"></a>    dt.cv.glp <span class="ot">&lt;-</span><span class="fu">apply</span>(dt.input, <span class="dv">1</span>, <span class="cf">function</span>(i){</span>
<span id="cb15-34"><a href="#cb15-34"></a>              my.fold<span class="ot">&lt;-</span>i[[<span class="st">"fold"</span>]]</span>
<span id="cb15-35"><a href="#cb15-35"></a>              my.feature<span class="ot">&lt;-</span><span class="fu">fread</span>(i[<span class="st">"files"</span>])[<span class="dv">1</span>][[<span class="st">"Best proteins"</span>]] <span class="sc">%&gt;%</span> <span class="fu">strsplit</span>(<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb15-36"><a href="#cb15-36"></a>              <span class="fu">data.table</span>(<span class="at">method=</span><span class="st">"glParallel"</span>,<span class="at">fold=</span>my.fold,<span class="at">feature=</span>my.feature,<span class="at">score=</span><span class="cn">NA</span>,<span class="at">rank=</span><span class="cn">NA</span>)</span>
<span id="cb15-37"><a href="#cb15-37"></a>              <span class="co">#cbind(`fold`=i[["fold"]],fread(i["files"])[1])</span></span>
<span id="cb15-38"><a href="#cb15-38"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-39"><a href="#cb15-39"></a></span>
<span id="cb15-40"><a href="#cb15-40"></a>    <span class="co"># 2. Lasso</span></span>
<span id="cb15-41"><a href="#cb15-41"></a>    <span class="co"># one multinomial or binomial class has fewer than 8  observations; dangerous ground</span></span>
<span id="cb15-42"><a href="#cb15-42"></a>    dt.cv.lasso<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.fold), <span class="cf">function</span>(my.fold){</span>
<span id="cb15-43"><a href="#cb15-43"></a>      <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: LASSO, Fold:"</span>,my.fold))</span>
<span id="cb15-44"><a href="#cb15-44"></a>      my.tr.index<span class="ot">&lt;-</span>li.fold[[my.fold]] <span class="co"># index of training </span></span>
<span id="cb15-45"><a href="#cb15-45"></a>      x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][my.tr.index,] <span class="co"># the training dataset</span></span>
<span id="cb15-46"><a href="#cb15-46"></a>      <span class="fu">get_lasso_coef</span>(x, my.fold, <span class="at">my.num=</span>my.num) </span>
<span id="cb15-47"><a href="#cb15-47"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-48"><a href="#cb15-48"></a></span>
<span id="cb15-49"><a href="#cb15-49"></a>    <span class="co"># 3. ElasticNet</span></span>
<span id="cb15-50"><a href="#cb15-50"></a>    <span class="co"># warnings(): one multinomial or binomial class has fewer than 8  observations; dangerous ground</span></span>
<span id="cb15-51"><a href="#cb15-51"></a>    dt.cv.enet<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.fold), <span class="cf">function</span>(my.fold){</span>
<span id="cb15-52"><a href="#cb15-52"></a>      <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: ENET, Fold:"</span>,my.fold))</span>
<span id="cb15-53"><a href="#cb15-53"></a>      my.tr.index<span class="ot">&lt;-</span>li.fold[[my.fold]] <span class="co"># index of training </span></span>
<span id="cb15-54"><a href="#cb15-54"></a>      x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][my.tr.index,] <span class="co"># the training dataset </span></span>
<span id="cb15-55"><a href="#cb15-55"></a>      <span class="fu">get_enet_coef</span>(x, my.fold, <span class="at">my.num=</span>my.num) </span>
<span id="cb15-56"><a href="#cb15-56"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-57"><a href="#cb15-57"></a></span>
<span id="cb15-58"><a href="#cb15-58"></a>    <span class="co"># 4. mSVM-RFE</span></span>
<span id="cb15-59"><a href="#cb15-59"></a>    dt.cv.svm<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.fold), <span class="cf">function</span>(my.fold){</span>
<span id="cb15-60"><a href="#cb15-60"></a>      <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: mSVM-RFE, Fold:"</span>,my.fold))</span>
<span id="cb15-61"><a href="#cb15-61"></a>      my.tr.index<span class="ot">&lt;-</span>li.fold[[my.fold]] <span class="co"># index of training </span></span>
<span id="cb15-62"><a href="#cb15-62"></a>      x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]][my.tr.index,] <span class="co"># the training dataset </span></span>
<span id="cb15-63"><a href="#cb15-63"></a>      <span class="fu">set.seed</span>(<span class="dv">333</span>)</span>
<span id="cb15-64"><a href="#cb15-64"></a>      ranked.features<span class="ot">&lt;-</span><span class="fu">colnames</span>(x)[<span class="sc">-</span><span class="dv">1</span>][<span class="fu">svmRFE</span>(x, <span class="at">k=</span><span class="dv">5</span>, <span class="at">halve.above=</span><span class="dv">100</span>)][<span class="dv">1</span><span class="sc">:</span>my.num] <span class="co"># only top x ranked features</span></span>
<span id="cb15-65"><a href="#cb15-65"></a>      <span class="fu">data.table</span>(<span class="at">method=</span><span class="st">"mSVM-RFE"</span>,<span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span>my.fold,<span class="at">feature=</span>ranked.features, <span class="at">score=</span><span class="cn">NA</span>,<span class="at">rank=</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ranked.features))</span>
<span id="cb15-66"><a href="#cb15-66"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-67"><a href="#cb15-67"></a></span>
<span id="cb15-68"><a href="#cb15-68"></a>    <span class="co"># 5-10. Other methods via RFE</span></span>
<span id="cb15-69"><a href="#cb15-69"></a>    dt.cv.rfe<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.methods), <span class="cf">function</span>(my.method){</span>
<span id="cb15-70"><a href="#cb15-70"></a>              <span class="co"># runRFE2 for each repetition</span></span>
<span id="cb15-71"><a href="#cb15-71"></a>              <span class="fu">lapply</span>(<span class="fu">paste0</span>(<span class="st">"Rep"</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>), <span class="cf">function</span>(iRep){</span>
<span id="cb15-72"><a href="#cb15-72"></a>                this.fold<span class="ot">&lt;-</span><span class="fu">paste</span>(<span class="fu">paste0</span>(<span class="st">"Fold"</span>,<span class="dv">1</span><span class="sc">:</span><span class="dv">5</span>),iRep,<span class="at">sep=</span><span class="st">"."</span>) <span class="co"># 5-fold for this repetition</span></span>
<span id="cb15-73"><a href="#cb15-73"></a>                <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method:"</span>,my.method, <span class="st">"Fold:"</span>,this.fold))</span>
<span id="cb15-74"><a href="#cb15-74"></a></span>
<span id="cb15-75"><a href="#cb15-75"></a>                <span class="fu">runRFE2</span>(<span class="at">x=</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]], <span class="at">my.method=</span>my.method, <span class="at">my.num=</span>my.num, <span class="at">my.index=</span>li.fold[this.fold])</span>
<span id="cb15-76"><a href="#cb15-76"></a>              }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-77"><a href="#cb15-77"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb15-78"><a href="#cb15-78"></a></span>
<span id="cb15-79"><a href="#cb15-79"></a>    <span class="fu">rbind</span>(dt.cv.glp, dt.cv.lasso[method<span class="sc">==</span><span class="st">"LASSO"</span>], dt.cv.enet, dt.cv.svm, dt.cv.rfe)</span>
<span id="cb15-80"><a href="#cb15-80"></a>  }) <span class="co"># end of dl.kcv</span></span>
<span id="cb15-81"><a href="#cb15-81"></a></span>
<span id="cb15-82"><a href="#cb15-82"></a>  <span class="fu">save</span>(dl.kcv, <span class="at">file=</span>my.RData)</span>
<span id="cb15-83"><a href="#cb15-83"></a>}</span>
<span id="cb15-84"><a href="#cb15-84"></a></span>
<span id="cb15-85"><a href="#cb15-85"></a><span class="do">##</span></span>
<span id="cb15-86"><a href="#cb15-86"></a><span class="do">##</span></span>
<span id="cb15-87"><a href="#cb15-87"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.kcv.result.core17.RData"</span>)</span>
<span id="cb15-88"><a href="#cb15-88"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb15-89"><a href="#cb15-89"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb15-90"><a href="#cb15-90"></a>}<span class="cf">else</span>{</span>
<span id="cb15-91"><a href="#cb15-91"></a>  <span class="co"># for each number of feature: F2, F3, F4, F5, F6</span></span>
<span id="cb15-92"><a href="#cb15-92"></a>  dl.kcv.result<span class="ot">&lt;-</span>parallel<span class="sc">::</span><span class="fu">mclapply</span>(dl.kcv, <span class="cf">function</span>(dt.kcv){</span>
<span id="cb15-93"><a href="#cb15-93"></a>    <span class="co"># features by method and fold</span></span>
<span id="cb15-94"><a href="#cb15-94"></a>    dt.foo<span class="ot">&lt;-</span>dt.kcv[<span class="fu">order</span>(method,fold,feature)][,.(.N,<span class="at">features=</span><span class="fu">paste</span>(feature,<span class="at">collapse=</span><span class="st">","</span>)),.(method,fold)]</span>
<span id="cb15-95"><a href="#cb15-95"></a>    my.num<span class="ot">&lt;-</span>dt.foo[,<span class="fu">unique</span>(N)]</span>
<span id="cb15-96"><a href="#cb15-96"></a></span>
<span id="cb15-97"><a href="#cb15-97"></a>    <span class="co"># features by method, fold and features</span></span>
<span id="cb15-98"><a href="#cb15-98"></a>    dt.bar<span class="ot">&lt;-</span>dt.kcv[<span class="fu">order</span>(method,fold,feature)][,.(.N,<span class="at">features=</span><span class="fu">paste</span>(feature,<span class="at">collapse=</span><span class="st">","</span>)),.(method,fold)][,.(.N,<span class="at">methods=</span><span class="fu">paste</span>(method,<span class="at">collapse=</span><span class="st">","</span>)),.(fold,features)][<span class="fu">order</span>(fold,<span class="sc">-</span>N)]</span>
<span id="cb15-99"><a href="#cb15-99"></a></span>
<span id="cb15-100"><a href="#cb15-100"></a>    <span class="co"># get the CV-LPOCV (or CV-AUC) across 25 folds (i.e. 5-Fold-CV * 5 Rep) </span></span>
<span id="cb15-101"><a href="#cb15-101"></a>    dl.bar<span class="ot">&lt;-</span><span class="fu">split</span>(dt.bar, dt.bar<span class="sc">$</span>fold) <span class="co"># by each fold</span></span>
<span id="cb15-102"><a href="#cb15-102"></a>    dt.kcv.result<span class="ot">&lt;-</span>parallel<span class="sc">::</span><span class="fu">mclapply</span>(dl.bar, <span class="cf">function</span>(dt.baz){</span>
<span id="cb15-103"><a href="#cb15-103"></a>      my.fold<span class="ot">&lt;-</span>dt.baz[,.N,fold]<span class="sc">$</span>fold</span>
<span id="cb15-104"><a href="#cb15-104"></a>      my.index<span class="ot">&lt;-</span>li.fold[[my.fold]] <span class="co"># index of training</span></span>
<span id="cb15-105"><a href="#cb15-105"></a></span>
<span id="cb15-106"><a href="#cb15-106"></a>      <span class="co"># for each list of features in this fold</span></span>
<span id="cb15-107"><a href="#cb15-107"></a>      <span class="fu">lapply</span>(dt.baz<span class="sc">$</span>features, <span class="cf">function</span>(i){</span>
<span id="cb15-108"><a href="#cb15-108"></a>        <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">", Fold:"</span>,my.fold, <span class="st">", Features:"</span>,i))</span>
<span id="cb15-109"><a href="#cb15-109"></a>        my.feature <span class="ot">&lt;-</span> i <span class="sc">%&gt;%</span> <span class="fu">strsplit</span>(<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb15-110"><a href="#cb15-110"></a>        <span class="fu">get_cv_glm</span>(<span class="at">x=</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]],my.fold,my.index,my.feature)</span>
<span id="cb15-111"><a href="#cb15-111"></a>      }) <span class="sc">%&gt;%</span> rbindlist <span class="co"># merge all features</span></span>
<span id="cb15-112"><a href="#cb15-112"></a>    },<span class="at">mc.cores=</span><span class="dv">1</span>) <span class="sc">%&gt;%</span> rbindlist <span class="co"># merge all fold</span></span>
<span id="cb15-113"><a href="#cb15-113"></a></span>
<span id="cb15-114"><a href="#cb15-114"></a>    <span class="fu">merge</span>(dt.foo, dt.kcv.result, <span class="at">by.x=</span><span class="fu">c</span>(<span class="st">"fold"</span>,<span class="st">"features"</span>), <span class="at">by.y=</span><span class="fu">c</span>(<span class="st">"fold"</span>,<span class="st">"predictor"</span>))</span>
<span id="cb15-115"><a href="#cb15-115"></a>  },<span class="at">mc.cores=</span><span class="dv">1</span>) <span class="co"># parallel by the No. of features</span></span>
<span id="cb15-116"><a href="#cb15-116"></a>  <span class="fu">save</span>(dl.kcv.result, <span class="at">file=</span>my.RData)</span>
<span id="cb15-117"><a href="#cb15-117"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
<p>Having selected a set of predictors for each of the 11 ML methods, a logistic regression model was fitted on the training fold based on the selected predictors, and its predictive performance, i.e.&nbsp;the AUC, was calculated using the remaining held-out test fold. As the 5-fold CV was repeated 5 times, the 25 cross-validated AUCs were averaged by taking the mean AUC. This procedure was repeated from a selection of 2- to 6-predictor models, i.e.&nbsp;5 times, so the cross-validated AUCs were again averaged by taking the mean values of AUCs.</p>
<div class="cell">
<details class="code-fold">
<summary>Code to extract the final selected features from each ML method and fit a regression model and test its performance.</summary>
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.final.models.core17.RData"</span>)</span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb16-3"><a href="#cb16-3"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb16-4"><a href="#cb16-4"></a>}<span class="cf">else</span>{</span>
<span id="cb16-5"><a href="#cb16-5"></a>  <span class="fu">library</span>(e1071)</span>
<span id="cb16-6"><a href="#cb16-6"></a>  <span class="fu">source</span>(<span class="st">'SVM-RFE/msvmRFE.R'</span>)</span>
<span id="cb16-7"><a href="#cb16-7"></a></span>
<span id="cb16-8"><a href="#cb16-8"></a>  li.methods<span class="ot">&lt;-</span><span class="fu">list</span>(</span>
<span id="cb16-9"><a href="#cb16-9"></a>    <span class="st">`</span><span class="at">svmLinear</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmLinear"</span>,</span>
<span id="cb16-10"><a href="#cb16-10"></a>    <span class="st">`</span><span class="at">svmRadial</span><span class="st">`</span><span class="ot">=</span><span class="st">"svmRadial"</span>,</span>
<span id="cb16-11"><a href="#cb16-11"></a>    <span class="st">`</span><span class="at">nnet</span><span class="st">`</span><span class="ot">=</span><span class="st">"nnet"</span>,</span>
<span id="cb16-12"><a href="#cb16-12"></a>    <span class="st">`</span><span class="at">pcaNNet</span><span class="st">`</span><span class="ot">=</span><span class="st">"pcaNNet"</span>,</span>
<span id="cb16-13"><a href="#cb16-13"></a>    <span class="st">`</span><span class="at">rfFuncs</span><span class="st">`</span><span class="ot">=</span>rfFuncs,</span>
<span id="cb16-14"><a href="#cb16-14"></a>    <span class="st">`</span><span class="at">nbFuncs</span><span class="st">`</span><span class="ot">=</span>nbFuncs</span>
<span id="cb16-15"><a href="#cb16-15"></a>    )</span>
<span id="cb16-16"><a href="#cb16-16"></a></span>
<span id="cb16-17"><a href="#cb16-17"></a>  li.num<span class="ot">&lt;-</span><span class="fu">list</span>(<span class="st">`</span><span class="at">F2</span><span class="st">`</span><span class="ot">=</span><span class="dv">2</span>,<span class="st">`</span><span class="at">F3</span><span class="st">`</span><span class="ot">=</span><span class="dv">3</span>,<span class="st">`</span><span class="at">F4</span><span class="st">`</span><span class="ot">=</span><span class="dv">4</span>,<span class="st">`</span><span class="at">F5</span><span class="st">`</span><span class="ot">=</span><span class="dv">5</span>,<span class="st">`</span><span class="at">F6</span><span class="st">`</span><span class="ot">=</span><span class="dv">6</span>)</span>
<span id="cb16-18"><a href="#cb16-18"></a>  x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]]</span>
<span id="cb16-19"><a href="#cb16-19"></a></span>
<span id="cb16-20"><a href="#cb16-20"></a>  dl.final.models<span class="ot">&lt;-</span><span class="fu">lapply</span>(li.num, <span class="cf">function</span>(my.num){</span>
<span id="cb16-21"><a href="#cb16-21"></a>    <span class="co"># 1. glParallel</span></span>
<span id="cb16-22"><a href="#cb16-22"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: glParallel"</span>))</span>
<span id="cb16-23"><a href="#cb16-23"></a>    my.pattern<span class="ot">=</span><span class="fu">paste0</span>(<span class="st">"^core17</span><span class="sc">\\</span><span class="st">.final</span><span class="sc">\\</span><span class="st">.best"</span>,my.num)</span>
<span id="cb16-24"><a href="#cb16-24"></a>    dt.input<span class="ot">&lt;-</span><span class="fu">data.table</span>(</span>
<span id="cb16-25"><a href="#cb16-25"></a>                    <span class="at">foo=</span><span class="fu">list.files</span>(<span class="st">"glParallel/result"</span>,<span class="at">pattern=</span>my.pattern),</span>
<span id="cb16-26"><a href="#cb16-26"></a>                    <span class="at">files=</span><span class="fu">list.files</span>(<span class="st">"glParallel/result"</span>,<span class="at">pattern=</span>my.pattern,<span class="at">full.names=</span>T)</span>
<span id="cb16-27"><a href="#cb16-27"></a>                    )[,<span class="fu">c</span>(<span class="st">"foo1"</span>,<span class="st">"bar1"</span>)<span class="sc">:</span><span class="er">=</span><span class="fu">tstrsplit</span>(foo,<span class="st">"</span><span class="sc">\\</span><span class="st">."</span>,<span class="at">keep=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">3</span>))][,fold<span class="sc">:</span><span class="er">=</span><span class="fu">paste</span>(foo1,bar1,<span class="at">sep=</span><span class="st">"."</span>)][,<span class="fu">c</span>(<span class="st">"foo"</span>,<span class="st">"foo1"</span>,<span class="st">"bar1"</span>)<span class="sc">:</span><span class="er">=</span><span class="cn">NULL</span>]</span>
<span id="cb16-28"><a href="#cb16-28"></a></span>
<span id="cb16-29"><a href="#cb16-29"></a>    dt.glp <span class="ot">&lt;-</span><span class="fu">apply</span>(dt.input, <span class="dv">1</span>, <span class="cf">function</span>(i){</span>
<span id="cb16-30"><a href="#cb16-30"></a>              my.fold<span class="ot">&lt;-</span>i[[<span class="st">"fold"</span>]]</span>
<span id="cb16-31"><a href="#cb16-31"></a>              my.feature<span class="ot">&lt;-</span><span class="fu">fread</span>(i[<span class="st">"files"</span>])[<span class="dv">1</span>][[<span class="st">"Best proteins"</span>]] <span class="sc">%&gt;%</span> <span class="fu">strsplit</span>(<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb16-32"><a href="#cb16-32"></a>              <span class="fu">data.table</span>(<span class="at">method=</span><span class="st">"glParallel"</span>,<span class="at">fold=</span>my.fold,<span class="at">feature=</span>my.feature,<span class="at">score=</span><span class="cn">NA</span>,<span class="at">rank=</span><span class="cn">NA</span>)</span>
<span id="cb16-33"><a href="#cb16-33"></a>              <span class="co">#cbind(`fold`=i[["fold"]],fread(i["files"])[1])</span></span>
<span id="cb16-34"><a href="#cb16-34"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb16-35"><a href="#cb16-35"></a></span>
<span id="cb16-36"><a href="#cb16-36"></a>    <span class="co"># 2. Lasso</span></span>
<span id="cb16-37"><a href="#cb16-37"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: LASSO"</span>))</span>
<span id="cb16-38"><a href="#cb16-38"></a>    dt.lasso<span class="ot">&lt;-</span><span class="fu">get_lasso_coef</span>(<span class="at">x=</span>x, <span class="st">"final"</span>, <span class="at">my.num=</span>my.num)</span>
<span id="cb16-39"><a href="#cb16-39"></a></span>
<span id="cb16-40"><a href="#cb16-40"></a>    <span class="co"># 3. ElasticNet</span></span>
<span id="cb16-41"><a href="#cb16-41"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: ENET"</span>))</span>
<span id="cb16-42"><a href="#cb16-42"></a>    dt.enet<span class="ot">&lt;-</span><span class="fu">get_enet_coef</span>(<span class="at">x=</span>x, <span class="st">"final"</span>, <span class="at">my.num=</span>my.num)</span>
<span id="cb16-43"><a href="#cb16-43"></a></span>
<span id="cb16-44"><a href="#cb16-44"></a>    <span class="co"># 4. mSVM-RFE</span></span>
<span id="cb16-45"><a href="#cb16-45"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: mSVM-RFE"</span>))</span>
<span id="cb16-46"><a href="#cb16-46"></a>    <span class="fu">set.seed</span>(<span class="dv">333</span>)</span>
<span id="cb16-47"><a href="#cb16-47"></a>    ranked.features<span class="ot">&lt;-</span><span class="fu">colnames</span>(x)[<span class="sc">-</span><span class="dv">1</span>][<span class="fu">svmRFE</span>(x, <span class="at">k=</span><span class="dv">5</span>, <span class="at">halve.above=</span><span class="dv">100</span>)][<span class="dv">1</span><span class="sc">:</span>my.num] <span class="co"># only top 4 ranked features</span></span>
<span id="cb16-48"><a href="#cb16-48"></a>    dt.svm<span class="ot">&lt;-</span><span class="fu">data.table</span>(<span class="at">method=</span><span class="st">"mSVM-RFE"</span>,<span class="st">`</span><span class="at">fold</span><span class="st">`</span><span class="ot">=</span><span class="st">"final"</span>,<span class="at">feature=</span>ranked.features, <span class="at">score=</span><span class="cn">NA</span>, <span class="at">rank=</span><span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(ranked.features))</span>
<span id="cb16-49"><a href="#cb16-49"></a></span>
<span id="cb16-50"><a href="#cb16-50"></a>    <span class="co"># 5-10. Other methods via RFE: "svmLinear" "svmRadial" "nnet"      "pcaNNet"   "rfFuncs"   "nbFuncs"</span></span>
<span id="cb16-51"><a href="#cb16-51"></a>    dt.rfe<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">names</span>(li.methods), <span class="cf">function</span>(my.method){</span>
<span id="cb16-52"><a href="#cb16-52"></a>              <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method:"</span>,my.method))</span>
<span id="cb16-53"><a href="#cb16-53"></a>              <span class="fu">runRFE2</span>(<span class="at">x=</span>x, <span class="at">my.method=</span>my.method, <span class="at">my.num=</span>my.num, <span class="at">my.index=</span>li.fold.final, <span class="at">is.final=</span>T)</span>
<span id="cb16-54"><a href="#cb16-54"></a>    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb16-55"><a href="#cb16-55"></a></span>
<span id="cb16-56"><a href="#cb16-56"></a>    <span class="co"># compile all the final models #</span></span>
<span id="cb16-57"><a href="#cb16-57"></a>    <span class="fu">rbind</span>(dt.glp, dt.lasso[method<span class="sc">==</span><span class="st">"LASSO"</span>], dt.enet, dt.svm, dt.rfe)[<span class="fu">order</span>(method,feature)]</span>
<span id="cb16-58"><a href="#cb16-58"></a>  }) <span class="co"># end of dl.final.models</span></span>
<span id="cb16-59"><a href="#cb16-59"></a>  <span class="fu">save</span>(dl.final.models, <span class="at">file=</span>my.RData)</span>
<span id="cb16-60"><a href="#cb16-60"></a>} <span class="co"># end of if</span></span>
<span id="cb16-61"><a href="#cb16-61"></a></span>
<span id="cb16-62"><a href="#cb16-62"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.final.result.core17.RData"</span>)</span>
<span id="cb16-63"><a href="#cb16-63"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb16-64"><a href="#cb16-64"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb16-65"><a href="#cb16-65"></a>}<span class="cf">else</span>{</span>
<span id="cb16-66"><a href="#cb16-66"></a>  mat.tr<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]] <span class="co"># training model</span></span>
<span id="cb16-67"><a href="#cb16-67"></a></span>
<span id="cb16-68"><a href="#cb16-68"></a>  dl.final.result<span class="ot">&lt;-</span><span class="fu">lapply</span>(dl.final.models, <span class="cf">function</span>(dt.model){</span>
<span id="cb16-69"><a href="#cb16-69"></a>    dt.final.model<span class="ot">&lt;-</span>dt.model[,.(.N,<span class="at">features=</span><span class="fu">paste</span>(feature,<span class="at">collapse=</span><span class="st">","</span>)),method][<span class="fu">order</span>(features)]</span>
<span id="cb16-70"><a href="#cb16-70"></a>    dt.final<span class="ot">&lt;-</span>dt.final.model[,.(.N,<span class="at">methods=</span><span class="fu">paste</span>(method,<span class="at">collapse=</span><span class="st">','</span>)),features]</span>
<span id="cb16-71"><a href="#cb16-71"></a></span>
<span id="cb16-72"><a href="#cb16-72"></a>    <span class="do">#######################################################################</span></span>
<span id="cb16-73"><a href="#cb16-73"></a>    <span class="co"># get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb16-74"><a href="#cb16-74"></a>    <span class="do">#######################################################################</span></span>
<span id="cb16-75"><a href="#cb16-75"></a>    dt.final.result<span class="ot">&lt;-</span><span class="fu">lapply</span>(dt.final<span class="sc">$</span>methods, <span class="cf">function</span>(my.methods){</span>
<span id="cb16-76"><a href="#cb16-76"></a>                          <span class="do">############################################</span></span>
<span id="cb16-77"><a href="#cb16-77"></a>                          <span class="co"># fit the model using the training dataset #</span></span>
<span id="cb16-78"><a href="#cb16-78"></a>                          <span class="do">############################################</span></span>
<span id="cb16-79"><a href="#cb16-79"></a>                          my.feature<span class="ot">&lt;-</span>dt.final[methods<span class="sc">==</span>my.methods]<span class="sc">$</span>features <span class="sc">%&gt;%</span> <span class="fu">strsplit</span>(<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb16-80"><a href="#cb16-80"></a>                          df.mat.tr<span class="ot">&lt;-</span>mat.tr[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame  <span class="co"># training set</span></span>
<span id="cb16-81"><a href="#cb16-81"></a>                          my.model<span class="ot">&lt;-</span><span class="fu">glm</span>(y<span class="sc">~</span>. , <span class="at">data =</span> df.mat.tr, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb16-82"><a href="#cb16-82"></a></span>
<span id="cb16-83"><a href="#cb16-83"></a>                          <span class="do">## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb16-84"><a href="#cb16-84"></a>                          dt.foo1<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb16-85"><a href="#cb16-85"></a>                            <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"preterm"</span>,my.methods,my.GA,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb16-86"><a href="#cb16-86"></a>                            x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[my.GA]]</span>
<span id="cb16-87"><a href="#cb16-87"></a>                            my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(preterm)"</span>)</span>
<span id="cb16-88"><a href="#cb16-88"></a>                            <span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb16-89"><a href="#cb16-89"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb16-90"><a href="#cb16-90"></a>                            )</span>
<span id="cb16-91"><a href="#cb16-91"></a>                          }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb16-92"><a href="#cb16-92"></a></span>
<span id="cb16-93"><a href="#cb16-93"></a>                          <span class="do">## term (validation)</span></span>
<span id="cb16-94"><a href="#cb16-94"></a>                          dt.foo2<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>,<span class="st">"36wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb16-95"><a href="#cb16-95"></a>                            <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"term"</span>,my.methods,my.GA,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb16-96"><a href="#cb16-96"></a>                            x<span class="ot">&lt;-</span>li.mat[[<span class="st">"test"</span>]][[my.GA]]</span>
<span id="cb16-97"><a href="#cb16-97"></a>                            my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(term)"</span>)</span>
<span id="cb16-98"><a href="#cb16-98"></a>                            <span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb16-99"><a href="#cb16-99"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb16-100"><a href="#cb16-100"></a>                            )</span>
<span id="cb16-101"><a href="#cb16-101"></a>                          }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb16-102"><a href="#cb16-102"></a>                          </span>
<span id="cb16-103"><a href="#cb16-103"></a>                          <span class="do">## Munchel </span></span>
<span id="cb16-104"><a href="#cb16-104"></a>                          <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Munchel"</span>,my.methods,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb16-105"><a href="#cb16-105"></a>                          x<span class="ot">&lt;-</span>li.mat[[<span class="st">"munchel"</span>]]</span>
<span id="cb16-106"><a href="#cb16-106"></a>                          my.fold<span class="ot">&lt;-</span><span class="st">"Munchel"</span></span>
<span id="cb16-107"><a href="#cb16-107"></a>                          dt.foo3<span class="ot">&lt;-</span><span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb16-108"><a href="#cb16-108"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb16-109"><a href="#cb16-109"></a>                          )</span>
<span id="cb16-110"><a href="#cb16-110"></a></span>
<span id="cb16-111"><a href="#cb16-111"></a>                          <span class="fu">rbind</span>(dt.foo1,dt.foo2,dt.foo3)</span>
<span id="cb16-112"><a href="#cb16-112"></a>                      }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb16-113"><a href="#cb16-113"></a>    dt.final.result<span class="ot">&lt;-</span>dt.final.result[<span class="fu">order</span>(fold,<span class="sc">-</span>AUC_test)]</span>
<span id="cb16-114"><a href="#cb16-114"></a>    dt.final.result</span>
<span id="cb16-115"><a href="#cb16-115"></a>  })</span>
<span id="cb16-116"><a href="#cb16-116"></a>  <span class="fu">save</span>(dl.final.result, <span class="at">file=</span>my.RData)</span>
<span id="cb16-117"><a href="#cb16-117"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>
</section>
<section id="sec-validation" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="sec-validation"><span class="header-section-number">3.5</span> Internal and external validation</h2>
<p>Having identified the winning method (as shown in <a href="main_figure.html#fig-fig3" class="quarto-xref">Figure&nbsp;<span>6.7</span></a> A), it was applied to choose 2 to 10 predictors using the whole 28wkGA samples of the discovery dataset and the selected predictors were used to fit multivariate logistic regression models using the same training dataset (<a href="main_figure.html#fig-fig3" class="quarto-xref">Figure&nbsp;<span>6.7</span></a> B). Finally, we evaluated the predictive performance of those 2- to 10-predictor logistic regression models using the term validation cohort and the external Munchel dataset (as shown in <a href="main_figure.html#fig-fig4" class="quarto-xref">Figure&nbsp;<span>6.8</span></a>).</p>
<div class="cell">
<details class="code-fold">
<summary>Code to run internal and external validations for 2-10 predictors chosen by the winning method of 5-fold CV.</summary>
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.enet.models.core17.RData"</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb17-3"><a href="#cb17-3"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb17-4"><a href="#cb17-4"></a>}<span class="cf">else</span>{</span>
<span id="cb17-5"><a href="#cb17-5"></a>  li.num<span class="ot">&lt;-</span><span class="dv">2</span><span class="sc">:</span><span class="dv">10</span> <span class="sc">%&gt;%</span> as.list</span>
<span id="cb17-6"><a href="#cb17-6"></a>  <span class="fu">names</span>(li.num)<span class="ot">=</span><span class="fu">paste0</span>(<span class="st">"F"</span>,<span class="dv">2</span><span class="sc">:</span><span class="dv">10</span>)</span>
<span id="cb17-7"><a href="#cb17-7"></a></span>
<span id="cb17-8"><a href="#cb17-8"></a>  x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]]</span>
<span id="cb17-9"><a href="#cb17-9"></a></span>
<span id="cb17-10"><a href="#cb17-10"></a>  dl.enet.models<span class="ot">&lt;-</span><span class="fu">lapply</span>(li.num, <span class="cf">function</span>(my.num){</span>
<span id="cb17-11"><a href="#cb17-11"></a>    <span class="co"># 2. Lasso</span></span>
<span id="cb17-12"><a href="#cb17-12"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: LASSO"</span>))</span>
<span id="cb17-13"><a href="#cb17-13"></a>    dt.lasso<span class="ot">&lt;-</span><span class="fu">get_lasso_coef</span>(<span class="at">x=</span>x, <span class="st">"final"</span>, <span class="at">my.num=</span>my.num)</span>
<span id="cb17-14"><a href="#cb17-14"></a></span>
<span id="cb17-15"><a href="#cb17-15"></a>    <span class="co"># 3. ElasticNet</span></span>
<span id="cb17-16"><a href="#cb17-16"></a>    <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Num:"</span>,my.num,<span class="st">"Method: ENET"</span>))</span>
<span id="cb17-17"><a href="#cb17-17"></a>    dt.enet<span class="ot">&lt;-</span><span class="fu">get_enet_coef</span>(<span class="at">x=</span>x, <span class="st">"final"</span>, <span class="at">my.num=</span>my.num)</span>
<span id="cb17-18"><a href="#cb17-18"></a></span>
<span id="cb17-19"><a href="#cb17-19"></a>    <span class="co"># compile all the final models #</span></span>
<span id="cb17-20"><a href="#cb17-20"></a>    <span class="fu">rbind</span>(dt.lasso[method<span class="sc">==</span><span class="st">"LASSO"</span>], dt.enet)[<span class="fu">order</span>(method,feature)]</span>
<span id="cb17-21"><a href="#cb17-21"></a>  }) <span class="co"># end of dl.final.models</span></span>
<span id="cb17-22"><a href="#cb17-22"></a>  <span class="fu">save</span>(dl.enet.models, <span class="at">file=</span>my.RData)</span>
<span id="cb17-23"><a href="#cb17-23"></a>} <span class="co"># end of if</span></span>
<span id="cb17-24"><a href="#cb17-24"></a></span>
<span id="cb17-25"><a href="#cb17-25"></a><span class="do">##</span></span>
<span id="cb17-26"><a href="#cb17-26"></a><span class="do">## ENet and LASSO only using Discovery and Validation datasets</span></span>
<span id="cb17-27"><a href="#cb17-27"></a><span class="do">## </span></span>
<span id="cb17-28"><a href="#cb17-28"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dl.enet.result.core17.RData"</span>)</span>
<span id="cb17-29"><a href="#cb17-29"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb17-30"><a href="#cb17-30"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb17-31"><a href="#cb17-31"></a>}<span class="cf">else</span>{</span>
<span id="cb17-32"><a href="#cb17-32"></a>  mat.tr<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]] <span class="co"># training model</span></span>
<span id="cb17-33"><a href="#cb17-33"></a></span>
<span id="cb17-34"><a href="#cb17-34"></a>  dl.enet.result<span class="ot">&lt;-</span><span class="fu">lapply</span>(dl.enet.models, <span class="cf">function</span>(dt.model){</span>
<span id="cb17-35"><a href="#cb17-35"></a>    dt.final.model<span class="ot">&lt;-</span>dt.model[,.(.N,<span class="at">features=</span><span class="fu">paste</span>(feature,<span class="at">collapse=</span><span class="st">","</span>)),method][<span class="fu">order</span>(features)]</span>
<span id="cb17-36"><a href="#cb17-36"></a>    dt.final<span class="ot">&lt;-</span>dt.final.model[,.(.N,<span class="at">methods=</span><span class="fu">paste</span>(method,<span class="at">collapse=</span><span class="st">','</span>)),features]</span>
<span id="cb17-37"><a href="#cb17-37"></a>    <span class="do">#######################################################################</span></span>
<span id="cb17-38"><a href="#cb17-38"></a>    <span class="co"># get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb17-39"><a href="#cb17-39"></a>    <span class="do">#######################################################################</span></span>
<span id="cb17-40"><a href="#cb17-40"></a>    dt.final.result<span class="ot">&lt;-</span><span class="fu">lapply</span>(dt.final<span class="sc">$</span>methods, <span class="cf">function</span>(my.methods){</span>
<span id="cb17-41"><a href="#cb17-41"></a>                          <span class="do">############################################</span></span>
<span id="cb17-42"><a href="#cb17-42"></a>                          <span class="co"># fit the model using the training dataset #</span></span>
<span id="cb17-43"><a href="#cb17-43"></a>                          <span class="do">############################################</span></span>
<span id="cb17-44"><a href="#cb17-44"></a>                          my.feature<span class="ot">&lt;-</span>dt.final[methods<span class="sc">==</span>my.methods]<span class="sc">$</span>features <span class="sc">%&gt;%</span> <span class="fu">strsplit</span>(<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb17-45"><a href="#cb17-45"></a>                          df.mat.tr<span class="ot">&lt;-</span>mat.tr[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame  <span class="co"># training set</span></span>
<span id="cb17-46"><a href="#cb17-46"></a>                          my.model<span class="ot">&lt;-</span><span class="fu">glm</span>(y<span class="sc">~</span>. , <span class="at">data =</span> df.mat.tr, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb17-47"><a href="#cb17-47"></a></span>
<span id="cb17-48"><a href="#cb17-48"></a>                          <span class="do">## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb17-49"><a href="#cb17-49"></a>                          dt.foo1<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb17-50"><a href="#cb17-50"></a>                            <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"preterm"</span>,my.methods,my.GA,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-51"><a href="#cb17-51"></a>                            x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[my.GA]]</span>
<span id="cb17-52"><a href="#cb17-52"></a>                            my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(preterm)"</span>)</span>
<span id="cb17-53"><a href="#cb17-53"></a>                            <span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb17-54"><a href="#cb17-54"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-55"><a href="#cb17-55"></a>                            )</span>
<span id="cb17-56"><a href="#cb17-56"></a>                          }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-57"><a href="#cb17-57"></a></span>
<span id="cb17-58"><a href="#cb17-58"></a>                          <span class="do">## term (validation)</span></span>
<span id="cb17-59"><a href="#cb17-59"></a>                          dt.foo2<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>,<span class="st">"36wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb17-60"><a href="#cb17-60"></a>                            <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"term"</span>,my.methods,my.GA,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-61"><a href="#cb17-61"></a>                            x<span class="ot">&lt;-</span>li.mat[[<span class="st">"test"</span>]][[my.GA]]</span>
<span id="cb17-62"><a href="#cb17-62"></a>                            my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(term)"</span>)</span>
<span id="cb17-63"><a href="#cb17-63"></a>                            <span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb17-64"><a href="#cb17-64"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-65"><a href="#cb17-65"></a>                            )</span>
<span id="cb17-66"><a href="#cb17-66"></a>                          }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-67"><a href="#cb17-67"></a>                          </span>
<span id="cb17-68"><a href="#cb17-68"></a>                          <span class="do">## Munchel </span></span>
<span id="cb17-69"><a href="#cb17-69"></a>                          <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Munchel"</span>,my.methods,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-70"><a href="#cb17-70"></a>                          x<span class="ot">&lt;-</span>li.mat[[<span class="st">"munchel"</span>]]</span>
<span id="cb17-71"><a href="#cb17-71"></a>                          my.fold<span class="ot">&lt;-</span><span class="st">"Munchel"</span></span>
<span id="cb17-72"><a href="#cb17-72"></a>                          dt.foo3<span class="ot">&lt;-</span><span class="fu">cbind</span>(<span class="st">`</span><span class="at">methods</span><span class="st">`</span><span class="ot">=</span>my.methods,</span>
<span id="cb17-73"><a href="#cb17-73"></a>                                  <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-74"><a href="#cb17-74"></a>                          )</span>
<span id="cb17-75"><a href="#cb17-75"></a></span>
<span id="cb17-76"><a href="#cb17-76"></a>                          <span class="fu">rbind</span>(dt.foo1,dt.foo2,dt.foo3)</span>
<span id="cb17-77"><a href="#cb17-77"></a>                      }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-78"><a href="#cb17-78"></a>    dt.final.result<span class="ot">&lt;-</span>dt.final.result[<span class="fu">order</span>(fold,<span class="sc">-</span>AUC_test)]</span>
<span id="cb17-79"><a href="#cb17-79"></a>    dt.final.result</span>
<span id="cb17-80"><a href="#cb17-80"></a>  }) <span class="co"># end of dl.enet.models</span></span>
<span id="cb17-81"><a href="#cb17-81"></a>  <span class="fu">save</span>(dl.enet.result, <span class="at">file=</span>my.RData)</span>
<span id="cb17-82"><a href="#cb17-82"></a>}</span>
<span id="cb17-83"><a href="#cb17-83"></a></span>
<span id="cb17-84"><a href="#cb17-84"></a><span class="co">#</span></span>
<span id="cb17-85"><a href="#cb17-85"></a><span class="co"># The final best models</span></span>
<span id="cb17-86"><a href="#cb17-86"></a><span class="co">#</span></span>
<span id="cb17-87"><a href="#cb17-87"></a>my.RData<span class="ot">&lt;-</span><span class="fu">file.path</span>(<span class="st">"RData/dt.best.result.core17.RData"</span>)</span>
<span id="cb17-88"><a href="#cb17-88"></a><span class="cf">if</span>(<span class="fu">file.exists</span>(my.RData)){</span>
<span id="cb17-89"><a href="#cb17-89"></a>  <span class="fu">load</span>(my.RData)</span>
<span id="cb17-90"><a href="#cb17-90"></a>}<span class="cf">else</span>{</span>
<span id="cb17-91"><a href="#cb17-91"></a>  my.targets<span class="ot">&lt;-</span><span class="fu">c</span>(<span class="st">"LEP"</span>,<span class="st">"PAPPA2"</span>,<span class="st">"LEP,PAPPA2"</span>,</span>
<span id="cb17-92"><a href="#cb17-92"></a>                <span class="st">"LEP,LY6G6D,PAPPA2"</span> <span class="co"># best performing LASSO 3-mRNA model</span></span>
<span id="cb17-93"><a href="#cb17-93"></a>                )</span>
<span id="cb17-94"><a href="#cb17-94"></a></span>
<span id="cb17-95"><a href="#cb17-95"></a>  mat.tr<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[<span class="st">"28wk"</span>]] <span class="co"># training model</span></span>
<span id="cb17-96"><a href="#cb17-96"></a>  mat.tr<span class="ot">&lt;-</span><span class="fu">cbind</span>(mat.tr, <span class="st">"LEP_PAPPA2"</span><span class="ot">=</span>mat.tr[,<span class="st">"LEP"</span>] <span class="sc">*</span> mat.tr[,<span class="st">"PAPPA2"</span>])</span>
<span id="cb17-97"><a href="#cb17-97"></a></span>
<span id="cb17-98"><a href="#cb17-98"></a>  <span class="do">#######################################################################</span></span>
<span id="cb17-99"><a href="#cb17-99"></a>  <span class="co"># get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb17-100"><a href="#cb17-100"></a>  <span class="do">#######################################################################</span></span>
<span id="cb17-101"><a href="#cb17-101"></a>  my.targets<span class="ot">&lt;-</span><span class="st">"LEP_PAPPA2"</span></span>
<span id="cb17-102"><a href="#cb17-102"></a></span>
<span id="cb17-103"><a href="#cb17-103"></a>  dt.best.result<span class="ot">&lt;-</span><span class="fu">lapply</span>(my.targets, <span class="cf">function</span>(my.proteins){</span>
<span id="cb17-104"><a href="#cb17-104"></a>                        <span class="do">############################################</span></span>
<span id="cb17-105"><a href="#cb17-105"></a>                        <span class="co"># fit the model using the training dataset #</span></span>
<span id="cb17-106"><a href="#cb17-106"></a>                        <span class="do">############################################</span></span>
<span id="cb17-107"><a href="#cb17-107"></a>                        my.feature<span class="ot">&lt;-</span><span class="fu">strsplit</span>(my.proteins,<span class="st">","</span>) <span class="sc">%&gt;%</span> unlist</span>
<span id="cb17-108"><a href="#cb17-108"></a>                        df.mat.tr<span class="ot">&lt;-</span>mat.tr[,<span class="fu">c</span>(my.feature,<span class="st">'y'</span>)] <span class="sc">%&gt;%</span> as.data.frame  <span class="co"># training set</span></span>
<span id="cb17-109"><a href="#cb17-109"></a>                        my.model<span class="ot">&lt;-</span><span class="fu">glm</span>(y<span class="sc">~</span>. , <span class="at">data =</span> df.mat.tr, <span class="at">family =</span> <span class="st">"binomial"</span>)</span>
<span id="cb17-110"><a href="#cb17-110"></a></span>
<span id="cb17-111"><a href="#cb17-111"></a>                        <span class="do">## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb17-112"><a href="#cb17-112"></a>                        dt.foo1<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb17-113"><a href="#cb17-113"></a>                          <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"preterm"</span>,my.GA,my.proteins,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-114"><a href="#cb17-114"></a>                          x<span class="ot">&lt;-</span>li.mat[[<span class="st">"train"</span>]][[my.GA]]</span>
<span id="cb17-115"><a href="#cb17-115"></a>                          x<span class="ot">&lt;-</span><span class="fu">cbind</span>(x, <span class="st">"LEP_PAPPA2"</span><span class="ot">=</span>x[,<span class="st">"LEP"</span>] <span class="sc">*</span> x[,<span class="st">"PAPPA2"</span>])</span>
<span id="cb17-116"><a href="#cb17-116"></a>                          my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(preterm)"</span>)</span>
<span id="cb17-117"><a href="#cb17-117"></a>                          <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-118"><a href="#cb17-118"></a>                        }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-119"><a href="#cb17-119"></a></span>
<span id="cb17-120"><a href="#cb17-120"></a>                        <span class="do">## term (validation)</span></span>
<span id="cb17-121"><a href="#cb17-121"></a>                        dt.foo2<span class="ot">&lt;-</span><span class="fu">lapply</span>(<span class="fu">c</span>(<span class="st">"12wk"</span>,<span class="st">"20wk"</span>,<span class="st">"28wk"</span>,<span class="st">"36wk"</span>), <span class="cf">function</span>(my.GA){</span>
<span id="cb17-122"><a href="#cb17-122"></a>                          <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"term"</span>,my.GA,my.proteins,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-123"><a href="#cb17-123"></a>                          x<span class="ot">&lt;-</span>li.mat[[<span class="st">"test"</span>]][[my.GA]]</span>
<span id="cb17-124"><a href="#cb17-124"></a>                          x<span class="ot">&lt;-</span><span class="fu">cbind</span>(x, <span class="st">"LEP_PAPPA2"</span><span class="ot">=</span>x[,<span class="st">"LEP"</span>] <span class="sc">*</span> x[,<span class="st">"PAPPA2"</span>])</span>
<span id="cb17-125"><a href="#cb17-125"></a>                          my.fold<span class="ot">&lt;-</span><span class="fu">paste0</span>(my.GA,<span class="st">"(term)"</span>)</span>
<span id="cb17-126"><a href="#cb17-126"></a>                          <span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-127"><a href="#cb17-127"></a>                        }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-128"><a href="#cb17-128"></a>                        </span>
<span id="cb17-129"><a href="#cb17-129"></a>                        <span class="do">## Munchel </span></span>
<span id="cb17-130"><a href="#cb17-130"></a>                        <span class="fu">message</span>(<span class="fu">paste</span>(<span class="st">"Munchel"</span>,my.proteins,<span class="at">sep=</span><span class="st">":"</span>))</span>
<span id="cb17-131"><a href="#cb17-131"></a>                        x<span class="ot">&lt;-</span>li.mat[[<span class="st">"munchel"</span>]]</span>
<span id="cb17-132"><a href="#cb17-132"></a>                        x<span class="ot">&lt;-</span><span class="fu">cbind</span>(x, <span class="st">"LEP_PAPPA2"</span><span class="ot">=</span>x[,<span class="st">"LEP"</span>] <span class="sc">*</span> x[,<span class="st">"PAPPA2"</span>])</span>
<span id="cb17-133"><a href="#cb17-133"></a>                        my.fold<span class="ot">&lt;-</span><span class="st">"Munchel"</span></span>
<span id="cb17-134"><a href="#cb17-134"></a>                        dt.foo3<span class="ot">&lt;-</span><span class="fu">get_cv_glm2</span>(<span class="at">x=</span>x,<span class="at">my.fold=</span>my.fold,<span class="at">my.model=</span>my.model,<span class="at">my.feature=</span>my.feature)</span>
<span id="cb17-135"><a href="#cb17-135"></a>                        <span class="fu">rbind</span>(dt.foo1,dt.foo2,dt.foo3)</span>
<span id="cb17-136"><a href="#cb17-136"></a>                    }) <span class="sc">%&gt;%</span> rbindlist</span>
<span id="cb17-137"><a href="#cb17-137"></a>  <span class="fu">save</span>(dt.best.result, <span class="at">file=</span>my.RData)</span>
<span id="cb17-138"><a href="#cb17-138"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</details>
</div>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = true;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./quant.html" class="pagination-link" aria-label="RNA-seq data processing">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">RNA-seq data processing</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./SI_select_quant_method.html" class="pagination-link" aria-label="Selection of RNA-seq quantification method">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Selection of RNA-seq quantification method</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb18" data-shortcodes="false"><pre class="sourceCode numberSource markdown number-lines code-with-copy"><code class="sourceCode markdown"><span id="cb18-1"><a href="#cb18-1"></a><span class="fu"># Cross Validation {#sec-cv}</span></span>
<span id="cb18-2"><a href="#cb18-2"></a></span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="fu">## Data preparation {#sec-cv-prep}</span></span>
<span id="cb18-4"><a href="#cb18-4"></a></span>
<span id="cb18-5"><a href="#cb18-5"></a><span class="fu">### Internal validation cohort {#sec-cv-prep-int-val}</span></span>
<span id="cb18-6"><a href="#cb18-6"></a></span>
<span id="cb18-7"><a href="#cb18-7"></a>Internal validation dataset was from the <span class="in">`Validation`</span> dataset shown in @fig-fig1 C. </span>
<span id="cb18-8"><a href="#cb18-8"></a></span>
<span id="cb18-9"><a href="#cb18-9"></a>Now we set up the <span class="in">`Salmon`</span> quant files of the validation (i.e. term) dataset. NB, <span class="in">`dt.colllDataAll`</span> (shown from the code below) was set up from @lst-prep-quant-sf.</span>
<span id="cb18-10"><a href="#cb18-10"></a></span>
<span id="cb18-11"><a href="#cb18-11"></a><span class="in">```{r set-term-discovery}</span></span>
<span id="cb18-12"><a href="#cb18-12"></a><span class="in">#| label: set-term</span></span>
<span id="cb18-13"><a href="#cb18-13"></a><span class="in">#| eval: false</span></span>
<span id="cb18-14"><a href="#cb18-14"></a><span class="in">#| code-summary: Code to set the `Salmon` quant files of the term dataset (i.e. Validation dataset)</span></span>
<span id="cb18-15"><a href="#cb18-15"></a><span class="in"># remove these two samples as both of them flagged as "failed" by illumina (it is a 28wk control sample)</span></span>
<span id="cb18-16"><a href="#cb18-16"></a><span class="in">dt.colDataTerm&lt;-dt.colDataAll[Type=="term" &amp; !names %in% c("GS-B-374-UW","GS-B-374-UW-b")] </span></span>
<span id="cb18-17"><a href="#cb18-17"></a><span class="in">li.GA.term&lt;-split(dt.colDataTerm, dt.colDataTerm$GA)</span></span>
<span id="cb18-18"><a href="#cb18-18"></a><span class="in">```</span></span>
<span id="cb18-19"><a href="#cb18-19"></a></span>
<span id="cb18-20"><a href="#cb18-20"></a>We are ready to read the <span class="in">`Salmon`</span> quant files via <span class="in">`tximeta`</span> R package. NB, the code below is equivalent to @lst-prep-dds and @lst-set-dds from the discovery cohort (see @sec-mtd-deg-deseq2).</span>
<span id="cb18-21"><a href="#cb18-21"></a></span>
<span id="cb18-22"><a href="#cb18-22"></a><span class="in">```{r prep-term-dds1}</span></span>
<span id="cb18-23"><a href="#cb18-23"></a><span class="in">#| label: prep-term-dds</span></span>
<span id="cb18-24"><a href="#cb18-24"></a><span class="in">#| eval: false</span></span>
<span id="cb18-25"><a href="#cb18-25"></a><span class="in">#| code-summary: Code to read the `Salmon` quant files of the term dataset and make `dds` object.</span></span>
<span id="cb18-26"><a href="#cb18-26"></a><span class="in">my.dds.RData&lt;-paste0("RData/dds.term.",my.salmon.index,".RData")</span></span>
<span id="cb18-27"><a href="#cb18-27"></a><span class="in">if(file.exists(my.dds.RData)){</span></span>
<span id="cb18-28"><a href="#cb18-28"></a><span class="in">  load(my.dds.RData)</span></span>
<span id="cb18-29"><a href="#cb18-29"></a><span class="in">  message("loading dds...")</span></span>
<span id="cb18-30"><a href="#cb18-30"></a><span class="in">}else{</span></span>
<span id="cb18-31"><a href="#cb18-31"></a><span class="in">  gse.term&lt;-tximeta::tximeta(dt.colDataTerm,skipMeta=T,tx2gene=dt.tx2gene[,.(transcript_id,gene_id)],txOut=F)</span></span>
<span id="cb18-32"><a href="#cb18-32"></a><span class="in">  # set up `dds` at gene-level</span></span>
<span id="cb18-33"><a href="#cb18-33"></a><span class="in">  my.design &lt;- formula(~ Batch + GA + Sex + Condition)      # isa 'formula'</span></span>
<span id="cb18-34"><a href="#cb18-34"></a><span class="in">  dds.term &lt;- DESeqDataSet(se=gse.term, design=my.design) </span></span>
<span id="cb18-35"><a href="#cb18-35"></a></span>
<span id="cb18-36"><a href="#cb18-36"></a><span class="in">  dds.term$Group&lt;-factor(paste0(dds.term$GA,dds.term$Condition)) # add 'Group'</span></span>
<span id="cb18-37"><a href="#cb18-37"></a><span class="in">  design(dds.term) &lt;- formula(~ Batch + Sex + Group)        # isa 'formula'</span></span>
<span id="cb18-38"><a href="#cb18-38"></a></span>
<span id="cb18-39"><a href="#cb18-39"></a><span class="in">  #</span></span>
<span id="cb18-40"><a href="#cb18-40"></a><span class="in">  dds.term&lt;- DESeq(dds.term, parallel=TRUE) # isa 'DESeqDataSet'</span></span>
<span id="cb18-41"><a href="#cb18-41"></a><span class="in">  save(dds.term,file=my.dds.RData)</span></span>
<span id="cb18-42"><a href="#cb18-42"></a><span class="in">}</span></span>
<span id="cb18-43"><a href="#cb18-43"></a></span>
<span id="cb18-44"><a href="#cb18-44"></a><span class="in"># use 15150 genes considered in this study</span></span>
<span id="cb18-45"><a href="#cb18-45"></a><span class="in">dds.f2.term&lt;-DESeq(dds.term[rownames(dds.f2)], parallel=T)</span></span>
<span id="cb18-46"><a href="#cb18-46"></a></span>
<span id="cb18-47"><a href="#cb18-47"></a><span class="in">my.dl.resLFC.RData&lt;-paste0("RData/dl.resLFC.term.",my.salmon.index,".RData")</span></span>
<span id="cb18-48"><a href="#cb18-48"></a><span class="in">if(file.exists(my.dl.resLFC.RData)){</span></span>
<span id="cb18-49"><a href="#cb18-49"></a><span class="in">  load(my.dl.resLFC.RData)</span></span>
<span id="cb18-50"><a href="#cb18-50"></a><span class="in">}else{</span></span>
<span id="cb18-51"><a href="#cb18-51"></a><span class="in">  # apply shink</span></span>
<span id="cb18-52"><a href="#cb18-52"></a><span class="in">  li.resLFC.term&lt;-lapply(names(li.GA.term),function(my.GA){</span></span>
<span id="cb18-53"><a href="#cb18-53"></a><span class="in">    my.res&lt;-results(dds.f2.term, </span></span>
<span id="cb18-54"><a href="#cb18-54"></a><span class="in">            #alpha=.05, # by default independant filtering at FDR (alpha) 0.1 (10%) </span></span>
<span id="cb18-55"><a href="#cb18-55"></a><span class="in">            independentFiltering=FALSE,</span></span>
<span id="cb18-56"><a href="#cb18-56"></a><span class="in">            lfcThreshold=log2(minFC), </span></span>
<span id="cb18-57"><a href="#cb18-57"></a><span class="in">            contrast=c("Group",paste0(my.GA,c("Case","Control"))),</span></span>
<span id="cb18-58"><a href="#cb18-58"></a><span class="in">            parallel=TRUE)  </span></span>
<span id="cb18-59"><a href="#cb18-59"></a><span class="in">    lfcShrink(dds.f2.term, </span></span>
<span id="cb18-60"><a href="#cb18-60"></a><span class="in">              #contrast=c("Group",paste0(my.GA,c("Case","Control"))), # not necessary for 'ashr'</span></span>
<span id="cb18-61"><a href="#cb18-61"></a><span class="in">              res=my.res, #li.res[[my.GA]],</span></span>
<span id="cb18-62"><a href="#cb18-62"></a><span class="in">              lfcThreshold=log2(minFC), # not applicable for 'asher' </span></span>
<span id="cb18-63"><a href="#cb18-63"></a><span class="in">              type="ashr",</span></span>
<span id="cb18-64"><a href="#cb18-64"></a><span class="in">              parallel=TRUE)  </span></span>
<span id="cb18-65"><a href="#cb18-65"></a><span class="in">  })</span></span>
<span id="cb18-66"><a href="#cb18-66"></a><span class="in">  names(li.resLFC.term)&lt;-names(li.GA.term)</span></span>
<span id="cb18-67"><a href="#cb18-67"></a></span>
<span id="cb18-68"><a href="#cb18-68"></a><span class="in">  dl.resLFC.term&lt;-lapply(li.resLFC.term, function(i)</span></span>
<span id="cb18-69"><a href="#cb18-69"></a><span class="in">    data.table(`gene_id`=rownames(i), as.data.frame(i))[order(pvalue)][,`:=`("BH"=p.adjust(pvalue,"BH"),"BY"=p.adjust(pvalue,"BY"),"bf"=p.adjust(pvalue,"bonferroni"))]</span></span>
<span id="cb18-70"><a href="#cb18-70"></a><span class="in">  )</span></span>
<span id="cb18-71"><a href="#cb18-71"></a><span class="in">  save(dl.resLFC.term, file=my.dl.resLFC.RData)</span></span>
<span id="cb18-72"><a href="#cb18-72"></a><span class="in">  #fwrite(dl.resLFC[["28wk"]], file=paste0("data/DEG.DSeq2.28wk.",my.type,".",my.salmon.index,".csv"))</span></span>
<span id="cb18-73"><a href="#cb18-73"></a><span class="in">}</span></span>
<span id="cb18-74"><a href="#cb18-74"></a><span class="in">```</span></span>
<span id="cb18-75"><a href="#cb18-75"></a></span>
<span id="cb18-76"><a href="#cb18-76"></a>Now we use <span class="in">`edgeR`</span>. NB, this is equivalent to @lst-set-edger shown in @sec-mtd-deg-edger.</span>
<span id="cb18-77"><a href="#cb18-77"></a></span>
<span id="cb18-78"><a href="#cb18-78"></a><span class="in">```{r init-edger-term1}</span></span>
<span id="cb18-79"><a href="#cb18-79"></a><span class="in">#| label: init-edger-term</span></span>
<span id="cb18-80"><a href="#cb18-80"></a><span class="in">#| eval: false</span></span>
<span id="cb18-81"><a href="#cb18-81"></a><span class="in">#| code-summary: "Code to find DEGs by `edgeR` from the term dataset"</span></span>
<span id="cb18-82"><a href="#cb18-82"></a><span class="in">gse2 &lt;-gse.term[rownames(dds.f2.term),]</span></span>
<span id="cb18-83"><a href="#cb18-83"></a><span class="in">d2&lt;-tximeta::makeDGEList(gse2)</span></span>
<span id="cb18-84"><a href="#cb18-84"></a><span class="in">d2$samples&lt;-cbind(d2$samples,colData(gse2))</span></span>
<span id="cb18-85"><a href="#cb18-85"></a><span class="in">d2$samples$group&lt;-factor(paste0(d2$samples$GA,d2$samples$Condition)) # add 'group'</span></span>
<span id="cb18-86"><a href="#cb18-86"></a><span class="in">d2$samples$GA&lt;-droplevels(d2$samples$GA) # 36wk removed - really? 2023-03-21</span></span>
<span id="cb18-87"><a href="#cb18-87"></a><span class="in">d2$samples$Batch&lt;-droplevels(d2$samples$Batch) # some batches removed</span></span>
<span id="cb18-88"><a href="#cb18-88"></a></span>
<span id="cb18-89"><a href="#cb18-89"></a><span class="in"># TMM normalisation (default). It adds `norm.factors` d2$samples</span></span>
<span id="cb18-90"><a href="#cb18-90"></a><span class="in"># NB, we have `offsets`, which take precedence over lib.size and norm.factors</span></span>
<span id="cb18-91"><a href="#cb18-91"></a><span class="in">d2&lt;-calcNormFactors(d2,method="TMM") </span></span>
<span id="cb18-92"><a href="#cb18-92"></a></span>
<span id="cb18-93"><a href="#cb18-93"></a><span class="in"># design</span></span>
<span id="cb18-94"><a href="#cb18-94"></a><span class="in"># my.design &lt;- model.matrix(~ Batch + Sex + group, data=d2$samples)         # isa 'matrix'</span></span>
<span id="cb18-95"><a href="#cb18-95"></a><span class="in">#my.design &lt;- model.matrix(~ 0 + group,  data=d2$samples)       # isa 'matrix'</span></span>
<span id="cb18-96"><a href="#cb18-96"></a><span class="in">my.design &lt;- model.matrix(~ 0 + group + Sex + Batch , data=d2$samples)      # isa 'matrix'</span></span>
<span id="cb18-97"><a href="#cb18-97"></a><span class="in">(my.contrasts &lt;- makeContrasts(`12wk`=group12wkCase-group12wkControl, </span></span>
<span id="cb18-98"><a href="#cb18-98"></a><span class="in">                              `20wk`=group20wkCase-group20wkControl, </span></span>
<span id="cb18-99"><a href="#cb18-99"></a><span class="in">                              `28wk`=group28wkCase-group28wkControl, </span></span>
<span id="cb18-100"><a href="#cb18-100"></a><span class="in">                              levels=my.design)</span></span>
<span id="cb18-101"><a href="#cb18-101"></a><span class="in">)</span></span>
<span id="cb18-102"><a href="#cb18-102"></a></span>
<span id="cb18-103"><a href="#cb18-103"></a><span class="in"># dispersion</span></span>
<span id="cb18-104"><a href="#cb18-104"></a><span class="in">#dp2 = estimateDisp(d2, design=my.design, verbose=T)</span></span>
<span id="cb18-105"><a href="#cb18-105"></a><span class="in">dp2 = estimateGLMCommonDisp(d2, design=my.design, verbose=T) </span></span>
<span id="cb18-106"><a href="#cb18-106"></a><span class="in">dp2 = estimateGLMTrendedDisp(dp2, design=my.design, verbose=T)</span></span>
<span id="cb18-107"><a href="#cb18-107"></a><span class="in">dp2 = estimateGLMTagwiseDisp(dp2, design=my.design)</span></span>
<span id="cb18-108"><a href="#cb18-108"></a></span>
<span id="cb18-109"><a href="#cb18-109"></a><span class="in">#f = glmFit(dp2, design=my.design) # </span></span>
<span id="cb18-110"><a href="#cb18-110"></a><span class="in">f = glmQLFit(dp2, design=my.design) # QL(Quasi-like) pipeline</span></span>
<span id="cb18-111"><a href="#cb18-111"></a><span class="in">colnames(f)</span></span>
<span id="cb18-112"><a href="#cb18-112"></a><span class="in">f$coefficients %&gt;% head</span></span>
<span id="cb18-113"><a href="#cb18-113"></a></span>
<span id="cb18-114"><a href="#cb18-114"></a><span class="in"># get the edgeR results</span></span>
<span id="cb18-115"><a href="#cb18-115"></a><span class="in">li.res.edgeR.term&lt;-lapply(names(li.GA.term), function(i){</span></span>
<span id="cb18-116"><a href="#cb18-116"></a><span class="in">  te &lt;- glmTreat(f, contrast=my.contrasts[,i], lfc=log2(minFC))</span></span>
<span id="cb18-117"><a href="#cb18-117"></a><span class="in">  topTags(te, n=nrow(te))    # default sort by pvalue</span></span>
<span id="cb18-118"><a href="#cb18-118"></a><span class="in">})</span></span>
<span id="cb18-119"><a href="#cb18-119"></a><span class="in">names(li.res.edgeR.term) &lt;-names(li.GA.term)</span></span>
<span id="cb18-120"><a href="#cb18-120"></a></span>
<span id="cb18-121"><a href="#cb18-121"></a><span class="in">dl.res.edgeR.term&lt;-lapply(li.res.edgeR.term, function(i)</span></span>
<span id="cb18-122"><a href="#cb18-122"></a><span class="in">  data.table(`gene_id`=rownames(i),i$table)[order(PValue)][,`:=`("BH"=p.adjust(PValue,"BH"),"BY"=p.adjust(PValue,"BY"),"bf"=p.adjust(PValue,"bonferroni"))]</span></span>
<span id="cb18-123"><a href="#cb18-123"></a><span class="in">)</span></span>
<span id="cb18-124"><a href="#cb18-124"></a></span>
<span id="cb18-125"><a href="#cb18-125"></a><span class="in">my.dl.res.edgeR.RData&lt;-paste0("RData/dl.res.edgeR.term.",my.salmon.index,".RData")</span></span>
<span id="cb18-126"><a href="#cb18-126"></a><span class="in">save(dl.res.edgeR.term, file=my.dl.res.edgeR.RData)</span></span>
<span id="cb18-127"><a href="#cb18-127"></a><span class="in">#fwrite(dl.res.edgeR[["28wk"]], file=paste0("data/DEG.edgeR.28wk.",my.type,".",my.salmon.index,".csv"))</span></span>
<span id="cb18-128"><a href="#cb18-128"></a><span class="in">```</span></span>
<span id="cb18-129"><a href="#cb18-129"></a></span>
<span id="cb18-130"><a href="#cb18-130"></a>The gene-level count matrix was converted as the unit of CPM (Count Per Million), in log2-scale, via the “cpm” function of edgeR and it was further transformed into a matrix of the z-score using the mean and standard deviation of logCPM from the control samples of each corresponding gestational age group. NB, this is equivalent to @lst-cnt-cpm shown in @sec-zscore-mat.</span>
<span id="cb18-131"><a href="#cb18-131"></a></span>
<span id="cb18-132"><a href="#cb18-132"></a><span class="in">```{r dt-cnt-cpm-term2}</span></span>
<span id="cb18-133"><a href="#cb18-133"></a><span class="in">#| label: dt-cnt-cpm-term</span></span>
<span id="cb18-134"><a href="#cb18-134"></a><span class="in">#| eval: false</span></span>
<span id="cb18-135"><a href="#cb18-135"></a><span class="in">#| code-summary: Code to make the count matrix from the validation dataset</span></span>
<span id="cb18-136"><a href="#cb18-136"></a><span class="in"># based on genes from dds.f2.term</span></span>
<span id="cb18-137"><a href="#cb18-137"></a><span class="in"># CPM based on edgeR TMM  (NB, d isa "DGEList")</span></span>
<span id="cb18-138"><a href="#cb18-138"></a><span class="in">my.cnt.RData&lt;-paste0("RData/dt.count2.term.",my.salmon.index,".RData")</span></span>
<span id="cb18-139"><a href="#cb18-139"></a><span class="in">if(file.exists(my.cnt.RData)){</span></span>
<span id="cb18-140"><a href="#cb18-140"></a><span class="in">  load(my.cnt.RData)</span></span>
<span id="cb18-141"><a href="#cb18-141"></a><span class="in">}else{</span></span>
<span id="cb18-142"><a href="#cb18-142"></a><span class="in">  dt.count&lt;-merge(</span></span>
<span id="cb18-143"><a href="#cb18-143"></a><span class="in">    data.table(`geneName`=rownames(dds.f2.term),counts(dds.f2.term,normalized=T)) %&gt;% </span></span>
<span id="cb18-144"><a href="#cb18-144"></a><span class="in">      melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="Count"),</span></span>
<span id="cb18-145"><a href="#cb18-145"></a><span class="in">    dt.samples[Type=="term",.(SampleID,GA,Condition,Group=paste(GA,Condition,sep="-"))]</span></span>
<span id="cb18-146"><a href="#cb18-146"></a><span class="in">  )</span></span>
<span id="cb18-147"><a href="#cb18-147"></a></span>
<span id="cb18-148"><a href="#cb18-148"></a><span class="in">  # CPM based on DESeq2 `fpm`</span></span>
<span id="cb18-149"><a href="#cb18-149"></a><span class="in">  dt.cpm&lt;-merge(</span></span>
<span id="cb18-150"><a href="#cb18-150"></a><span class="in">    data.table(`geneName`=rownames(dds.f2.term),fpm(dds.f2.term)) %&gt;% </span></span>
<span id="cb18-151"><a href="#cb18-151"></a><span class="in">      melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="CPM"),</span></span>
<span id="cb18-152"><a href="#cb18-152"></a><span class="in">    dt.samples[Type=="term",.(SampleID,GA,Condition,Group=paste(GA,Condition,sep="-"))]</span></span>
<span id="cb18-153"><a href="#cb18-153"></a><span class="in">  )</span></span>
<span id="cb18-154"><a href="#cb18-154"></a></span>
<span id="cb18-155"><a href="#cb18-155"></a><span class="in">  dt.tpm&lt;-merge(</span></span>
<span id="cb18-156"><a href="#cb18-156"></a><span class="in">    data.table(`geneName`=rownames(dds.f2.term), assays(dds.f2.term)[["abundance"]]) %&gt;% </span></span>
<span id="cb18-157"><a href="#cb18-157"></a><span class="in">      melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="TPM"),</span></span>
<span id="cb18-158"><a href="#cb18-158"></a><span class="in">    dt.samples[Type=="term",.(SampleID,GA,Condition,Group=paste(GA,Condition,sep="-"))]</span></span>
<span id="cb18-159"><a href="#cb18-159"></a><span class="in">  )</span></span>
<span id="cb18-160"><a href="#cb18-160"></a></span>
<span id="cb18-161"><a href="#cb18-161"></a><span class="in">  # CPM based on edgeR TMM  (NB, d isa "DGEList")</span></span>
<span id="cb18-162"><a href="#cb18-162"></a><span class="in">  dt.cpm2&lt;-merge(</span></span>
<span id="cb18-163"><a href="#cb18-163"></a><span class="in">    data.table(`geneName`=rownames(d2),cpm(d2)) %&gt;% </span></span>
<span id="cb18-164"><a href="#cb18-164"></a><span class="in">      melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="CPM"),</span></span>
<span id="cb18-165"><a href="#cb18-165"></a><span class="in">    dt.samples[Type=="term",.(SampleID,GA,Condition,Group=paste(GA,Condition,sep="-"))]</span></span>
<span id="cb18-166"><a href="#cb18-166"></a><span class="in">    )</span></span>
<span id="cb18-167"><a href="#cb18-167"></a></span>
<span id="cb18-168"><a href="#cb18-168"></a><span class="in">  dt.logcpm2&lt;-merge(</span></span>
<span id="cb18-169"><a href="#cb18-169"></a><span class="in">    data.table(`geneName`=rownames(d2),cpm(d2,log=T)) %&gt;% </span></span>
<span id="cb18-170"><a href="#cb18-170"></a><span class="in">      melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="logCPM"),</span></span>
<span id="cb18-171"><a href="#cb18-171"></a><span class="in">    dt.samples[Type=="term",.(SampleID,GA,Condition,Group=paste(GA,Condition,sep="-"))]</span></span>
<span id="cb18-172"><a href="#cb18-172"></a><span class="in">    )</span></span>
<span id="cb18-173"><a href="#cb18-173"></a></span>
<span id="cb18-174"><a href="#cb18-174"></a><span class="in">  save(dt.count, dt.cpm, dt.tpm, dt.cpm2, dt.logcpm2, file=my.cnt.RData)</span></span>
<span id="cb18-175"><a href="#cb18-175"></a><span class="in">}</span></span>
<span id="cb18-176"><a href="#cb18-176"></a><span class="in">```</span></span>
<span id="cb18-177"><a href="#cb18-177"></a></span>
<span id="cb18-178"><a href="#cb18-178"></a><span class="in">```{r cpm-zscore-term1}</span></span>
<span id="cb18-179"><a href="#cb18-179"></a><span class="in">#| label: cpm-zscore-term</span></span>
<span id="cb18-180"><a href="#cb18-180"></a><span class="in">#| eval: false</span></span>
<span id="cb18-181"><a href="#cb18-181"></a><span class="in">#| code-summary: Code to make the z-score matrix from the validation dataset</span></span>
<span id="cb18-182"><a href="#cb18-182"></a><span class="in">my.cpmZ.RData&lt;-paste0("RData/dt.cpmZ.term.",my.salmon.index,".RData")</span></span>
<span id="cb18-183"><a href="#cb18-183"></a><span class="in">if(file.exists(my.cpmZ.RData)){</span></span>
<span id="cb18-184"><a href="#cb18-184"></a><span class="in">  load(my.cpmZ.RData)</span></span>
<span id="cb18-185"><a href="#cb18-185"></a><span class="in">}else{</span></span>
<span id="cb18-186"><a href="#cb18-186"></a><span class="in">  dt.cpmZ.term=merge(dt.logcpm2,</span></span>
<span id="cb18-187"><a href="#cb18-187"></a><span class="in">                dt.logcpm2[Condition=="Control",.(Mean=mean(logCPM),SD=sd(logCPM)),.(GA,geneName)]</span></span>
<span id="cb18-188"><a href="#cb18-188"></a><span class="in">        ,by=c("GA","geneName")</span></span>
<span id="cb18-189"><a href="#cb18-189"></a><span class="in">        )[,.(Group,GA,Condition,SampleID,geneName,logCPM,logCPMZ=(logCPM-Mean)/SD)]</span></span>
<span id="cb18-190"><a href="#cb18-190"></a><span class="in">  save(dt.cpmZ.term,file=my.cpmZ.RData)</span></span>
<span id="cb18-191"><a href="#cb18-191"></a><span class="in">}</span></span>
<span id="cb18-192"><a href="#cb18-192"></a><span class="in">```</span></span>
<span id="cb18-193"><a href="#cb18-193"></a></span>
<span id="cb18-194"><a href="#cb18-194"></a><span class="fu">### External validation dataset {#sec-cv-prep-ext-val}</span></span>
<span id="cb18-195"><a href="#cb18-195"></a></span>
<span id="cb18-196"><a href="#cb18-196"></a>For an external validation, we downloaded the raw sequencing counts file (<span class="co">[</span><span class="ot">Data File S2</span><span class="co">](https://www.science.org/doi/suppl/10.1126/scitranslmed.aaz0131/suppl_file/aaz0131_data_file_s2.xlsx)</span>: Raw whole-transcriptome sequencing counts for iPEC cohort; n=113) from <span class="co">[</span><span class="ot">Munchel et al.</span><span class="co">](https://pubmed.ncbi.nlm.nih.gov/32611681/)</span>. The Data File (in the excel file format) was read and parsed by using <span class="co">[</span><span class="ot">`readxl`</span><span class="co">](https://readxl.tidyverse.org/)</span> (v1.3.1) and <span class="co">[</span><span class="ot">`data.table`</span><span class="co">](https://rdatatable.gitlab.io/data.table/)</span> (v1.13.6) R packages, respectively. </span>
<span id="cb18-197"><a href="#cb18-197"></a></span>
<span id="cb18-198"><a href="#cb18-198"></a>For downstream processing, we only considered those genes in the final set of 15,150 genes that were used in the differentially expressed gene analysis of the discovery and the validation cohort (see @sec-mtd-deg-deseq2). </span>
<span id="cb18-199"><a href="#cb18-199"></a></span>
<span id="cb18-200"><a href="#cb18-200"></a><span class="in">```{r munchel-dds-init}</span></span>
<span id="cb18-201"><a href="#cb18-201"></a><span class="in">#| label: munchel-dds-init </span></span>
<span id="cb18-202"><a href="#cb18-202"></a><span class="in">#| eval: false</span></span>
<span id="cb18-203"><a href="#cb18-203"></a><span class="in">#| code-summary: "Code to import Munchel dataset and make `dds` object by `DESeq2`"</span></span>
<span id="cb18-204"><a href="#cb18-204"></a><span class="in">my.dds.RData&lt;-paste0("RData/dds.munchel.RData")</span></span>
<span id="cb18-205"><a href="#cb18-205"></a><span class="in">if(file.exists(my.dds.RData)){</span></span>
<span id="cb18-206"><a href="#cb18-206"></a><span class="in">  load(my.dds.RData)</span></span>
<span id="cb18-207"><a href="#cb18-207"></a><span class="in">  message("loading dds...")</span></span>
<span id="cb18-208"><a href="#cb18-208"></a><span class="in">}else{</span></span>
<span id="cb18-209"><a href="#cb18-209"></a><span class="in">  # import</span></span>
<span id="cb18-210"><a href="#cb18-210"></a><span class="in">  dt.foo&lt;-readxl::read_excel("~/data/Munchel/SciTrMed.2020/aaz0131_data_file_s2.xlsx",skip=3) %&gt;% as.data.table</span></span>
<span id="cb18-211"><a href="#cb18-211"></a><span class="in">  dt.foo[,-c("Chr","Start","End","Strand")][1:5,1:5]</span></span>
<span id="cb18-212"><a href="#cb18-212"></a></span>
<span id="cb18-213"><a href="#cb18-213"></a><span class="in">  # sample info with GA of sample collection</span></span>
<span id="cb18-214"><a href="#cb18-214"></a><span class="in">  dt.munchel.meta&lt;-data.table(</span></span>
<span id="cb18-215"><a href="#cb18-215"></a><span class="in">                            names=dt.foo[is.na(Geneid),-c("Geneid","Chr","Start","End","Strand","Length")] %&gt;% </span></span>
<span id="cb18-216"><a href="#cb18-216"></a><span class="in">                              colnames %&gt;% </span></span>
<span id="cb18-217"><a href="#cb18-217"></a><span class="in">                              stringr::str_replace("\\.\\.\\.",""),</span></span>
<span id="cb18-218"><a href="#cb18-218"></a><span class="in">                            GA=dt.foo[is.na(Geneid),-c("Geneid","Chr","Start","End","Strand","Length")] %&gt;% unlist </span></span>
<span id="cb18-219"><a href="#cb18-219"></a><span class="in">                            )</span></span>
<span id="cb18-220"><a href="#cb18-220"></a><span class="in">  dt.munchel.meta[,Condition:=ifelse(grepl("PE",names),"Case","Control")]</span></span>
<span id="cb18-221"><a href="#cb18-221"></a><span class="in">  dt.munchel.meta$GA %&gt;% summary</span></span>
<span id="cb18-222"><a href="#cb18-222"></a><span class="in">  dt.munchel.meta[,.N,Condition]</span></span>
<span id="cb18-223"><a href="#cb18-223"></a><span class="in">  dt.munchel.meta[Condition=="Control"]$GA %&gt;% summary</span></span>
<span id="cb18-224"><a href="#cb18-224"></a><span class="in">  dt.munchel.meta[Condition=="Case"]$GA %&gt;% summary</span></span>
<span id="cb18-225"><a href="#cb18-225"></a><span class="in">  df.munchel.meta&lt;-data.frame(dt.munchel.meta, row.names=dt.munchel.meta$names)</span></span>
<span id="cb18-226"><a href="#cb18-226"></a></span>
<span id="cb18-227"><a href="#cb18-227"></a><span class="in">  # cnt </span></span>
<span id="cb18-228"><a href="#cb18-228"></a><span class="in">  dt.munchel.cnt&lt;-dt.foo[!is.na(Geneid),-c("Chr","Start","End","Strand","Length")]</span></span>
<span id="cb18-229"><a href="#cb18-229"></a><span class="in">  dt.munchel.cnt %&gt;% dim # 26708 genes x 114 samples</span></span>
<span id="cb18-230"><a href="#cb18-230"></a><span class="in">  dt.munchel.cnt[1:5,1:5]</span></span>
<span id="cb18-231"><a href="#cb18-231"></a><span class="in">  colnames(dt.munchel.cnt)&lt;-c("gene_name",dt.munchel.meta$names) # update the sample names</span></span>
<span id="cb18-232"><a href="#cb18-232"></a><span class="in">  dt.munchel.cnt[1:5,1:5]</span></span>
<span id="cb18-233"><a href="#cb18-233"></a><span class="in">  dt.munchel.cnt[,.N,gene_name][N&gt;1][order(-N)] # 0 duplicated gene names </span></span>
<span id="cb18-234"><a href="#cb18-234"></a></span>
<span id="cb18-235"><a href="#cb18-235"></a><span class="in">  dt.munchel.cnt[grepl("_dup",gene_name)][,.N,gene_name] # 1355 such gene names</span></span>
<span id="cb18-236"><a href="#cb18-236"></a><span class="in">  dt.munchel.cnt[grepl("_dup",gene_name)][1:5,1:5]</span></span>
<span id="cb18-237"><a href="#cb18-237"></a></span>
<span id="cb18-238"><a href="#cb18-238"></a><span class="in">  dt.munchel.cnt[,gene_name:=tstrsplit(gene_name,"_dup",fixed=T,keep=1L)]</span></span>
<span id="cb18-239"><a href="#cb18-239"></a><span class="in">  dt.munchel.cnt[grepl("_dup",gene_name)]</span></span>
<span id="cb18-240"><a href="#cb18-240"></a><span class="in">  dt.munchel.cnt[,.N,gene_name][N&gt;1][order(-N)] # 491 duplicated gene names</span></span>
<span id="cb18-241"><a href="#cb18-241"></a><span class="in">  dt.munchel.cnt[gene_name=="REXO1L2P",1:5]</span></span>
<span id="cb18-242"><a href="#cb18-242"></a><span class="in">  dt.munchel.cnt[,.N,gene_name %in% rownames(dds.f2)] # genes only in the dds.f2 (15150 genes)</span></span>
<span id="cb18-243"><a href="#cb18-243"></a><span class="in">                                                      # TRUE 13555; FALSE 13153</span></span>
<span id="cb18-244"><a href="#cb18-244"></a><span class="in">  rownames(dds.f2) %in% dt.munchel.cnt$gene_name %&gt;% table # from 15150 genesin dds.f2, 13469 genes in Munchel; 1681 genes not in Munchel</span></span>
<span id="cb18-245"><a href="#cb18-245"></a><span class="in">  dds.f2[!rownames(dds.f2) %in% dt.munchel.cnt$gene_name] %&gt;% names</span></span>
<span id="cb18-246"><a href="#cb18-246"></a></span>
<span id="cb18-247"><a href="#cb18-247"></a><span class="in">  dt.munchel.cnt2&lt;- (dt.munchel.cnt[gene_name %in% rownames(dds.f2)] %&gt;% </span></span>
<span id="cb18-248"><a href="#cb18-248"></a><span class="in">                     melt.data.table(id.vars=c("gene_name"), variable.name="SampleID",value.name="Cnt"))[,.(Cnt=sum(Cnt)),.(SampleID,gene_name)] %&gt;% </span></span>
<span id="cb18-249"><a href="#cb18-249"></a><span class="in">                      dcast.data.table(gene_name ~ SampleID, value.var="Cnt")</span></span>
<span id="cb18-250"><a href="#cb18-250"></a><span class="in">  dim(dt.munchel.cnt2) # 13469 genes x 114 samples</span></span>
<span id="cb18-251"><a href="#cb18-251"></a><span class="in">  dt.munchel.cnt2[,.N,gene_name][N&gt;1][order(-N)] # no duplicated genes</span></span>
<span id="cb18-252"><a href="#cb18-252"></a><span class="in">  all.equal(colnames(dt.munchel.cnt),colnames(dt.munchel.cnt2))</span></span>
<span id="cb18-253"><a href="#cb18-253"></a></span>
<span id="cb18-254"><a href="#cb18-254"></a><span class="in">  mat.munchel.cnt2&lt;-dt.munchel.cnt2 %&gt;% as.matrix(rownames="gene_name")</span></span>
<span id="cb18-255"><a href="#cb18-255"></a><span class="in">  dim(mat.munchel.cnt2) # 13469 x 113</span></span>
<span id="cb18-256"><a href="#cb18-256"></a><span class="in">  mat.munchel.cnt2[1:5,1:5]</span></span>
<span id="cb18-257"><a href="#cb18-257"></a></span>
<span id="cb18-258"><a href="#cb18-258"></a><span class="in">  all.equal(colnames(mat.munchel.cnt2), rownames(df.munchel.meta))</span></span>
<span id="cb18-259"><a href="#cb18-259"></a></span>
<span id="cb18-260"><a href="#cb18-260"></a><span class="in">  dds.munchel&lt;-DESeqDataSetFromMatrix(mat.munchel.cnt2, df.munchel.meta, design=formula(~Condition) )</span></span>
<span id="cb18-261"><a href="#cb18-261"></a></span>
<span id="cb18-262"><a href="#cb18-262"></a><span class="in">  dds.munchel&lt;- DESeq(dds.munchel, parallel=TRUE) # isa 'DESeqDataSet'</span></span>
<span id="cb18-263"><a href="#cb18-263"></a><span class="in">  save(dt.munchel.meta,dds.munchel,file=my.dds.RData)</span></span>
<span id="cb18-264"><a href="#cb18-264"></a><span class="in">}</span></span>
<span id="cb18-265"><a href="#cb18-265"></a><span class="in">```</span></span>
<span id="cb18-266"><a href="#cb18-266"></a></span>
<span id="cb18-267"><a href="#cb18-267"></a>Using the filtered gene-level raw count matrix, we ran edgeR and constructed a matrix of CPM, in log2-scale, via the “cpm” function of edgeR. The matrix was further transformed into a matrix of the z-score using the mean and standard deviation of logCPM from the 73 control samples.</span>
<span id="cb18-268"><a href="#cb18-268"></a></span>
<span id="cb18-269"><a href="#cb18-269"></a><span class="in">```{r munchel-init-edger}</span></span>
<span id="cb18-270"><a href="#cb18-270"></a><span class="in">#| label: munchel-init-edger</span></span>
<span id="cb18-271"><a href="#cb18-271"></a><span class="in">#| eval: false</span></span>
<span id="cb18-272"><a href="#cb18-272"></a><span class="in">#| code-summary: Code to make the z-score matrix from the Munchel dataset </span></span>
<span id="cb18-273"><a href="#cb18-273"></a><span class="in">my.cpmZ.RData&lt;-paste0("RData/dt.cpmZ.munchel.RData")</span></span>
<span id="cb18-274"><a href="#cb18-274"></a><span class="in">if(file.exists(my.cpmZ.RData)){</span></span>
<span id="cb18-275"><a href="#cb18-275"></a><span class="in">  load(my.cpmZ.RData)</span></span>
<span id="cb18-276"><a href="#cb18-276"></a><span class="in">}else{</span></span>
<span id="cb18-277"><a href="#cb18-277"></a><span class="in">  load("RData/dds.munchel.RData")</span></span>
<span id="cb18-278"><a href="#cb18-278"></a><span class="in">  dds.munchel # samples from Discovery &amp; Validation1</span></span>
<span id="cb18-279"><a href="#cb18-279"></a></span>
<span id="cb18-280"><a href="#cb18-280"></a><span class="in">  d.munchel = DEFormats::as.DGEList(dds.munchel)</span></span>
<span id="cb18-281"><a href="#cb18-281"></a><span class="in">  d.munchel&lt;-calcNormFactors(d.munchel,method="TMM") </span></span>
<span id="cb18-282"><a href="#cb18-282"></a></span>
<span id="cb18-283"><a href="#cb18-283"></a><span class="in">  dt.logcpm2&lt;-merge(</span></span>
<span id="cb18-284"><a href="#cb18-284"></a><span class="in">      data.table(`geneName`=rownames(d.munchel),cpm(d.munchel,log=T)) %&gt;% </span></span>
<span id="cb18-285"><a href="#cb18-285"></a><span class="in">        melt.data.table(id.vars=c("geneName"),variable.name="SampleID",value.name="logCPM"),</span></span>
<span id="cb18-286"><a href="#cb18-286"></a><span class="in">      df.munchel.meta,by.x="SampleID",by.y="names"</span></span>
<span id="cb18-287"><a href="#cb18-287"></a><span class="in">      )</span></span>
<span id="cb18-288"><a href="#cb18-288"></a></span>
<span id="cb18-289"><a href="#cb18-289"></a><span class="in">  dt.cpmZ.munchel=merge(dt.logcpm2,</span></span>
<span id="cb18-290"><a href="#cb18-290"></a><span class="in">                dt.logcpm2[Condition=="Control",.(Mean=mean(logCPM),SD=sd(logCPM)),.(geneName)]</span></span>
<span id="cb18-291"><a href="#cb18-291"></a><span class="in">        ,by=c("geneName")</span></span>
<span id="cb18-292"><a href="#cb18-292"></a><span class="in">        )[,.(Condition,SampleID,geneName,logCPM,logCPMZ=(logCPM-Mean)/SD)]</span></span>
<span id="cb18-293"><a href="#cb18-293"></a><span class="in">  save(dt.cpmZ.munchel,file=my.cpmZ.RData)</span></span>
<span id="cb18-294"><a href="#cb18-294"></a><span class="in">}</span></span>
<span id="cb18-295"><a href="#cb18-295"></a><span class="in">```</span></span>
<span id="cb18-296"><a href="#cb18-296"></a></span>
<span id="cb18-297"><a href="#cb18-297"></a><span class="fu">## Data split for 5-fold CV {#sec-cv-split}</span></span>
<span id="cb18-298"><a href="#cb18-298"></a>We randomly split the samples into 5 strata by distributing the number of case and control outcomes as even as possible across the 5 folds. This stratified 5-fold splitting was repeated 5 times by changing a seed number in each repetition, and the 11 ML models (see below #sec-cv-11ML) were trained to choose a desired number of predictors from 2 to 6. </span>
<span id="cb18-299"><a href="#cb18-299"></a></span>
<span id="cb18-300"><a href="#cb18-300"></a><span class="in">```{r split-data-cv}</span></span>
<span id="cb18-301"><a href="#cb18-301"></a><span class="in">#| label: split-data-cv</span></span>
<span id="cb18-302"><a href="#cb18-302"></a><span class="in">#| eval: false</span></span>
<span id="cb18-303"><a href="#cb18-303"></a><span class="in">#| code-summary: Code to split 5-fold with 5 repetitions</span></span>
<span id="cb18-304"><a href="#cb18-304"></a><span class="in">load("RData/dt.cpmZ.preterm.POPS-2022.GRCh38.88.RData") # dt.cpmZ (preterm)</span></span>
<span id="cb18-305"><a href="#cb18-305"></a><span class="in">load("RData/dt.cpmZ.term.POPS-2022.GRCh38.88.RData") # dt.cpmZ.term (term)</span></span>
<span id="cb18-306"><a href="#cb18-306"></a><span class="in">load("RData/dt.cpmZ.munchel.RData") # dt.cpmZ.munchel (Munchel)</span></span>
<span id="cb18-307"><a href="#cb18-307"></a></span>
<span id="cb18-308"><a href="#cb18-308"></a><span class="in">li.mat&lt;-list()</span></span>
<span id="cb18-309"><a href="#cb18-309"></a><span class="in"># set the train dataset, i.e. preterm-28wk</span></span>
<span id="cb18-310"><a href="#cb18-310"></a><span class="in">li.mat[["train"]]&lt;-lapply(list(`12wk`="12wk",`20wk`="20wk",`28wk`="28wk"), function(my.GA) {</span></span>
<span id="cb18-311"><a href="#cb18-311"></a><span class="in">  dt.cpmZ[GA==my.GA &amp; geneName %in% core17,.(SampleID,geneName,logCPMZ,y=ifelse(Condition=="Case",1,0))] %&gt;% dcast.data.table(SampleID+y~geneName,value.var="logCPMZ") %&gt;% as.matrix(rownames="SampleID") # isa 'list'</span></span>
<span id="cb18-312"><a href="#cb18-312"></a><span class="in">  })</span></span>
<span id="cb18-313"><a href="#cb18-313"></a></span>
<span id="cb18-314"><a href="#cb18-314"></a><span class="in"># set the test dataset, i.e. term</span></span>
<span id="cb18-315"><a href="#cb18-315"></a><span class="in">li.mat[["test"]]&lt;-lapply(list(`12wk`="12wk",`20wk`="20wk",`28wk`="28wk",`36wk`="36wk"), function(my.GA) {</span></span>
<span id="cb18-316"><a href="#cb18-316"></a><span class="in">    dt.cpmZ.term[GA==my.GA &amp; geneName %in% core17,.(SampleID,geneName,logCPMZ,y=ifelse(Condition=="Case",1,0))] %&gt;% dcast.data.table(SampleID+y~geneName,value.var="logCPMZ") %&gt;% as.matrix(rownames="SampleID") # isa 'list'</span></span>
<span id="cb18-317"><a href="#cb18-317"></a><span class="in">  })</span></span>
<span id="cb18-318"><a href="#cb18-318"></a></span>
<span id="cb18-319"><a href="#cb18-319"></a><span class="in">li.mat[["munchel"]]&lt;-dt.cpmZ.munchel[geneName %in% core17,.(SampleID,geneName,logCPMZ,y=ifelse(Condition=="Case",1,0))] %&gt;% dcast.data.table(SampleID+y~geneName,value.var="logCPMZ") %&gt;% as.matrix(rownames="SampleID") # isa 'matrix'</span></span>
<span id="cb18-320"><a href="#cb18-320"></a></span>
<span id="cb18-321"><a href="#cb18-321"></a><span class="in">##############################################</span></span>
<span id="cb18-322"><a href="#cb18-322"></a><span class="in"># Set the 5-fold with 5 rep for 28wk preterm #</span></span>
<span id="cb18-323"><a href="#cb18-323"></a><span class="in">##############################################</span></span>
<span id="cb18-324"><a href="#cb18-324"></a><span class="in"># set stratified folds</span></span>
<span id="cb18-325"><a href="#cb18-325"></a><span class="in"># such that the numbers of cases and controls in each fold are the same for each fold (or, at least, as close to this as possible)</span></span>
<span id="cb18-326"><a href="#cb18-326"></a><span class="in">nFold&lt;-5; nRep&lt;-5; li.fold&lt;-list() # index of training in </span></span>
<span id="cb18-327"><a href="#cb18-327"></a><span class="in">for(iRep in 1:nRep){</span></span>
<span id="cb18-328"><a href="#cb18-328"></a><span class="in">  caseInds &lt;- which(li.mat[["train"]][["28wk"]][,"y"]==1)</span></span>
<span id="cb18-329"><a href="#cb18-329"></a><span class="in">  ctrlInds &lt;- which(li.mat[["train"]][["28wk"]][,"y"]==0)</span></span>
<span id="cb18-330"><a href="#cb18-330"></a></span>
<span id="cb18-331"><a href="#cb18-331"></a><span class="in">  #Randomise for good measure:</span></span>
<span id="cb18-332"><a href="#cb18-332"></a><span class="in">  set.seed(123+iRep)</span></span>
<span id="cb18-333"><a href="#cb18-333"></a><span class="in">  caseInds &lt;- caseInds[sample(1:length(caseInds))]</span></span>
<span id="cb18-334"><a href="#cb18-334"></a><span class="in">  ctrlInds &lt;- ctrlInds[sample(1:length(ctrlInds))]</span></span>
<span id="cb18-335"><a href="#cb18-335"></a></span>
<span id="cb18-336"><a href="#cb18-336"></a><span class="in">  approximatelyEqualParts_Cases &lt;- ggplot2::cut_interval(1:length(caseInds), nFold)</span></span>
<span id="cb18-337"><a href="#cb18-337"></a><span class="in">  approximatelyEqualParts_Ctrls &lt;- ggplot2::cut_interval(1:length(ctrlInds), nFold)</span></span>
<span id="cb18-338"><a href="#cb18-338"></a></span>
<span id="cb18-339"><a href="#cb18-339"></a><span class="in">  quintiles_Cases &lt;- vector(mode = "integer", length = length(caseInds))</span></span>
<span id="cb18-340"><a href="#cb18-340"></a><span class="in">  quintiles_Ctrls &lt;- vector(mode = "integer", length = length(ctrlInds))</span></span>
<span id="cb18-341"><a href="#cb18-341"></a><span class="in">  for(i in 1:length(levels(approximatelyEqualParts_Cases))){</span></span>
<span id="cb18-342"><a href="#cb18-342"></a><span class="in">    currentLevel &lt;- levels(approximatelyEqualParts_Cases)[i]</span></span>
<span id="cb18-343"><a href="#cb18-343"></a><span class="in">    quintiles_Cases[approximatelyEqualParts_Cases == currentLevel] &lt;- i</span></span>
<span id="cb18-344"><a href="#cb18-344"></a><span class="in">  }</span></span>
<span id="cb18-345"><a href="#cb18-345"></a></span>
<span id="cb18-346"><a href="#cb18-346"></a><span class="in">  for(i in 1:length(levels(approximatelyEqualParts_Ctrls))){</span></span>
<span id="cb18-347"><a href="#cb18-347"></a><span class="in">    currentLevel &lt;- levels(approximatelyEqualParts_Ctrls)[i]</span></span>
<span id="cb18-348"><a href="#cb18-348"></a><span class="in">    quintiles_Ctrls[approximatelyEqualParts_Ctrls == currentLevel] &lt;- i</span></span>
<span id="cb18-349"><a href="#cb18-349"></a><span class="in">  }</span></span>
<span id="cb18-350"><a href="#cb18-350"></a></span>
<span id="cb18-351"><a href="#cb18-351"></a><span class="in">  quintiles &lt;- vector(mode = "integer", length = nrow(li.mat[["train"]][["28wk"]]))</span></span>
<span id="cb18-352"><a href="#cb18-352"></a><span class="in">  for(i in 1:nFold){</span></span>
<span id="cb18-353"><a href="#cb18-353"></a><span class="in">    quintiles[c(caseInds[quintiles_Cases == i], ctrlInds[quintiles_Ctrls == i])] &lt;- i</span></span>
<span id="cb18-354"><a href="#cb18-354"></a><span class="in">  }</span></span>
<span id="cb18-355"><a href="#cb18-355"></a></span>
<span id="cb18-356"><a href="#cb18-356"></a><span class="in">    # Split the data into training and testing sets for this fold</span></span>
<span id="cb18-357"><a href="#cb18-357"></a><span class="in">  for(iFold in 1:nFold){</span></span>
<span id="cb18-358"><a href="#cb18-358"></a><span class="in">    li.fold[[paste0("Fold",iFold,".Rep",iRep)]]&lt;-which(quintiles != iFold)</span></span>
<span id="cb18-359"><a href="#cb18-359"></a><span class="in">  }</span></span>
<span id="cb18-360"><a href="#cb18-360"></a><span class="in">} # end of iRep</span></span>
<span id="cb18-361"><a href="#cb18-361"></a></span>
<span id="cb18-362"><a href="#cb18-362"></a><span class="in">########################################</span></span>
<span id="cb18-363"><a href="#cb18-363"></a><span class="in"># Set the final 5-fold to use all_28wk #</span></span>
<span id="cb18-364"><a href="#cb18-364"></a><span class="in">########################################</span></span>
<span id="cb18-365"><a href="#cb18-365"></a><span class="in">nFold&lt;-5; nRep&lt;-1; li.fold.final&lt;-list() # index of training in </span></span>
<span id="cb18-366"><a href="#cb18-366"></a><span class="in">for(iRep in 1:nRep){</span></span>
<span id="cb18-367"><a href="#cb18-367"></a><span class="in">  caseInds &lt;- which(li.mat[["train"]][["28wk"]][,"y"]==1)</span></span>
<span id="cb18-368"><a href="#cb18-368"></a><span class="in">  ctrlInds &lt;- which(li.mat[["train"]][["28wk"]][,"y"]==0)</span></span>
<span id="cb18-369"><a href="#cb18-369"></a></span>
<span id="cb18-370"><a href="#cb18-370"></a><span class="in">  #Randomise for good measure:</span></span>
<span id="cb18-371"><a href="#cb18-371"></a><span class="in">  set.seed(333)</span></span>
<span id="cb18-372"><a href="#cb18-372"></a><span class="in">  caseInds &lt;- caseInds[sample(1:length(caseInds))]</span></span>
<span id="cb18-373"><a href="#cb18-373"></a><span class="in">  ctrlInds &lt;- ctrlInds[sample(1:length(ctrlInds))]</span></span>
<span id="cb18-374"><a href="#cb18-374"></a></span>
<span id="cb18-375"><a href="#cb18-375"></a><span class="in">  approximatelyEqualParts_Cases &lt;- ggplot2::cut_interval(1:length(caseInds), nFold)</span></span>
<span id="cb18-376"><a href="#cb18-376"></a><span class="in">  approximatelyEqualParts_Ctrls &lt;- ggplot2::cut_interval(1:length(ctrlInds), nFold)</span></span>
<span id="cb18-377"><a href="#cb18-377"></a></span>
<span id="cb18-378"><a href="#cb18-378"></a><span class="in">  quintiles_Cases &lt;- vector(mode = "integer", length = length(caseInds))</span></span>
<span id="cb18-379"><a href="#cb18-379"></a><span class="in">  quintiles_Ctrls &lt;- vector(mode = "integer", length = length(ctrlInds))</span></span>
<span id="cb18-380"><a href="#cb18-380"></a><span class="in">  for(i in 1:length(levels(approximatelyEqualParts_Cases))){</span></span>
<span id="cb18-381"><a href="#cb18-381"></a><span class="in">    currentLevel &lt;- levels(approximatelyEqualParts_Cases)[i]</span></span>
<span id="cb18-382"><a href="#cb18-382"></a><span class="in">    quintiles_Cases[approximatelyEqualParts_Cases == currentLevel] &lt;- i</span></span>
<span id="cb18-383"><a href="#cb18-383"></a><span class="in">  }</span></span>
<span id="cb18-384"><a href="#cb18-384"></a></span>
<span id="cb18-385"><a href="#cb18-385"></a><span class="in">  for(i in 1:length(levels(approximatelyEqualParts_Ctrls))){</span></span>
<span id="cb18-386"><a href="#cb18-386"></a><span class="in">    currentLevel &lt;- levels(approximatelyEqualParts_Ctrls)[i]</span></span>
<span id="cb18-387"><a href="#cb18-387"></a><span class="in">    quintiles_Ctrls[approximatelyEqualParts_Ctrls == currentLevel] &lt;- i</span></span>
<span id="cb18-388"><a href="#cb18-388"></a><span class="in">  }</span></span>
<span id="cb18-389"><a href="#cb18-389"></a></span>
<span id="cb18-390"><a href="#cb18-390"></a><span class="in">  quintiles &lt;- vector(mode = "integer", length = nrow(li.mat[["train"]][["28wk"]]))</span></span>
<span id="cb18-391"><a href="#cb18-391"></a><span class="in">  for(i in 1:nFold){</span></span>
<span id="cb18-392"><a href="#cb18-392"></a><span class="in">    quintiles[c(caseInds[quintiles_Cases == i], ctrlInds[quintiles_Ctrls == i])] &lt;- i</span></span>
<span id="cb18-393"><a href="#cb18-393"></a><span class="in">  }</span></span>
<span id="cb18-394"><a href="#cb18-394"></a></span>
<span id="cb18-395"><a href="#cb18-395"></a><span class="in">    # Split the data into training and testing sets for this fold</span></span>
<span id="cb18-396"><a href="#cb18-396"></a><span class="in">  for(iFold in 1:nFold){</span></span>
<span id="cb18-397"><a href="#cb18-397"></a><span class="in">    li.fold.final[[paste0("Fold",iFold,".Rep",iRep)]]&lt;-which(quintiles != iFold)</span></span>
<span id="cb18-398"><a href="#cb18-398"></a><span class="in">  }</span></span>
<span id="cb18-399"><a href="#cb18-399"></a><span class="in">} # end of iRep</span></span>
<span id="cb18-400"><a href="#cb18-400"></a><span class="in">```</span></span>
<span id="cb18-401"><a href="#cb18-401"></a></span>
<span id="cb18-402"><a href="#cb18-402"></a><span class="fu">## 11 machine learning methods {#sec-cv-11ML}</span></span>
<span id="cb18-403"><a href="#cb18-403"></a>We considered a total of 11 ML methods to select the best performing method based on the 5-fold cross-validation (CV) with 5 repetitions. </span>
<span id="cb18-404"><a href="#cb18-404"></a></span>
<span id="cb18-405"><a href="#cb18-405"></a><span class="al">![11 machine-learning methods considered in this study](static/figure/cfRNA.11ML.png)</span>{#fig-11ML}</span>
<span id="cb18-406"><a href="#cb18-406"></a></span>
<span id="cb18-407"><a href="#cb18-407"></a>For the three penalised regression methods (ENet1, ENet2 and LASSO), they were firstly fitted by using the <span class="co">[</span><span class="ot">train</span><span class="co">](https://topepo.github.io/caret/model-training-and-tuning.html)</span> function for the two Elastic net methods (ENet1 and ENet2) and the <span class="co">[</span><span class="ot">cv.glmnet</span><span class="co">](https://glmnet.stanford.edu/reference/cv.glmnet.html)</span> function for LASSO, from <span class="co">[</span><span class="ot">the caret</span><span class="co">](https://topepo.github.io/caret/)</span> (v6.0.94) and <span class="co">[</span><span class="ot">the glmnet</span><span class="co">](https://glmnet.stanford.edu/)</span> (v.4.1.2) R package, respectively. For ENet1, both the parameter $\alpha$ and $\lambda$ were tuned by the <span class="in">`caret::train`</span>, whereas the parameter $\lambda$ was further tuned by the <span class="in">`glmnet::cv.glmnet`</span> for ENet2. </span>
<span id="cb18-408"><a href="#cb18-408"></a></span>
<span id="cb18-409"><a href="#cb18-409"></a>Next, based on the best fitted penalised regression models, a matrix of the $\beta$ coefficient was examined to find the first set of predictors with non-zero $\beta$ coefficients that satisfied a desired number of predictors. If the number of predictors with non-zero coefficients exceeded the desired number, the absolute values of coefficients were sorted in their decreasing order and only the desired number of predictors were selected with their highest absolute scores. </span>
<span id="cb18-410"><a href="#cb18-410"></a></span>
<span id="cb18-411"><a href="#cb18-411"></a>For the remaining methods, except <span class="co">[</span><span class="ot">mSVM-RFE</span><span class="co">](https://github.com/johncolby/SVM-RFE)</span> (see also @sec-cv-svm-rfe) which embedded a Recursive Feature Elimination (RFE) algorithm internally, we used the <span class="co">[</span><span class="ot">`caret::rfe`</span><span class="co">](https://topepo.github.io/caret/recursive-feature-elimination.html#recursive-feature-elimination-via-caret)</span> function by controlling the “sizes” parameter to have the corresponding models with the desired number of predictors. </span>
<span id="cb18-412"><a href="#cb18-412"></a></span>
<span id="cb18-413"><a href="#cb18-413"></a><span class="fu">### `glParallel` {#sec-cv-glParallel}</span></span>
<span id="cb18-414"><a href="#cb18-414"></a>In <span class="co">[</span><span class="ot">glParallel</span><span class="co">](https://gitlab.developers.cam.ac.uk/ssg29/glparallel)</span>, a brute-force exhaustive search method, for a given number of predictors, it searched all possible combinations of predictors in multivariate regression models and picked the best model based on the highest predictive performance. </span>
<span id="cb18-415"><a href="#cb18-415"></a></span>
<span id="cb18-416"><a href="#cb18-416"></a>For example, glParallel trained a total of 2,380 models, which is the possible number of combinations having 4 predictors out of 17, and chose the best model based on the highest <span class="co">[</span><span class="ot">Leave Pair Out Cross Validated (LPOCV)</span><span class="co">](https://pubmed.ncbi.nlm.nih.gov/24966219/)</span> Area Under the ROC Curve (AUC), a version of optimism-corrected AUC. </span>
<span id="cb18-417"><a href="#cb18-417"></a></span>
<span id="cb18-418"><a href="#cb18-418"></a>::: {.callout-note title="Install <span class="in">`glParallel`</span>"}</span>
<span id="cb18-419"><a href="#cb18-419"></a>You need to download and install <span class="in">`glParallel`</span> locally via the following <span class="in">`git`</span> command:</span>
<span id="cb18-420"><a href="#cb18-420"></a></span>
<span id="cb18-421"><a href="#cb18-421"></a>``<span class="in">`{#lst-clone-glParallel .bash lst-cap="Code to download `</span>glParallel`"}</span>
<span id="cb18-422"><a href="#cb18-422"></a>git clone https://gitlab.developers.cam.ac.uk/ssg29/glparallel.git static/R/glParallel</span>
<span id="cb18-423"><a href="#cb18-423"></a><span class="in">```</span></span>
<span id="cb18-424"><a href="#cb18-424"></a><span class="in">:::</span></span>
<span id="cb18-425"><a href="#cb18-425"></a></span>
<span id="cb18-426"><a href="#cb18-426"></a><span class="in">Then, prepare dataset to run `glParallel`.</span></span>
<span id="cb18-427"><a href="#cb18-427"></a><span class="in">```{r prep-glParallel-data}</span></span>
<span id="cb18-428"><a href="#cb18-428"></a><span class="in">#| label: prep-glParallel-data</span></span>
<span id="cb18-429"><a href="#cb18-429"></a><span class="in">#| eval: false</span></span>
<span id="cb18-430"><a href="#cb18-430"></a><span class="in">#| code-summary: Code to prepare dataset for `glParallel`</span></span>
<span id="cb18-431"><a href="#cb18-431"></a><span class="in">#####################################################</span></span>
<span id="cb18-432"><a href="#cb18-432"></a><span class="in"># make training dataset files for the CV glParallel #</span></span>
<span id="cb18-433"><a href="#cb18-433"></a><span class="in">#####################################################</span></span>
<span id="cb18-434"><a href="#cb18-434"></a><span class="in">lapply(names(li.fold), function(i){</span></span>
<span id="cb18-435"><a href="#cb18-435"></a><span class="in">  message("fold=",i)</span></span>
<span id="cb18-436"><a href="#cb18-436"></a><span class="in">  # training set</span></span>
<span id="cb18-437"><a href="#cb18-437"></a><span class="in">  my.index=li.fold[[i]]</span></span>
<span id="cb18-438"><a href="#cb18-438"></a><span class="in">  my.file.name=file.path("glParallel/data",paste("core17",i,"csv",sep="."))</span></span>
<span id="cb18-439"><a href="#cb18-439"></a><span class="in">  fwrite(li.mat[["train"]][["28wk"]][my.index,], file=my.file.name)</span></span>
<span id="cb18-440"><a href="#cb18-440"></a><span class="in">})</span></span>
<span id="cb18-441"><a href="#cb18-441"></a><span class="in"># then run glParallel (see glParallel/RUN)</span></span>
<span id="cb18-442"><a href="#cb18-442"></a></span>
<span id="cb18-443"><a href="#cb18-443"></a><span class="in">####################################################</span></span>
<span id="cb18-444"><a href="#cb18-444"></a><span class="in"># make training dataset files for final glParallel #</span></span>
<span id="cb18-445"><a href="#cb18-445"></a><span class="in">####################################################</span></span>
<span id="cb18-446"><a href="#cb18-446"></a><span class="in">fwrite(li.mat[["train"]][["28wk"]], file="glParallel/data/core17.final.csv")</span></span>
<span id="cb18-447"><a href="#cb18-447"></a><span class="in">```</span></span>
<span id="cb18-448"><a href="#cb18-448"></a></span>
<span id="cb18-449"><a href="#cb18-449"></a>::: {.callout-note title="LPOCV-AUC"}</span>
<span id="cb18-450"><a href="#cb18-450"></a>In LPOCV-AUC, a model was fitted based on a given set of training samples except one pair of case-and-control, then the model was used to predict the outcome of the remaining pair. The LPOCV-AUC was calculated as the proportion of all pairwise combinations in which the predicted probability was greater for the case than for the control. </span>
<span id="cb18-451"><a href="#cb18-451"></a>There is a helper function to calculate the LPOCV-AUC in <span class="co">[</span><span class="ot">`glParallel`</span><span class="co">](https://gitlab.developers.cam.ac.uk/ssg29/glparallel/-/blob/main/lib/local.R?ref_type=heads#L68)</span></span>
<span id="cb18-452"><a href="#cb18-452"></a>:::</span>
<span id="cb18-453"><a href="#cb18-453"></a></span>
<span id="cb18-454"><a href="#cb18-454"></a><span class="fu">### `mSVM-RFE` {#sec-cv-svm-rfe}</span></span>
<span id="cb18-455"><a href="#cb18-455"></a>This method is from the (multiple) Support Vector Machine Recursive Feature Elimination <span class="co">[</span><span class="ot">(mSVM-RFE)</span><span class="co">](https://github.com/johncolby/SVM-RFE)</span>.</span>
<span id="cb18-456"><a href="#cb18-456"></a></span>
<span id="cb18-457"><a href="#cb18-457"></a>::: {.callout-note title="Install <span class="in">`SVM-RFE`</span>"}</span>
<span id="cb18-458"><a href="#cb18-458"></a>You need to download nad install <span class="in">`SVM-RFE`</span> locally via the following <span class="in">`git`</span> command:</span>
<span id="cb18-459"><a href="#cb18-459"></a></span>
<span id="cb18-460"><a href="#cb18-460"></a>``<span class="in">`{#lst-clone-svm-rfe .bash lst-cap="Code to download `</span>SVM-RFE`"}</span>
<span id="cb18-461"><a href="#cb18-461"></a>git clone https://github.com/johncolby/SVM-RFE.git static/R/SVM-RFE</span>
<span id="cb18-462"><a href="#cb18-462"></a><span class="in">```</span></span>
<span id="cb18-463"><a href="#cb18-463"></a><span class="in">:::</span></span>
<span id="cb18-464"><a href="#cb18-464"></a></span>
<span id="cb18-465"><a href="#cb18-465"></a><span class="in">## 5-Fold cross validation {#sec-5fold-cv}</span></span>
<span id="cb18-466"><a href="#cb18-466"></a></span>
<span id="cb18-467"><a href="#cb18-467"></a><span class="in">We defined a series of helper functions to facilitate the whole process of CV more efficient.</span></span>
<span id="cb18-468"><a href="#cb18-468"></a></span>
<span id="cb18-469"><a href="#cb18-469"></a><span class="in">::: {.callout-tip title="`R` function `get_lasso_coef`"}</span></span>
<span id="cb18-470"><a href="#cb18-470"></a><span class="in">This helper function runs [LASSO](https://en.wikipedia.org/wiki/Lasso_(statistics)) and ranks features by their importance.</span></span>
<span id="cb18-471"><a href="#cb18-471"></a><span class="in">```{r def-fun1}</span></span>
<span id="cb18-472"><a href="#cb18-472"></a><span class="in">#| label: def-lasso</span></span>
<span id="cb18-473"><a href="#cb18-473"></a><span class="in">#| eval: false</span></span>
<span id="cb18-474"><a href="#cb18-474"></a><span class="in">#| code-summary: Code to run Lasso and get non-zero coefficient</span></span>
<span id="cb18-475"><a href="#cb18-475"></a><span class="in"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb18-476"><a href="#cb18-476"></a><span class="in">get_lasso_coef&lt;-function(x,my.fold,my.num=4){</span></span>
<span id="cb18-477"><a href="#cb18-477"></a><span class="in">  #x isa `matrix` and should contain 'y' column</span></span>
<span id="cb18-478"><a href="#cb18-478"></a><span class="in">  all.features&lt;-colnames(x)[colnames(x)!="y"]</span></span>
<span id="cb18-479"><a href="#cb18-479"></a></span>
<span id="cb18-480"><a href="#cb18-480"></a><span class="in">  #############</span></span>
<span id="cb18-481"><a href="#cb18-481"></a><span class="in">  # run Lasso #</span></span>
<span id="cb18-482"><a href="#cb18-482"></a><span class="in">  #############</span></span>
<span id="cb18-483"><a href="#cb18-483"></a><span class="in">  set.seed(333) # set a random seed for a reproducibility</span></span>
<span id="cb18-484"><a href="#cb18-484"></a><span class="in">  system.time(</span></span>
<span id="cb18-485"><a href="#cb18-485"></a><span class="in">      cv.fit&lt;-cv.glmnet(</span></span>
<span id="cb18-486"><a href="#cb18-486"></a><span class="in">                  x= x[,all.features], </span></span>
<span id="cb18-487"><a href="#cb18-487"></a><span class="in">                  y= x[,'y'], </span></span>
<span id="cb18-488"><a href="#cb18-488"></a><span class="in">                  family="binomial",</span></span>
<span id="cb18-489"><a href="#cb18-489"></a><span class="in">                  alpha=1, # default (i.e. lasso)</span></span>
<span id="cb18-490"><a href="#cb18-490"></a><span class="in">                  keep=T, # FALSE by default</span></span>
<span id="cb18-491"><a href="#cb18-491"></a><span class="in">                  type.measure = "auc" #type.measure="class" # default for 'binomial'</span></span>
<span id="cb18-492"><a href="#cb18-492"></a><span class="in">      )</span></span>
<span id="cb18-493"><a href="#cb18-493"></a><span class="in">  )</span></span>
<span id="cb18-494"><a href="#cb18-494"></a></span>
<span id="cb18-495"><a href="#cb18-495"></a><span class="in">  ############################################</span></span>
<span id="cb18-496"><a href="#cb18-496"></a><span class="in">  # 1. select by lambda.min  &amp; 2. lambda.1se #</span></span>
<span id="cb18-497"><a href="#cb18-497"></a><span class="in">  ############################################</span></span>
<span id="cb18-498"><a href="#cb18-498"></a><span class="in">  dt.foo&lt;-lapply(c("lambda.min","lambda.1se"), function(my.lambda){</span></span>
<span id="cb18-499"><a href="#cb18-499"></a><span class="in">    coeff1&lt;-coef(cv.fit, s = my.lambda) %&gt;% as.matrix #Extract coefficients from this glmnet object</span></span>
<span id="cb18-500"><a href="#cb18-500"></a><span class="in">    nZero1&lt;-coeff1[coeff1[,"s1"]!=0,,drop=F][-1,,drop=F] %&gt;% nrow # the number of non-zero coeff</span></span>
<span id="cb18-501"><a href="#cb18-501"></a><span class="in">    if(nZero1==0){</span></span>
<span id="cb18-502"><a href="#cb18-502"></a><span class="in">      dt.foo&lt;-data.table(</span></span>
<span id="cb18-503"><a href="#cb18-503"></a><span class="in">                        method=my.lambda,</span></span>
<span id="cb18-504"><a href="#cb18-504"></a><span class="in">                        fold=my.fold,</span></span>
<span id="cb18-505"><a href="#cb18-505"></a><span class="in">                        `feature`=NA,</span></span>
<span id="cb18-506"><a href="#cb18-506"></a><span class="in">                        score=NA)</span></span>
<span id="cb18-507"><a href="#cb18-507"></a><span class="in">    }else{</span></span>
<span id="cb18-508"><a href="#cb18-508"></a><span class="in">      coeff1[coeff1[,"s1"]!=0,,drop=F][-1,,drop=F] </span></span>
<span id="cb18-509"><a href="#cb18-509"></a><span class="in">      coeff1[coeff1[,"s1"]!=0,,drop=F][-1,,drop=F] %&gt;% as.data.table(keep.rownames=T) # return DT(rn,s1)</span></span>
<span id="cb18-510"><a href="#cb18-510"></a><span class="in">      dt.foo&lt;-data.table(</span></span>
<span id="cb18-511"><a href="#cb18-511"></a><span class="in">                        method=my.lambda,</span></span>
<span id="cb18-512"><a href="#cb18-512"></a><span class="in">                        fold=my.fold,</span></span>
<span id="cb18-513"><a href="#cb18-513"></a><span class="in">                        coeff1[coeff1[,"s1"]!=0,,drop=F][-1,,drop=F] %&gt;% as.data.table(keep.rownames=T))</span></span>
<span id="cb18-514"><a href="#cb18-514"></a><span class="in">    }</span></span>
<span id="cb18-515"><a href="#cb18-515"></a><span class="in">    setnames(dt.foo,c("method","fold","feature","score"))</span></span>
<span id="cb18-516"><a href="#cb18-516"></a><span class="in">    dt.foo</span></span>
<span id="cb18-517"><a href="#cb18-517"></a><span class="in">  }) %&gt;% rbindlist</span></span>
<span id="cb18-518"><a href="#cb18-518"></a></span>
<span id="cb18-519"><a href="#cb18-519"></a><span class="in">  ####################</span></span>
<span id="cb18-520"><a href="#cb18-520"></a><span class="in">  # 3. Lasso-pathway #</span></span>
<span id="cb18-521"><a href="#cb18-521"></a><span class="in">  ####################</span></span>
<span id="cb18-522"><a href="#cb18-522"></a><span class="in">  mat.beta &lt;- cv.fit$glmnet.fit$beta %&gt;% as.matrix</span></span>
<span id="cb18-523"><a href="#cb18-523"></a><span class="in">  apply(mat.beta, 2, function(i){table(i!=0)["TRUE"]})</span></span>
<span id="cb18-524"><a href="#cb18-524"></a><span class="in">  my.lambdas&lt;-apply(mat.beta, 2, function(i){table(i!=0)["TRUE"]})&gt;=my.num</span></span>
<span id="cb18-525"><a href="#cb18-525"></a><span class="in">  this.index&lt;-my.lambdas[my.lambdas &amp; !is.na(my.lambdas)][1] %&gt;% names # the first index &gt;=my.num</span></span>
<span id="cb18-526"><a href="#cb18-526"></a><span class="in">  if(is.na(this.index)){</span></span>
<span id="cb18-527"><a href="#cb18-527"></a><span class="in">    NULL</span></span>
<span id="cb18-528"><a href="#cb18-528"></a><span class="in">  }else{</span></span>
<span id="cb18-529"><a href="#cb18-529"></a><span class="in">    this.index.num &lt;- (strsplit(this.index,"s")[[1]][2] %&gt;% as.integer) +1</span></span>
<span id="cb18-530"><a href="#cb18-530"></a><span class="in">    nZero&lt;-sum(mat.beta[,this.index]!=0, na.rm=T) # number of non-zero coefficient</span></span>
<span id="cb18-531"><a href="#cb18-531"></a><span class="in">    #mat.beta[mat.beta[,this.index]!=0,this.index,drop=F]</span></span>
<span id="cb18-532"><a href="#cb18-532"></a><span class="in">    dt.bar&lt;-data.table(</span></span>
<span id="cb18-533"><a href="#cb18-533"></a><span class="in">                      method="LASSO",</span></span>
<span id="cb18-534"><a href="#cb18-534"></a><span class="in">                      fold=my.fold,</span></span>
<span id="cb18-535"><a href="#cb18-535"></a><span class="in">                      mat.beta[mat.beta[,this.index.num]!=0,this.index.num,drop=F] %&gt;% as.data.table(keep.rownames=T)</span></span>
<span id="cb18-536"><a href="#cb18-536"></a><span class="in">    ) # save as the above</span></span>
<span id="cb18-537"><a href="#cb18-537"></a><span class="in">    setnames(dt.bar,c("method","fold","feature","score"))</span></span>
<span id="cb18-538"><a href="#cb18-538"></a></span>
<span id="cb18-539"><a href="#cb18-539"></a><span class="in">    if(nrow(dt.bar)&gt;my.num){</span></span>
<span id="cb18-540"><a href="#cb18-540"></a><span class="in">      dt.bar&lt;-dt.bar[order(method,fold,-abs(score))][1:my.num]</span></span>
<span id="cb18-541"><a href="#cb18-541"></a><span class="in">    }</span></span>
<span id="cb18-542"><a href="#cb18-542"></a></span>
<span id="cb18-543"><a href="#cb18-543"></a><span class="in">    dt.baz&lt;-rbind(dt.foo, dt.bar)</span></span>
<span id="cb18-544"><a href="#cb18-544"></a><span class="in">    dt.baz&lt;-dt.baz[order(method,fold,-abs(score))][,rank:=1:.N,.(method,fold)]</span></span>
<span id="cb18-545"><a href="#cb18-545"></a><span class="in">    return(dt.baz)</span></span>
<span id="cb18-546"><a href="#cb18-546"></a><span class="in">  }</span></span>
<span id="cb18-547"><a href="#cb18-547"></a><span class="in">} # end of get_lasso_coef</span></span>
<span id="cb18-548"><a href="#cb18-548"></a><span class="in">```</span></span>
<span id="cb18-549"><a href="#cb18-549"></a>:::</span>
<span id="cb18-550"><a href="#cb18-550"></a></span>
<span id="cb18-551"><a href="#cb18-551"></a>::: {.callout-tip title="<span class="in">`R`</span> function <span class="in">`get_enet_coef`</span>"}</span>
<span id="cb18-552"><a href="#cb18-552"></a>This helper function runs <span class="co">[</span><span class="ot">Elastic net</span><span class="co">](https://en.wikipedia.org/wiki/Elastic_net_regularization)</span> and rank features by their importance.</span>
<span id="cb18-553"><a href="#cb18-553"></a><span class="in">```{r def-fun2}</span></span>
<span id="cb18-554"><a href="#cb18-554"></a><span class="in">#| label: def-enet</span></span>
<span id="cb18-555"><a href="#cb18-555"></a><span class="in">#| eval: false</span></span>
<span id="cb18-556"><a href="#cb18-556"></a><span class="in">#| code-summary: Code to run ENet1 and ENet2 and get non-zero coefficients</span></span>
<span id="cb18-557"><a href="#cb18-557"></a><span class="in"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb18-558"><a href="#cb18-558"></a><span class="in">get_enet_coef&lt;-function(x,my.fold,my.num=4){</span></span>
<span id="cb18-559"><a href="#cb18-559"></a><span class="in">  #x isa `matrix` and should contain 'y' column</span></span>
<span id="cb18-560"><a href="#cb18-560"></a><span class="in">  all.features&lt;-colnames(x)[colnames(x)!="y"]</span></span>
<span id="cb18-561"><a href="#cb18-561"></a></span>
<span id="cb18-562"><a href="#cb18-562"></a><span class="in">  cv.fit&lt;-list()</span></span>
<span id="cb18-563"><a href="#cb18-563"></a><span class="in">  ##########</span></span>
<span id="cb18-564"><a href="#cb18-564"></a><span class="in">  # E: EN1 #</span></span>
<span id="cb18-565"><a href="#cb18-565"></a><span class="in">  ##########</span></span>
<span id="cb18-566"><a href="#cb18-566"></a><span class="in">  cl &lt;- makePSOCKcluster(8) # No. of cores to use</span></span>
<span id="cb18-567"><a href="#cb18-567"></a><span class="in">  registerDoParallel(cl)</span></span>
<span id="cb18-568"><a href="#cb18-568"></a><span class="in">  set.seed(333) # set a random seed for a reproducibility</span></span>
<span id="cb18-569"><a href="#cb18-569"></a><span class="in">  system.time(</span></span>
<span id="cb18-570"><a href="#cb18-570"></a><span class="in">      cv.fit[["E"]]&lt;-caret::train(</span></span>
<span id="cb18-571"><a href="#cb18-571"></a><span class="in">                              x= x[,all.features], </span></span>
<span id="cb18-572"><a href="#cb18-572"></a><span class="in">                              y=factor(ifelse(x[,"y"]==1,'case','non_case'),levels=c("non_case","case")),</span></span>
<span id="cb18-573"><a href="#cb18-573"></a><span class="in">                              method="glmnet",</span></span>
<span id="cb18-574"><a href="#cb18-574"></a><span class="in">                              family="binomial",</span></span>
<span id="cb18-575"><a href="#cb18-575"></a><span class="in">                              trControl = trainControl(method = "cv",</span></span>
<span id="cb18-576"><a href="#cb18-576"></a><span class="in">                                                        summaryFunction = twoClassSummary,</span></span>
<span id="cb18-577"><a href="#cb18-577"></a><span class="in">                                                        classProbs = TRUE,</span></span>
<span id="cb18-578"><a href="#cb18-578"></a><span class="in">                                                        savePredictions = T,</span></span>
<span id="cb18-579"><a href="#cb18-579"></a><span class="in">                                                        verboseIter = T,</span></span>
<span id="cb18-580"><a href="#cb18-580"></a><span class="in">                                                        ),  # number =10 by default for "cv"</span></span>
<span id="cb18-581"><a href="#cb18-581"></a><span class="in">                              tuneLength=10, # grid size: 10(alpha) * 10(lambda) </span></span>
<span id="cb18-582"><a href="#cb18-582"></a><span class="in">      )</span></span>
<span id="cb18-583"><a href="#cb18-583"></a><span class="in">  )</span></span>
<span id="cb18-584"><a href="#cb18-584"></a><span class="in">  stopCluster(cl)</span></span>
<span id="cb18-585"><a href="#cb18-585"></a></span>
<span id="cb18-586"><a href="#cb18-586"></a><span class="in">  if(F){</span></span>
<span id="cb18-587"><a href="#cb18-587"></a><span class="in">  varImp(cv.fit[["E"]], useModel=T)</span></span>
<span id="cb18-588"><a href="#cb18-588"></a><span class="in">  varImp(cv.fit[["E"]], useModel=F, nonpara=F, scale=T)</span></span>
<span id="cb18-589"><a href="#cb18-589"></a><span class="in">  predictors(cv.fit$E) # features used in the model</span></span>
<span id="cb18-590"><a href="#cb18-590"></a><span class="in">  }</span></span>
<span id="cb18-591"><a href="#cb18-591"></a></span>
<span id="cb18-592"><a href="#cb18-592"></a><span class="in">  mat.beta&lt;- cv.fit$E$finalModel$beta %&gt;% as.matrix</span></span>
<span id="cb18-593"><a href="#cb18-593"></a><span class="in">  my.lambdas&lt;-apply(mat.beta, 2, function(i){table(i!=0)["TRUE"]})&gt;=my.num</span></span>
<span id="cb18-594"><a href="#cb18-594"></a><span class="in">  this.index&lt;-my.lambdas[my.lambdas &amp; !is.na(my.lambdas)][1] %&gt;% names</span></span>
<span id="cb18-595"><a href="#cb18-595"></a><span class="in">  if(is.na(this.index)){</span></span>
<span id="cb18-596"><a href="#cb18-596"></a><span class="in">    dt.foo&lt;-NULL</span></span>
<span id="cb18-597"><a href="#cb18-597"></a><span class="in">  }else{</span></span>
<span id="cb18-598"><a href="#cb18-598"></a><span class="in">    this.index.num &lt;- (strsplit(this.index,"s")[[1]][2] %&gt;% as.integer) +1</span></span>
<span id="cb18-599"><a href="#cb18-599"></a><span class="in">    #mat.beta[mat.beta[,this.index.num]!=0,this.index.num,drop=F] %&gt;% as.data.table(keep.rownames=T)</span></span>
<span id="cb18-600"><a href="#cb18-600"></a><span class="in">    dt.foo&lt;-data.table(method="ENet1",</span></span>
<span id="cb18-601"><a href="#cb18-601"></a><span class="in">                      fold=my.fold,</span></span>
<span id="cb18-602"><a href="#cb18-602"></a><span class="in">                      mat.beta[mat.beta[,this.index.num]!=0,this.index.num,drop=F] %&gt;% as.data.table(keep.rownames=T)) # save as the above</span></span>
<span id="cb18-603"><a href="#cb18-603"></a><span class="in">    setnames(dt.foo,c("method","fold","feature","score"))</span></span>
<span id="cb18-604"><a href="#cb18-604"></a><span class="in">    if(nrow(dt.foo)&gt;my.num){</span></span>
<span id="cb18-605"><a href="#cb18-605"></a><span class="in">      dt.foo&lt;-dt.foo[order(method,fold,-abs(score))][1:my.num]</span></span>
<span id="cb18-606"><a href="#cb18-606"></a><span class="in">    }</span></span>
<span id="cb18-607"><a href="#cb18-607"></a><span class="in">  }</span></span>
<span id="cb18-608"><a href="#cb18-608"></a></span>
<span id="cb18-609"><a href="#cb18-609"></a><span class="in">  ##########</span></span>
<span id="cb18-610"><a href="#cb18-610"></a><span class="in">  # F: EN2 #</span></span>
<span id="cb18-611"><a href="#cb18-611"></a><span class="in">  ##########</span></span>
<span id="cb18-612"><a href="#cb18-612"></a><span class="in">  set.seed(333)</span></span>
<span id="cb18-613"><a href="#cb18-613"></a><span class="in">  system.time(</span></span>
<span id="cb18-614"><a href="#cb18-614"></a><span class="in">      cv.fit[["F"]]&lt;-cv.glmnet(</span></span>
<span id="cb18-615"><a href="#cb18-615"></a><span class="in">                  x= x[,all.features], </span></span>
<span id="cb18-616"><a href="#cb18-616"></a><span class="in">                  y= x[,"y"], # will be coerced to a factor if not (for binomial)</span></span>
<span id="cb18-617"><a href="#cb18-617"></a><span class="in">                  family="binomial",</span></span>
<span id="cb18-618"><a href="#cb18-618"></a><span class="in">                  alpha=cv.fit$E$bestTune$alpha,</span></span>
<span id="cb18-619"><a href="#cb18-619"></a><span class="in">                  keep=T, # FALSE by default</span></span>
<span id="cb18-620"><a href="#cb18-620"></a><span class="in">                  type.measure = "auc" #type.measure="class" # default for 'binomial'</span></span>
<span id="cb18-621"><a href="#cb18-621"></a><span class="in">      )</span></span>
<span id="cb18-622"><a href="#cb18-622"></a><span class="in">  )</span></span>
<span id="cb18-623"><a href="#cb18-623"></a><span class="in">  #cv.fit$F$nzero</span></span>
<span id="cb18-624"><a href="#cb18-624"></a><span class="in">  mat.beta2 &lt;- cv.fit$F$glmnet.fit$beta %&gt;% as.matrix</span></span>
<span id="cb18-625"><a href="#cb18-625"></a><span class="in">  my.lambdas&lt;-apply(mat.beta2, 2, function(i){table(i!=0)["TRUE"]})&gt;=my.num</span></span>
<span id="cb18-626"><a href="#cb18-626"></a><span class="in">  this.index&lt;-my.lambdas[my.lambdas &amp; !is.na(my.lambdas)][1] %&gt;% names</span></span>
<span id="cb18-627"><a href="#cb18-627"></a><span class="in">  if(is.na(this.index)){</span></span>
<span id="cb18-628"><a href="#cb18-628"></a><span class="in">    dt.bar&lt;-NULL</span></span>
<span id="cb18-629"><a href="#cb18-629"></a><span class="in">  }else{</span></span>
<span id="cb18-630"><a href="#cb18-630"></a><span class="in">    this.index.num &lt;- (strsplit(this.index,"s")[[1]][2] %&gt;% as.integer) +1</span></span>
<span id="cb18-631"><a href="#cb18-631"></a><span class="in">    dt.bar&lt;-data.table(</span></span>
<span id="cb18-632"><a href="#cb18-632"></a><span class="in">                        method="ENet2",</span></span>
<span id="cb18-633"><a href="#cb18-633"></a><span class="in">                        fold=my.fold,</span></span>
<span id="cb18-634"><a href="#cb18-634"></a><span class="in">                        mat.beta2[mat.beta2[,this.index.num]!=0,this.index.num,drop=F] %&gt;% as.data.table(keep.rownames=T)) # save as the above</span></span>
<span id="cb18-635"><a href="#cb18-635"></a><span class="in">    setnames(dt.bar,c("method","fold","feature","score"))</span></span>
<span id="cb18-636"><a href="#cb18-636"></a><span class="in">    if(nrow(dt.bar)&gt;my.num){</span></span>
<span id="cb18-637"><a href="#cb18-637"></a><span class="in">      dt.bar&lt;-dt.bar[order(method,fold,-abs(score))][1:my.num]</span></span>
<span id="cb18-638"><a href="#cb18-638"></a><span class="in">    }</span></span>
<span id="cb18-639"><a href="#cb18-639"></a><span class="in">  }</span></span>
<span id="cb18-640"><a href="#cb18-640"></a></span>
<span id="cb18-641"><a href="#cb18-641"></a><span class="in">  dt.baz&lt;-rbind(dt.foo,dt.bar)</span></span>
<span id="cb18-642"><a href="#cb18-642"></a><span class="in">  if(!is.null(dt.baz)){</span></span>
<span id="cb18-643"><a href="#cb18-643"></a><span class="in">    dt.baz&lt;-dt.baz[order(method,fold,-abs(score))][,rank:=1:.N,.(method,fold)]</span></span>
<span id="cb18-644"><a href="#cb18-644"></a><span class="in">  }</span></span>
<span id="cb18-645"><a href="#cb18-645"></a><span class="in">  return(dt.baz)</span></span>
<span id="cb18-646"><a href="#cb18-646"></a><span class="in">} # end of get_enet_coef</span></span>
<span id="cb18-647"><a href="#cb18-647"></a><span class="in">```</span></span>
<span id="cb18-648"><a href="#cb18-648"></a>:::</span>
<span id="cb18-649"><a href="#cb18-649"></a></span>
<span id="cb18-650"><a href="#cb18-650"></a>::: {.callout-tip title="<span class="in">`R`</span> function <span class="in">`runRFE2`</span>"}</span>
<span id="cb18-651"><a href="#cb18-651"></a>This helper function select desired number of features by using recursive feature elimination method via <span class="co">[</span><span class="ot">`caret::rfe()`</span><span class="co">](https://topepo.github.io/caret/recursive-feature-elimination.html)</span></span>
<span id="cb18-652"><a href="#cb18-652"></a><span class="in">```{r def-fun3}</span></span>
<span id="cb18-653"><a href="#cb18-653"></a><span class="in">#| lable: def-rfe </span></span>
<span id="cb18-654"><a href="#cb18-654"></a><span class="in">#| eval: false</span></span>
<span id="cb18-655"><a href="#cb18-655"></a><span class="in">#| code-summary: Code to run recursive feature elimination</span></span>
<span id="cb18-656"><a href="#cb18-656"></a><span class="in"># x: data matrix</span></span>
<span id="cb18-657"><a href="#cb18-657"></a><span class="in"># my.method: </span></span>
<span id="cb18-658"><a href="#cb18-658"></a><span class="in"># my.num: number of desired features</span></span>
<span id="cb18-659"><a href="#cb18-659"></a><span class="in"># my.index: a list with elements for each external resampling iteration.</span></span>
<span id="cb18-660"><a href="#cb18-660"></a><span class="in"># is.final: the final selected features if set true; oterwise at each fold level</span></span>
<span id="cb18-661"><a href="#cb18-661"></a><span class="in"># returns: data.table(`method`,`fold`,`feature`,`score`,`rank`)</span></span>
<span id="cb18-662"><a href="#cb18-662"></a><span class="in">runRFE2 &lt;-function(x, my.method="svmRadial", my.num=4, my.index, is.final=F){</span></span>
<span id="cb18-663"><a href="#cb18-663"></a><span class="in">  #x isa `matrix` and should contain 'y' column</span></span>
<span id="cb18-664"><a href="#cb18-664"></a><span class="in">  all.features&lt;-colnames(x)[colnames(x)!="y"]</span></span>
<span id="cb18-665"><a href="#cb18-665"></a></span>
<span id="cb18-666"><a href="#cb18-666"></a><span class="in">  li.methods&lt;-list(</span></span>
<span id="cb18-667"><a href="#cb18-667"></a><span class="in">    `svmLinear`="svmLinear",</span></span>
<span id="cb18-668"><a href="#cb18-668"></a><span class="in">    `svmRadial`="svmRadial",</span></span>
<span id="cb18-669"><a href="#cb18-669"></a><span class="in">    `nnet`="nnet",</span></span>
<span id="cb18-670"><a href="#cb18-670"></a><span class="in">    `pcaNNet`="pcaNNet",</span></span>
<span id="cb18-671"><a href="#cb18-671"></a><span class="in">    `rfFuncs`=rfFuncs,</span></span>
<span id="cb18-672"><a href="#cb18-672"></a><span class="in">    `nbFuncs`=nbFuncs,</span></span>
<span id="cb18-673"><a href="#cb18-673"></a><span class="in">    )</span></span>
<span id="cb18-674"><a href="#cb18-674"></a></span>
<span id="cb18-675"><a href="#cb18-675"></a><span class="in">  my.fun&lt;-li.methods[[my.method]]</span></span>
<span id="cb18-676"><a href="#cb18-676"></a><span class="in">  if(is.list(my.fun)){</span></span>
<span id="cb18-677"><a href="#cb18-677"></a><span class="in">    myFuncs&lt;-my.fun</span></span>
<span id="cb18-678"><a href="#cb18-678"></a><span class="in">  }else{</span></span>
<span id="cb18-679"><a href="#cb18-679"></a><span class="in">    myFuncs&lt;-caretFuncs</span></span>
<span id="cb18-680"><a href="#cb18-680"></a><span class="in">  }</span></span>
<span id="cb18-681"><a href="#cb18-681"></a><span class="in">  myFuncs$summary &lt;- twoClassSummary</span></span>
<span id="cb18-682"><a href="#cb18-682"></a></span>
<span id="cb18-683"><a href="#cb18-683"></a><span class="in">  rfe.ctrl &lt;- rfeControl(functions=myFuncs,</span></span>
<span id="cb18-684"><a href="#cb18-684"></a><span class="in">                         method = "cv",</span></span>
<span id="cb18-685"><a href="#cb18-685"></a><span class="in">                         #repeats =1, number = 10, # NB, index below</span></span>
<span id="cb18-686"><a href="#cb18-686"></a><span class="in">                         #returnResamp="all", # "final" by default</span></span>
<span id="cb18-687"><a href="#cb18-687"></a><span class="in">                         saveDetails=T,</span></span>
<span id="cb18-688"><a href="#cb18-688"></a><span class="in">                         verbose = TRUE,</span></span>
<span id="cb18-689"><a href="#cb18-689"></a><span class="in">                         index = my.index #a list with elements for each external resampling iteration.</span></span>
<span id="cb18-690"><a href="#cb18-690"></a><span class="in">                                          #Each list element is the sample rows used for training at</span></span>
<span id="cb18-691"><a href="#cb18-691"></a><span class="in">                                          #that iteration.</span></span>
<span id="cb18-692"><a href="#cb18-692"></a><span class="in">  )</span></span>
<span id="cb18-693"><a href="#cb18-693"></a></span>
<span id="cb18-694"><a href="#cb18-694"></a><span class="in">  tr.ctrl &lt;- trainControl(method = "cv",</span></span>
<span id="cb18-695"><a href="#cb18-695"></a><span class="in">                          #repeats =1, number = 10, # NB, index below</span></span>
<span id="cb18-696"><a href="#cb18-696"></a><span class="in">                          summaryFunction = twoClassSummary,</span></span>
<span id="cb18-697"><a href="#cb18-697"></a><span class="in">                          classProbs = TRUE,</span></span>
<span id="cb18-698"><a href="#cb18-698"></a><span class="in">                          savePredictions = T,</span></span>
<span id="cb18-699"><a href="#cb18-699"></a><span class="in">                          verboseIter = T,</span></span>
<span id="cb18-700"><a href="#cb18-700"></a><span class="in">                          index = my.index #a list with elements for each external resampling iteration.</span></span>
<span id="cb18-701"><a href="#cb18-701"></a><span class="in">                                            #Each list element is the sample rows used for training at</span></span>
<span id="cb18-702"><a href="#cb18-702"></a><span class="in">                                            #that iteration.</span></span>
<span id="cb18-703"><a href="#cb18-703"></a><span class="in">  )</span></span>
<span id="cb18-704"><a href="#cb18-704"></a></span>
<span id="cb18-705"><a href="#cb18-705"></a><span class="in">  # run REF via caret::ref #</span></span>
<span id="cb18-706"><a href="#cb18-706"></a><span class="in">  cl &lt;- makePSOCKcluster(8) # No. of cores to use</span></span>
<span id="cb18-707"><a href="#cb18-707"></a><span class="in">  registerDoParallel(cl)</span></span>
<span id="cb18-708"><a href="#cb18-708"></a><span class="in">  set.seed(333) # set a random seed for a reproducibility</span></span>
<span id="cb18-709"><a href="#cb18-709"></a><span class="in">  cv.rfe&lt;-caret::rfe(</span></span>
<span id="cb18-710"><a href="#cb18-710"></a><span class="in">                     x=as.data.frame(x[,all.features]),</span></span>
<span id="cb18-711"><a href="#cb18-711"></a><span class="in">                     y=factor(ifelse(x[,"y"]==1,'case','non_case'),levels=c("non_case","case")),</span></span>
<span id="cb18-712"><a href="#cb18-712"></a><span class="in">                     sizes = my.num, #2^(2:4), # default </span></span>
<span id="cb18-713"><a href="#cb18-713"></a><span class="in">                     metric="ROC",</span></span>
<span id="cb18-714"><a href="#cb18-714"></a><span class="in">                     rfeControl=rfe.ctrl,</span></span>
<span id="cb18-715"><a href="#cb18-715"></a><span class="in">                     method=my.method, # feed it to 'train'</span></span>
<span id="cb18-716"><a href="#cb18-716"></a><span class="in">                     tuneLength = 5, #ifelse(trControl$method == "none", 1, 3)</span></span>
<span id="cb18-717"><a href="#cb18-717"></a><span class="in">                     trControl=tr.ctrl # feed it to 'train'</span></span>
<span id="cb18-718"><a href="#cb18-718"></a><span class="in">  )</span></span>
<span id="cb18-719"><a href="#cb18-719"></a><span class="in">  stopCluster(cl)</span></span>
<span id="cb18-720"><a href="#cb18-720"></a></span>
<span id="cb18-721"><a href="#cb18-721"></a><span class="in">  dt.foo&lt;-data.table(`method`=my.method,cv.rfe$variables)</span></span>
<span id="cb18-722"><a href="#cb18-722"></a><span class="in">  if(is.final){</span></span>
<span id="cb18-723"><a href="#cb18-723"></a><span class="in">    dt.bar&lt;-data.table(`method`=my.method,</span></span>
<span id="cb18-724"><a href="#cb18-724"></a><span class="in">                       `fold`="final",</span></span>
<span id="cb18-725"><a href="#cb18-725"></a><span class="in">                       `feature`=cv.rfe$optVariables[1:my.num],</span></span>
<span id="cb18-726"><a href="#cb18-726"></a><span class="in">                       `score`=NA,</span></span>
<span id="cb18-727"><a href="#cb18-727"></a><span class="in">                       `rank`=1:my.num)</span></span>
<span id="cb18-728"><a href="#cb18-728"></a><span class="in">  }else{</span></span>
<span id="cb18-729"><a href="#cb18-729"></a><span class="in">    dt.bar&lt;-dt.foo[Variables==cv.rfe$optsize][order(Resample,-Overall)][,.SD[1:my.num],.(method,Resample)][,rank:=1:.N,.(method,Resample)][,.(method,fold=Resample,feature=var,score=Overall,rank)]</span></span>
<span id="cb18-730"><a href="#cb18-730"></a><span class="in">  }</span></span>
<span id="cb18-731"><a href="#cb18-731"></a></span>
<span id="cb18-732"><a href="#cb18-732"></a><span class="in">  return(dt.bar)</span></span>
<span id="cb18-733"><a href="#cb18-733"></a><span class="in">}</span></span>
<span id="cb18-734"><a href="#cb18-734"></a><span class="in">```</span></span>
<span id="cb18-735"><a href="#cb18-735"></a>:::</span>
<span id="cb18-736"><a href="#cb18-736"></a></span>
<span id="cb18-737"><a href="#cb18-737"></a>::: {.callout-tip title="<span class="in">`R`</span> function <span class="in">`get_cv_glm`</span>"}</span>
<span id="cb18-738"><a href="#cb18-738"></a>This helper function extracts the predictive performance of the training model from a given fold tested using held-out samples during kCV.</span>
<span id="cb18-739"><a href="#cb18-739"></a><span class="in">```{r def-fun4}</span></span>
<span id="cb18-740"><a href="#cb18-740"></a><span class="in">#| label: def-cv-glm</span></span>
<span id="cb18-741"><a href="#cb18-741"></a><span class="in">#| eval: false</span></span>
<span id="cb18-742"><a href="#cb18-742"></a><span class="in">#| code-summary: Code to extract the stat of the training model given the fold ID from the 5-fold CV with 5 repetitions</span></span>
<span id="cb18-743"><a href="#cb18-743"></a><span class="in"># x: matrix dataset (train/test at the same time, separated by my.index which is the training)</span></span>
<span id="cb18-744"><a href="#cb18-744"></a><span class="in"># my.fold: fold ID</span></span>
<span id="cb18-745"><a href="#cb18-745"></a><span class="in"># my.index: the training index of `x` to subset where the model should be built</span></span>
<span id="cb18-746"><a href="#cb18-746"></a><span class="in"># my.feature: features of interests</span></span>
<span id="cb18-747"><a href="#cb18-747"></a><span class="in">get_cv_glm&lt;-function(x=li.mat[["train"]][["28wk"]],my.fold,my.index,my.feature){</span></span>
<span id="cb18-748"><a href="#cb18-748"></a><span class="in">  mat.tr&lt;-x[my.index,] # index of the training</span></span>
<span id="cb18-749"><a href="#cb18-749"></a><span class="in">  df.mat.tr&lt;-mat.tr[,c(my.feature,'y')] %&gt;% as.data.frame  # training set</span></span>
<span id="cb18-750"><a href="#cb18-750"></a></span>
<span id="cb18-751"><a href="#cb18-751"></a><span class="in">  ############################################</span></span>
<span id="cb18-752"><a href="#cb18-752"></a><span class="in">  # fit the model using the training dataset #</span></span>
<span id="cb18-753"><a href="#cb18-753"></a><span class="in">  ############################################</span></span>
<span id="cb18-754"><a href="#cb18-754"></a><span class="in">  my.model&lt;-glm(y~. , data = df.mat.tr, family = "binomial")</span></span>
<span id="cb18-755"><a href="#cb18-755"></a></span>
<span id="cb18-756"><a href="#cb18-756"></a><span class="in">  # ROC from the training fold</span></span>
<span id="cb18-757"><a href="#cb18-757"></a><span class="in">  my.roc &lt;-pROC::roc(response=df.mat.tr$y, predictor=fitted(my.model),quite=T,ci=T)</span></span>
<span id="cb18-758"><a href="#cb18-758"></a></span>
<span id="cb18-759"><a href="#cb18-759"></a><span class="in">  # LPOCV from the training fold</span></span>
<span id="cb18-760"><a href="#cb18-760"></a><span class="in">  LPOCV.boot&lt;-boot::boot(data=df.mat.tr, statistic=get_LPOCV_boot,R=100,parallel="multicore",ncpus=10)</span></span>
<span id="cb18-761"><a href="#cb18-761"></a><span class="in">  LPOCV.ci&lt;-boot::boot.ci(LPOCV.boot,type="perc")</span></span>
<span id="cb18-762"><a href="#cb18-762"></a></span>
<span id="cb18-763"><a href="#cb18-763"></a><span class="in">  # the whole dataset were training set, i.e. no test</span></span>
<span id="cb18-764"><a href="#cb18-764"></a><span class="in">  if(length(my.index)==nrow(x)){</span></span>
<span id="cb18-765"><a href="#cb18-765"></a><span class="in">    cbind(</span></span>
<span id="cb18-766"><a href="#cb18-766"></a><span class="in">      data.table(</span></span>
<span id="cb18-767"><a href="#cb18-767"></a><span class="in">                `fold`=my.fold,</span></span>
<span id="cb18-768"><a href="#cb18-768"></a><span class="in">                `predictor`=paste(my.feature,collapse=",")</span></span>
<span id="cb18-769"><a href="#cb18-769"></a><span class="in">                ),</span></span>
<span id="cb18-770"><a href="#cb18-770"></a><span class="in">      data.table(</span></span>
<span id="cb18-771"><a href="#cb18-771"></a><span class="in">                `AIC`=my.model$aic,</span></span>
<span id="cb18-772"><a href="#cb18-772"></a><span class="in">                `BIC`=BIC(my.model),</span></span>
<span id="cb18-773"><a href="#cb18-773"></a><span class="in">                `AUC`=my.roc$ci[2]*100, </span></span>
<span id="cb18-774"><a href="#cb18-774"></a><span class="in">                `AUC_lo`=my.roc$ci[1]*100, </span></span>
<span id="cb18-775"><a href="#cb18-775"></a><span class="in">                `AUC_hi`=my.roc$ci[3]*100,</span></span>
<span id="cb18-776"><a href="#cb18-776"></a><span class="in">                `LPOCV`=LPOCV.boot$t0,</span></span>
<span id="cb18-777"><a href="#cb18-777"></a><span class="in">                `LPOCV_lo`=LPOCV.ci$percent[4],</span></span>
<span id="cb18-778"><a href="#cb18-778"></a><span class="in">                `LPOCV_hi`=LPOCV.ci$percent[5]</span></span>
<span id="cb18-779"><a href="#cb18-779"></a><span class="in">                )</span></span>
<span id="cb18-780"><a href="#cb18-780"></a><span class="in">    )</span></span>
<span id="cb18-781"><a href="#cb18-781"></a><span class="in">  }else{</span></span>
<span id="cb18-782"><a href="#cb18-782"></a><span class="in">    #################################################</span></span>
<span id="cb18-783"><a href="#cb18-783"></a><span class="in">    # now, predict the outcome of the held-out data #</span></span>
<span id="cb18-784"><a href="#cb18-784"></a><span class="in">    # using the model from the training dataset     #</span></span>
<span id="cb18-785"><a href="#cb18-785"></a><span class="in">    #################################################</span></span>
<span id="cb18-786"><a href="#cb18-786"></a><span class="in">    mat.test&lt;-x[-my.index,]  </span></span>
<span id="cb18-787"><a href="#cb18-787"></a><span class="in">    df.mat.test&lt;-mat.test[,c(my.feature,'y')] %&gt;% as.data.frame # held-out</span></span>
<span id="cb18-788"><a href="#cb18-788"></a></span>
<span id="cb18-789"><a href="#cb18-789"></a><span class="in">    my.prob&lt;-predict.glm(my.model, newdata=df.mat.test, type="response") </span></span>
<span id="cb18-790"><a href="#cb18-790"></a><span class="in">    my.roc.test &lt;- pROC::roc(response=df.mat.test$y, predictor=my.prob,quiet=T,ci=T)</span></span>
<span id="cb18-791"><a href="#cb18-791"></a><span class="in">    LPOCV.boot.test&lt;-boot::boot(data=df.mat.test, statistic=get_LPOCV_boot,R=100,parallel="multicore",ncpus=20)</span></span>
<span id="cb18-792"><a href="#cb18-792"></a><span class="in">    # deal with failed boot result</span></span>
<span id="cb18-793"><a href="#cb18-793"></a><span class="in">    if(is.numeric(LPOCV.boot.test$t)){</span></span>
<span id="cb18-794"><a href="#cb18-794"></a><span class="in">      LPOCV.ci.test&lt;-boot::boot.ci(LPOCV.boot.test,type="perc")</span></span>
<span id="cb18-795"><a href="#cb18-795"></a><span class="in">      LPOCV_test_lo=LPOCV.ci.test$percent[4]</span></span>
<span id="cb18-796"><a href="#cb18-796"></a><span class="in">      LPOCV_test_hi=LPOCV.ci.test$percent[5]</span></span>
<span id="cb18-797"><a href="#cb18-797"></a><span class="in">    }else{</span></span>
<span id="cb18-798"><a href="#cb18-798"></a><span class="in">      LPOCV_test_lo=NA</span></span>
<span id="cb18-799"><a href="#cb18-799"></a><span class="in">      LPOCV_test_hi=NA</span></span>
<span id="cb18-800"><a href="#cb18-800"></a><span class="in">    }</span></span>
<span id="cb18-801"><a href="#cb18-801"></a><span class="in">    # return the following table</span></span>
<span id="cb18-802"><a href="#cb18-802"></a><span class="in">    cbind(</span></span>
<span id="cb18-803"><a href="#cb18-803"></a><span class="in">      data.table(</span></span>
<span id="cb18-804"><a href="#cb18-804"></a><span class="in">                `fold`=my.fold,</span></span>
<span id="cb18-805"><a href="#cb18-805"></a><span class="in">                `predictor`=paste(my.feature,collapse=",")</span></span>
<span id="cb18-806"><a href="#cb18-806"></a><span class="in">                ),</span></span>
<span id="cb18-807"><a href="#cb18-807"></a><span class="in">      data.table(</span></span>
<span id="cb18-808"><a href="#cb18-808"></a><span class="in">                `AIC`=my.model$aic,</span></span>
<span id="cb18-809"><a href="#cb18-809"></a><span class="in">                `BIC`=BIC(my.model),</span></span>
<span id="cb18-810"><a href="#cb18-810"></a><span class="in">                `AUC`=my.roc$ci[2]*100, </span></span>
<span id="cb18-811"><a href="#cb18-811"></a><span class="in">                `AUC_lo`=my.roc$ci[1]*100, </span></span>
<span id="cb18-812"><a href="#cb18-812"></a><span class="in">                `AUC_hi`=my.roc$ci[3]*100,</span></span>
<span id="cb18-813"><a href="#cb18-813"></a><span class="in">                `LPOCV`=LPOCV.boot$t0,</span></span>
<span id="cb18-814"><a href="#cb18-814"></a><span class="in">                `LPOCV_lo`=LPOCV.ci$percent[4],</span></span>
<span id="cb18-815"><a href="#cb18-815"></a><span class="in">                `LPOCV_hi`=LPOCV.ci$percent[5],</span></span>
<span id="cb18-816"><a href="#cb18-816"></a><span class="in">                `AUC_test`=my.roc.test$ci[2]*100, </span></span>
<span id="cb18-817"><a href="#cb18-817"></a><span class="in">                `AUC_test_lo`=my.roc.test$ci[1]*100, </span></span>
<span id="cb18-818"><a href="#cb18-818"></a><span class="in">                `AUC_test_hi`=my.roc.test$ci[3]*100,</span></span>
<span id="cb18-819"><a href="#cb18-819"></a><span class="in">                `LPOCV_test`=LPOCV.boot.test$t0,</span></span>
<span id="cb18-820"><a href="#cb18-820"></a><span class="in">                `LPOCV_test_lo`=LPOCV_test_lo,</span></span>
<span id="cb18-821"><a href="#cb18-821"></a><span class="in">                `LPOCV_test_hi`=LPOCV_test_hi</span></span>
<span id="cb18-822"><a href="#cb18-822"></a><span class="in">                )</span></span>
<span id="cb18-823"><a href="#cb18-823"></a><span class="in">    )</span></span>
<span id="cb18-824"><a href="#cb18-824"></a><span class="in">  }</span></span>
<span id="cb18-825"><a href="#cb18-825"></a><span class="in">}</span></span>
<span id="cb18-826"><a href="#cb18-826"></a><span class="in">```</span></span>
<span id="cb18-827"><a href="#cb18-827"></a>:::</span>
<span id="cb18-828"><a href="#cb18-828"></a></span>
<span id="cb18-829"><a href="#cb18-829"></a>::: {.callout-tip title="<span class="in">`R`</span> function <span class="in">`get_cv_glm2`</span>"}</span>
<span id="cb18-830"><a href="#cb18-830"></a>This helper function extracts the basic statistic (e.g. AIC, BIC, and AUC etc) of the training model for a given fold during kCV.</span>
<span id="cb18-831"><a href="#cb18-831"></a><span class="in">```{r def-fun5}</span></span>
<span id="cb18-832"><a href="#cb18-832"></a><span class="in">#| label: def-cv-glm2</span></span>
<span id="cb18-833"><a href="#cb18-833"></a><span class="in">#| eval: false</span></span>
<span id="cb18-834"><a href="#cb18-834"></a><span class="in">#| code-summary: Code to extract the predictive performance of the training model given the fold ID from the 5-fold CV with 5 repetitions</span></span>
<span id="cb18-835"><a href="#cb18-835"></a><span class="in"># x: the dataset where the model should be tested on (i.e. the test set)</span></span>
<span id="cb18-836"><a href="#cb18-836"></a><span class="in"># my.model: the model from the training </span></span>
<span id="cb18-837"><a href="#cb18-837"></a><span class="in"># my.feature: features of interests</span></span>
<span id="cb18-838"><a href="#cb18-838"></a><span class="in">get_cv_glm2&lt;-function(x=li.mat[["test"]][["28wk"]],my.fold, my.model,my.feature){</span></span>
<span id="cb18-839"><a href="#cb18-839"></a><span class="in">    df.mat.test&lt;-x[,c(my.feature,'y')] %&gt;% as.data.frame # test (validation) dataset</span></span>
<span id="cb18-840"><a href="#cb18-840"></a></span>
<span id="cb18-841"><a href="#cb18-841"></a><span class="in">    #my.prob&lt;-predict.glm(my.model, newdata=df.mat.test, type="response") </span></span>
<span id="cb18-842"><a href="#cb18-842"></a><span class="in">    my.prob&lt;-predict(my.model, newdata=df.mat.test, type="response") </span></span>
<span id="cb18-843"><a href="#cb18-843"></a><span class="in">    my.roc.test &lt;- pROC::roc(response=df.mat.test$y, predictor=my.prob,quiet=T,ci=T)</span></span>
<span id="cb18-844"><a href="#cb18-844"></a><span class="in">    LPOCV.boot.test&lt;-boot::boot(data=df.mat.test, statistic=get_LPOCV_boot,R=100,parallel="multicore",ncpus=20)</span></span>
<span id="cb18-845"><a href="#cb18-845"></a><span class="in">    # deal with failed boot result</span></span>
<span id="cb18-846"><a href="#cb18-846"></a><span class="in">    if(is.numeric(LPOCV.boot.test$t)){</span></span>
<span id="cb18-847"><a href="#cb18-847"></a><span class="in">      LPOCV.ci.test&lt;-boot::boot.ci(LPOCV.boot.test,type="perc")</span></span>
<span id="cb18-848"><a href="#cb18-848"></a><span class="in">      LPOCV_test_lo=LPOCV.ci.test$percent[4]</span></span>
<span id="cb18-849"><a href="#cb18-849"></a><span class="in">      LPOCV_test_hi=LPOCV.ci.test$percent[5]</span></span>
<span id="cb18-850"><a href="#cb18-850"></a><span class="in">    }else{</span></span>
<span id="cb18-851"><a href="#cb18-851"></a><span class="in">      LPOCV_test_lo=NA</span></span>
<span id="cb18-852"><a href="#cb18-852"></a><span class="in">      LPOCV_test_hi=NA</span></span>
<span id="cb18-853"><a href="#cb18-853"></a><span class="in">    }</span></span>
<span id="cb18-854"><a href="#cb18-854"></a></span>
<span id="cb18-855"><a href="#cb18-855"></a><span class="in">    # return the following table</span></span>
<span id="cb18-856"><a href="#cb18-856"></a><span class="in">    cbind(</span></span>
<span id="cb18-857"><a href="#cb18-857"></a><span class="in">      data.table(</span></span>
<span id="cb18-858"><a href="#cb18-858"></a><span class="in">                `fold`=my.fold,</span></span>
<span id="cb18-859"><a href="#cb18-859"></a><span class="in">                `predictor`=paste(my.feature,collapse=",")</span></span>
<span id="cb18-860"><a href="#cb18-860"></a><span class="in">                ),</span></span>
<span id="cb18-861"><a href="#cb18-861"></a><span class="in">      data.table(</span></span>
<span id="cb18-862"><a href="#cb18-862"></a><span class="in">                `AUC_test`=my.roc.test$ci[2]*100, </span></span>
<span id="cb18-863"><a href="#cb18-863"></a><span class="in">                `AUC_test_lo`=my.roc.test$ci[1]*100, </span></span>
<span id="cb18-864"><a href="#cb18-864"></a><span class="in">                `AUC_test_hi`=my.roc.test$ci[3]*100,</span></span>
<span id="cb18-865"><a href="#cb18-865"></a><span class="in">                `LPOCV_test`=LPOCV.boot.test$t0,</span></span>
<span id="cb18-866"><a href="#cb18-866"></a><span class="in">                `LPOCV_test_lo`=LPOCV_test_lo,</span></span>
<span id="cb18-867"><a href="#cb18-867"></a><span class="in">                `LPOCV_test_hi`=LPOCV_test_hi,</span></span>
<span id="cb18-868"><a href="#cb18-868"></a><span class="in">                 `AIC`=my.model$aic,</span></span>
<span id="cb18-869"><a href="#cb18-869"></a><span class="in">                 `BIC`=BIC(my.model)</span></span>
<span id="cb18-870"><a href="#cb18-870"></a><span class="in">                )</span></span>
<span id="cb18-871"><a href="#cb18-871"></a><span class="in">    )</span></span>
<span id="cb18-872"><a href="#cb18-872"></a><span class="in">}</span></span>
<span id="cb18-873"><a href="#cb18-873"></a><span class="in">```</span></span>
<span id="cb18-874"><a href="#cb18-874"></a>:::</span>
<span id="cb18-875"><a href="#cb18-875"></a></span>
<span id="cb18-876"><a href="#cb18-876"></a>Having defined those helper functions, we are now ready to proceed 5-fold CV with 5 repetitions.</span>
<span id="cb18-877"><a href="#cb18-877"></a></span>
<span id="cb18-878"><a href="#cb18-878"></a><span class="in">```{r kcv_all_method1}</span></span>
<span id="cb18-879"><a href="#cb18-879"></a><span class="in">#| label: kcv-train-all</span></span>
<span id="cb18-880"><a href="#cb18-880"></a><span class="in">#| eval: false</span></span>
<span id="cb18-881"><a href="#cb18-881"></a><span class="in">#| code-summary: Code to run 11 ML methods in 5-fold CV with 5-repetitions</span></span>
<span id="cb18-882"><a href="#cb18-882"></a><span class="in">## </span></span>
<span id="cb18-883"><a href="#cb18-883"></a><span class="in">## Training on based on 5-fold CV</span></span>
<span id="cb18-884"><a href="#cb18-884"></a><span class="in">##</span></span>
<span id="cb18-885"><a href="#cb18-885"></a><span class="in">my.RData&lt;-file.path("RData/dl.kcv.core17.RData")</span></span>
<span id="cb18-886"><a href="#cb18-886"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-887"><a href="#cb18-887"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-888"><a href="#cb18-888"></a><span class="in">}else{</span></span>
<span id="cb18-889"><a href="#cb18-889"></a><span class="in">  library(e1071)</span></span>
<span id="cb18-890"><a href="#cb18-890"></a><span class="in">  source('SVM-RFE/msvmRFE.R')</span></span>
<span id="cb18-891"><a href="#cb18-891"></a></span>
<span id="cb18-892"><a href="#cb18-892"></a><span class="in">  li.methods&lt;-list(</span></span>
<span id="cb18-893"><a href="#cb18-893"></a><span class="in">    `svmLinear`="svmLinear",</span></span>
<span id="cb18-894"><a href="#cb18-894"></a><span class="in">    `svmRadial`="svmRadial",</span></span>
<span id="cb18-895"><a href="#cb18-895"></a><span class="in">    `nnet`="nnet",</span></span>
<span id="cb18-896"><a href="#cb18-896"></a><span class="in">    `pcaNNet`="pcaNNet",</span></span>
<span id="cb18-897"><a href="#cb18-897"></a><span class="in">    `rfFuncs`=rfFuncs,</span></span>
<span id="cb18-898"><a href="#cb18-898"></a><span class="in">    `nbFuncs`=nbFuncs</span></span>
<span id="cb18-899"><a href="#cb18-899"></a><span class="in">    )</span></span>
<span id="cb18-900"><a href="#cb18-900"></a></span>
<span id="cb18-901"><a href="#cb18-901"></a><span class="in">  #|Num: 6 Method: LASSO</span></span>
<span id="cb18-902"><a href="#cb18-902"></a><span class="in">  # Fold5.Rep5</span></span>
<span id="cb18-903"><a href="#cb18-903"></a><span class="in">  #Error in mat.beta[, this.index] : subscript out of bounds</span></span>
<span id="cb18-904"><a href="#cb18-904"></a><span class="in">  li.num&lt;-list(`F2`=2,`F3`=3,`F4`=4,`F5`=5,`F6`=6)</span></span>
<span id="cb18-905"><a href="#cb18-905"></a><span class="in">  dl.kcv&lt;-lapply(li.num, function(my.num){</span></span>
<span id="cb18-906"><a href="#cb18-906"></a><span class="in">    # 1. glParallel</span></span>
<span id="cb18-907"><a href="#cb18-907"></a><span class="in">    message(paste("Num:",my.num,"Method: glParallel"))</span></span>
<span id="cb18-908"><a href="#cb18-908"></a><span class="in">    my.pattern=paste0("^core17\\.Fold[[:alnum:]]\\.Rep[[:alnum:]]\\.best",my.num)</span></span>
<span id="cb18-909"><a href="#cb18-909"></a><span class="in">    dt.input&lt;-data.table(</span></span>
<span id="cb18-910"><a href="#cb18-910"></a><span class="in">                    foo=list.files("glParallel/result",pattern=my.pattern),</span></span>
<span id="cb18-911"><a href="#cb18-911"></a><span class="in">                    files=list.files("glParallel/result",pattern=my.pattern,full.names=T)</span></span>
<span id="cb18-912"><a href="#cb18-912"></a><span class="in">                    )[,c("foo1","bar1"):=tstrsplit(foo,"\\.",keep=c(2,3))][,fold:=paste(foo1,bar1,sep=".")][,c("foo","foo1","bar1"):=NULL]</span></span>
<span id="cb18-913"><a href="#cb18-913"></a></span>
<span id="cb18-914"><a href="#cb18-914"></a><span class="in">    dt.cv.glp &lt;-apply(dt.input, 1, function(i){</span></span>
<span id="cb18-915"><a href="#cb18-915"></a><span class="in">              my.fold&lt;-i[["fold"]]</span></span>
<span id="cb18-916"><a href="#cb18-916"></a><span class="in">              my.feature&lt;-fread(i["files"])[1][["Best proteins"]] %&gt;% strsplit(",") %&gt;% unlist</span></span>
<span id="cb18-917"><a href="#cb18-917"></a><span class="in">              data.table(method="glParallel",fold=my.fold,feature=my.feature,score=NA,rank=NA)</span></span>
<span id="cb18-918"><a href="#cb18-918"></a><span class="in">              #cbind(`fold`=i[["fold"]],fread(i["files"])[1])</span></span>
<span id="cb18-919"><a href="#cb18-919"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-920"><a href="#cb18-920"></a></span>
<span id="cb18-921"><a href="#cb18-921"></a><span class="in">    # 2. Lasso</span></span>
<span id="cb18-922"><a href="#cb18-922"></a><span class="in">    # one multinomial or binomial class has fewer than 8  observations; dangerous ground</span></span>
<span id="cb18-923"><a href="#cb18-923"></a><span class="in">    dt.cv.lasso&lt;-lapply(names(li.fold), function(my.fold){</span></span>
<span id="cb18-924"><a href="#cb18-924"></a><span class="in">      message(paste("Num:",my.num,"Method: LASSO, Fold:",my.fold))</span></span>
<span id="cb18-925"><a href="#cb18-925"></a><span class="in">      my.tr.index&lt;-li.fold[[my.fold]] # index of training </span></span>
<span id="cb18-926"><a href="#cb18-926"></a><span class="in">      x&lt;-li.mat[["train"]][["28wk"]][my.tr.index,] # the training dataset</span></span>
<span id="cb18-927"><a href="#cb18-927"></a><span class="in">      get_lasso_coef(x, my.fold, my.num=my.num) </span></span>
<span id="cb18-928"><a href="#cb18-928"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-929"><a href="#cb18-929"></a></span>
<span id="cb18-930"><a href="#cb18-930"></a><span class="in">    # 3. ElasticNet</span></span>
<span id="cb18-931"><a href="#cb18-931"></a><span class="in">    # warnings(): one multinomial or binomial class has fewer than 8  observations; dangerous ground</span></span>
<span id="cb18-932"><a href="#cb18-932"></a><span class="in">    dt.cv.enet&lt;-lapply(names(li.fold), function(my.fold){</span></span>
<span id="cb18-933"><a href="#cb18-933"></a><span class="in">      message(paste("Num:",my.num,"Method: ENET, Fold:",my.fold))</span></span>
<span id="cb18-934"><a href="#cb18-934"></a><span class="in">      my.tr.index&lt;-li.fold[[my.fold]] # index of training </span></span>
<span id="cb18-935"><a href="#cb18-935"></a><span class="in">      x&lt;-li.mat[["train"]][["28wk"]][my.tr.index,] # the training dataset </span></span>
<span id="cb18-936"><a href="#cb18-936"></a><span class="in">      get_enet_coef(x, my.fold, my.num=my.num) </span></span>
<span id="cb18-937"><a href="#cb18-937"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-938"><a href="#cb18-938"></a></span>
<span id="cb18-939"><a href="#cb18-939"></a><span class="in">    # 4. mSVM-RFE</span></span>
<span id="cb18-940"><a href="#cb18-940"></a><span class="in">    dt.cv.svm&lt;-lapply(names(li.fold), function(my.fold){</span></span>
<span id="cb18-941"><a href="#cb18-941"></a><span class="in">      message(paste("Num:",my.num,"Method: mSVM-RFE, Fold:",my.fold))</span></span>
<span id="cb18-942"><a href="#cb18-942"></a><span class="in">      my.tr.index&lt;-li.fold[[my.fold]] # index of training </span></span>
<span id="cb18-943"><a href="#cb18-943"></a><span class="in">      x&lt;-li.mat[["train"]][["28wk"]][my.tr.index,] # the training dataset </span></span>
<span id="cb18-944"><a href="#cb18-944"></a><span class="in">      set.seed(333)</span></span>
<span id="cb18-945"><a href="#cb18-945"></a><span class="in">      ranked.features&lt;-colnames(x)[-1][svmRFE(x, k=5, halve.above=100)][1:my.num] # only top x ranked features</span></span>
<span id="cb18-946"><a href="#cb18-946"></a><span class="in">      data.table(method="mSVM-RFE",`fold`=my.fold,feature=ranked.features, score=NA,rank=1:length(ranked.features))</span></span>
<span id="cb18-947"><a href="#cb18-947"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-948"><a href="#cb18-948"></a></span>
<span id="cb18-949"><a href="#cb18-949"></a><span class="in">    # 5-10. Other methods via RFE</span></span>
<span id="cb18-950"><a href="#cb18-950"></a><span class="in">    dt.cv.rfe&lt;-lapply(names(li.methods), function(my.method){</span></span>
<span id="cb18-951"><a href="#cb18-951"></a><span class="in">              # runRFE2 for each repetition</span></span>
<span id="cb18-952"><a href="#cb18-952"></a><span class="in">              lapply(paste0("Rep",1:5), function(iRep){</span></span>
<span id="cb18-953"><a href="#cb18-953"></a><span class="in">                this.fold&lt;-paste(paste0("Fold",1:5),iRep,sep=".") # 5-fold for this repetition</span></span>
<span id="cb18-954"><a href="#cb18-954"></a><span class="in">                message(paste("Num:",my.num,"Method:",my.method, "Fold:",this.fold))</span></span>
<span id="cb18-955"><a href="#cb18-955"></a></span>
<span id="cb18-956"><a href="#cb18-956"></a><span class="in">                runRFE2(x=li.mat[["train"]][["28wk"]], my.method=my.method, my.num=my.num, my.index=li.fold[this.fold])</span></span>
<span id="cb18-957"><a href="#cb18-957"></a><span class="in">              }) %&gt;% rbindlist</span></span>
<span id="cb18-958"><a href="#cb18-958"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-959"><a href="#cb18-959"></a></span>
<span id="cb18-960"><a href="#cb18-960"></a><span class="in">    rbind(dt.cv.glp, dt.cv.lasso[method=="LASSO"], dt.cv.enet, dt.cv.svm, dt.cv.rfe)</span></span>
<span id="cb18-961"><a href="#cb18-961"></a><span class="in">  }) # end of dl.kcv</span></span>
<span id="cb18-962"><a href="#cb18-962"></a></span>
<span id="cb18-963"><a href="#cb18-963"></a><span class="in">  save(dl.kcv, file=my.RData)</span></span>
<span id="cb18-964"><a href="#cb18-964"></a><span class="in">}</span></span>
<span id="cb18-965"><a href="#cb18-965"></a></span>
<span id="cb18-966"><a href="#cb18-966"></a><span class="in">##</span></span>
<span id="cb18-967"><a href="#cb18-967"></a><span class="in">##</span></span>
<span id="cb18-968"><a href="#cb18-968"></a><span class="in">my.RData&lt;-file.path("RData/dl.kcv.result.core17.RData")</span></span>
<span id="cb18-969"><a href="#cb18-969"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-970"><a href="#cb18-970"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-971"><a href="#cb18-971"></a><span class="in">}else{</span></span>
<span id="cb18-972"><a href="#cb18-972"></a><span class="in">  # for each number of feature: F2, F3, F4, F5, F6</span></span>
<span id="cb18-973"><a href="#cb18-973"></a><span class="in">  dl.kcv.result&lt;-parallel::mclapply(dl.kcv, function(dt.kcv){</span></span>
<span id="cb18-974"><a href="#cb18-974"></a><span class="in">    # features by method and fold</span></span>
<span id="cb18-975"><a href="#cb18-975"></a><span class="in">    dt.foo&lt;-dt.kcv[order(method,fold,feature)][,.(.N,features=paste(feature,collapse=",")),.(method,fold)]</span></span>
<span id="cb18-976"><a href="#cb18-976"></a><span class="in">    my.num&lt;-dt.foo[,unique(N)]</span></span>
<span id="cb18-977"><a href="#cb18-977"></a></span>
<span id="cb18-978"><a href="#cb18-978"></a><span class="in">    # features by method, fold and features</span></span>
<span id="cb18-979"><a href="#cb18-979"></a><span class="in">    dt.bar&lt;-dt.kcv[order(method,fold,feature)][,.(.N,features=paste(feature,collapse=",")),.(method,fold)][,.(.N,methods=paste(method,collapse=",")),.(fold,features)][order(fold,-N)]</span></span>
<span id="cb18-980"><a href="#cb18-980"></a></span>
<span id="cb18-981"><a href="#cb18-981"></a><span class="in">    # get the CV-LPOCV (or CV-AUC) across 25 folds (i.e. 5-Fold-CV * 5 Rep) </span></span>
<span id="cb18-982"><a href="#cb18-982"></a><span class="in">    dl.bar&lt;-split(dt.bar, dt.bar$fold) # by each fold</span></span>
<span id="cb18-983"><a href="#cb18-983"></a><span class="in">    dt.kcv.result&lt;-parallel::mclapply(dl.bar, function(dt.baz){</span></span>
<span id="cb18-984"><a href="#cb18-984"></a><span class="in">      my.fold&lt;-dt.baz[,.N,fold]$fold</span></span>
<span id="cb18-985"><a href="#cb18-985"></a><span class="in">      my.index&lt;-li.fold[[my.fold]] # index of training</span></span>
<span id="cb18-986"><a href="#cb18-986"></a></span>
<span id="cb18-987"><a href="#cb18-987"></a><span class="in">      # for each list of features in this fold</span></span>
<span id="cb18-988"><a href="#cb18-988"></a><span class="in">      lapply(dt.baz$features, function(i){</span></span>
<span id="cb18-989"><a href="#cb18-989"></a><span class="in">        message(paste("Num:",my.num,", Fold:",my.fold, ", Features:",i))</span></span>
<span id="cb18-990"><a href="#cb18-990"></a><span class="in">        my.feature &lt;- i %&gt;% strsplit(",") %&gt;% unlist</span></span>
<span id="cb18-991"><a href="#cb18-991"></a><span class="in">        get_cv_glm(x=li.mat[["train"]][["28wk"]],my.fold,my.index,my.feature)</span></span>
<span id="cb18-992"><a href="#cb18-992"></a><span class="in">      }) %&gt;% rbindlist # merge all features</span></span>
<span id="cb18-993"><a href="#cb18-993"></a><span class="in">    },mc.cores=1) %&gt;% rbindlist # merge all fold</span></span>
<span id="cb18-994"><a href="#cb18-994"></a></span>
<span id="cb18-995"><a href="#cb18-995"></a><span class="in">    merge(dt.foo, dt.kcv.result, by.x=c("fold","features"), by.y=c("fold","predictor"))</span></span>
<span id="cb18-996"><a href="#cb18-996"></a><span class="in">  },mc.cores=1) # parallel by the No. of features</span></span>
<span id="cb18-997"><a href="#cb18-997"></a><span class="in">  save(dl.kcv.result, file=my.RData)</span></span>
<span id="cb18-998"><a href="#cb18-998"></a><span class="in">}</span></span>
<span id="cb18-999"><a href="#cb18-999"></a><span class="in">```</span></span>
<span id="cb18-1000"><a href="#cb18-1000"></a></span>
<span id="cb18-1001"><a href="#cb18-1001"></a>Having selected a set of predictors for each of the 11 ML methods, a logistic regression model was fitted on the training fold based on the selected predictors, and its predictive performance, i.e. the AUC, was calculated using the remaining held-out test fold. As the 5-fold CV was repeated 5 times, the 25 cross-validated AUCs were averaged by taking the mean AUC. This procedure was repeated from a selection of 2- to 6-predictor models, i.e. 5 times, so the cross-validated AUCs were again averaged by taking the mean values of AUCs. </span>
<span id="cb18-1002"><a href="#cb18-1002"></a></span>
<span id="cb18-1003"><a href="#cb18-1003"></a><span class="in">```{r kcv_all_method_final_model1}</span></span>
<span id="cb18-1004"><a href="#cb18-1004"></a><span class="in">#| label: kcv-all-final</span></span>
<span id="cb18-1005"><a href="#cb18-1005"></a><span class="in">#| eval: false</span></span>
<span id="cb18-1006"><a href="#cb18-1006"></a><span class="in">#| code-summary: Code to extract the final selected features from each ML method and fit a regression model and test its performance.</span></span>
<span id="cb18-1007"><a href="#cb18-1007"></a><span class="in">my.RData&lt;-file.path("RData/dl.final.models.core17.RData")</span></span>
<span id="cb18-1008"><a href="#cb18-1008"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-1009"><a href="#cb18-1009"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-1010"><a href="#cb18-1010"></a><span class="in">}else{</span></span>
<span id="cb18-1011"><a href="#cb18-1011"></a><span class="in">  library(e1071)</span></span>
<span id="cb18-1012"><a href="#cb18-1012"></a><span class="in">  source('SVM-RFE/msvmRFE.R')</span></span>
<span id="cb18-1013"><a href="#cb18-1013"></a></span>
<span id="cb18-1014"><a href="#cb18-1014"></a><span class="in">  li.methods&lt;-list(</span></span>
<span id="cb18-1015"><a href="#cb18-1015"></a><span class="in">    `svmLinear`="svmLinear",</span></span>
<span id="cb18-1016"><a href="#cb18-1016"></a><span class="in">    `svmRadial`="svmRadial",</span></span>
<span id="cb18-1017"><a href="#cb18-1017"></a><span class="in">    `nnet`="nnet",</span></span>
<span id="cb18-1018"><a href="#cb18-1018"></a><span class="in">    `pcaNNet`="pcaNNet",</span></span>
<span id="cb18-1019"><a href="#cb18-1019"></a><span class="in">    `rfFuncs`=rfFuncs,</span></span>
<span id="cb18-1020"><a href="#cb18-1020"></a><span class="in">    `nbFuncs`=nbFuncs</span></span>
<span id="cb18-1021"><a href="#cb18-1021"></a><span class="in">    )</span></span>
<span id="cb18-1022"><a href="#cb18-1022"></a></span>
<span id="cb18-1023"><a href="#cb18-1023"></a><span class="in">  li.num&lt;-list(`F2`=2,`F3`=3,`F4`=4,`F5`=5,`F6`=6)</span></span>
<span id="cb18-1024"><a href="#cb18-1024"></a><span class="in">  x&lt;-li.mat[["train"]][["28wk"]]</span></span>
<span id="cb18-1025"><a href="#cb18-1025"></a></span>
<span id="cb18-1026"><a href="#cb18-1026"></a><span class="in">  dl.final.models&lt;-lapply(li.num, function(my.num){</span></span>
<span id="cb18-1027"><a href="#cb18-1027"></a><span class="in">    # 1. glParallel</span></span>
<span id="cb18-1028"><a href="#cb18-1028"></a><span class="in">    message(paste("Num:",my.num,"Method: glParallel"))</span></span>
<span id="cb18-1029"><a href="#cb18-1029"></a><span class="in">    my.pattern=paste0("^core17\\.final\\.best",my.num)</span></span>
<span id="cb18-1030"><a href="#cb18-1030"></a><span class="in">    dt.input&lt;-data.table(</span></span>
<span id="cb18-1031"><a href="#cb18-1031"></a><span class="in">                    foo=list.files("glParallel/result",pattern=my.pattern),</span></span>
<span id="cb18-1032"><a href="#cb18-1032"></a><span class="in">                    files=list.files("glParallel/result",pattern=my.pattern,full.names=T)</span></span>
<span id="cb18-1033"><a href="#cb18-1033"></a><span class="in">                    )[,c("foo1","bar1"):=tstrsplit(foo,"\\.",keep=c(2,3))][,fold:=paste(foo1,bar1,sep=".")][,c("foo","foo1","bar1"):=NULL]</span></span>
<span id="cb18-1034"><a href="#cb18-1034"></a></span>
<span id="cb18-1035"><a href="#cb18-1035"></a><span class="in">    dt.glp &lt;-apply(dt.input, 1, function(i){</span></span>
<span id="cb18-1036"><a href="#cb18-1036"></a><span class="in">              my.fold&lt;-i[["fold"]]</span></span>
<span id="cb18-1037"><a href="#cb18-1037"></a><span class="in">              my.feature&lt;-fread(i["files"])[1][["Best proteins"]] %&gt;% strsplit(",") %&gt;% unlist</span></span>
<span id="cb18-1038"><a href="#cb18-1038"></a><span class="in">              data.table(method="glParallel",fold=my.fold,feature=my.feature,score=NA,rank=NA)</span></span>
<span id="cb18-1039"><a href="#cb18-1039"></a><span class="in">              #cbind(`fold`=i[["fold"]],fread(i["files"])[1])</span></span>
<span id="cb18-1040"><a href="#cb18-1040"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-1041"><a href="#cb18-1041"></a></span>
<span id="cb18-1042"><a href="#cb18-1042"></a><span class="in">    # 2. Lasso</span></span>
<span id="cb18-1043"><a href="#cb18-1043"></a><span class="in">    message(paste("Num:",my.num,"Method: LASSO"))</span></span>
<span id="cb18-1044"><a href="#cb18-1044"></a><span class="in">    dt.lasso&lt;-get_lasso_coef(x=x, "final", my.num=my.num)</span></span>
<span id="cb18-1045"><a href="#cb18-1045"></a></span>
<span id="cb18-1046"><a href="#cb18-1046"></a><span class="in">    # 3. ElasticNet</span></span>
<span id="cb18-1047"><a href="#cb18-1047"></a><span class="in">    message(paste("Num:",my.num,"Method: ENET"))</span></span>
<span id="cb18-1048"><a href="#cb18-1048"></a><span class="in">    dt.enet&lt;-get_enet_coef(x=x, "final", my.num=my.num)</span></span>
<span id="cb18-1049"><a href="#cb18-1049"></a></span>
<span id="cb18-1050"><a href="#cb18-1050"></a><span class="in">    # 4. mSVM-RFE</span></span>
<span id="cb18-1051"><a href="#cb18-1051"></a><span class="in">    message(paste("Num:",my.num,"Method: mSVM-RFE"))</span></span>
<span id="cb18-1052"><a href="#cb18-1052"></a><span class="in">    set.seed(333)</span></span>
<span id="cb18-1053"><a href="#cb18-1053"></a><span class="in">    ranked.features&lt;-colnames(x)[-1][svmRFE(x, k=5, halve.above=100)][1:my.num] # only top 4 ranked features</span></span>
<span id="cb18-1054"><a href="#cb18-1054"></a><span class="in">    dt.svm&lt;-data.table(method="mSVM-RFE",`fold`="final",feature=ranked.features, score=NA, rank=1:length(ranked.features))</span></span>
<span id="cb18-1055"><a href="#cb18-1055"></a></span>
<span id="cb18-1056"><a href="#cb18-1056"></a><span class="in">    # 5-10. Other methods via RFE: "svmLinear" "svmRadial" "nnet"      "pcaNNet"   "rfFuncs"   "nbFuncs"</span></span>
<span id="cb18-1057"><a href="#cb18-1057"></a><span class="in">    dt.rfe&lt;-lapply(names(li.methods), function(my.method){</span></span>
<span id="cb18-1058"><a href="#cb18-1058"></a><span class="in">              message(paste("Num:",my.num,"Method:",my.method))</span></span>
<span id="cb18-1059"><a href="#cb18-1059"></a><span class="in">              runRFE2(x=x, my.method=my.method, my.num=my.num, my.index=li.fold.final, is.final=T)</span></span>
<span id="cb18-1060"><a href="#cb18-1060"></a><span class="in">    }) %&gt;% rbindlist</span></span>
<span id="cb18-1061"><a href="#cb18-1061"></a></span>
<span id="cb18-1062"><a href="#cb18-1062"></a><span class="in">    # compile all the final models #</span></span>
<span id="cb18-1063"><a href="#cb18-1063"></a><span class="in">    rbind(dt.glp, dt.lasso[method=="LASSO"], dt.enet, dt.svm, dt.rfe)[order(method,feature)]</span></span>
<span id="cb18-1064"><a href="#cb18-1064"></a><span class="in">  }) # end of dl.final.models</span></span>
<span id="cb18-1065"><a href="#cb18-1065"></a><span class="in">  save(dl.final.models, file=my.RData)</span></span>
<span id="cb18-1066"><a href="#cb18-1066"></a><span class="in">} # end of if</span></span>
<span id="cb18-1067"><a href="#cb18-1067"></a></span>
<span id="cb18-1068"><a href="#cb18-1068"></a><span class="in">my.RData&lt;-file.path("RData/dl.final.result.core17.RData")</span></span>
<span id="cb18-1069"><a href="#cb18-1069"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-1070"><a href="#cb18-1070"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-1071"><a href="#cb18-1071"></a><span class="in">}else{</span></span>
<span id="cb18-1072"><a href="#cb18-1072"></a><span class="in">  mat.tr&lt;-li.mat[["train"]][["28wk"]] # training model</span></span>
<span id="cb18-1073"><a href="#cb18-1073"></a></span>
<span id="cb18-1074"><a href="#cb18-1074"></a><span class="in">  dl.final.result&lt;-lapply(dl.final.models, function(dt.model){</span></span>
<span id="cb18-1075"><a href="#cb18-1075"></a><span class="in">    dt.final.model&lt;-dt.model[,.(.N,features=paste(feature,collapse=",")),method][order(features)]</span></span>
<span id="cb18-1076"><a href="#cb18-1076"></a><span class="in">    dt.final&lt;-dt.final.model[,.(.N,methods=paste(method,collapse=',')),features]</span></span>
<span id="cb18-1077"><a href="#cb18-1077"></a></span>
<span id="cb18-1078"><a href="#cb18-1078"></a><span class="in">    #######################################################################</span></span>
<span id="cb18-1079"><a href="#cb18-1079"></a><span class="in">    # get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb18-1080"><a href="#cb18-1080"></a><span class="in">    #######################################################################</span></span>
<span id="cb18-1081"><a href="#cb18-1081"></a><span class="in">    dt.final.result&lt;-lapply(dt.final$methods, function(my.methods){</span></span>
<span id="cb18-1082"><a href="#cb18-1082"></a><span class="in">                          ############################################</span></span>
<span id="cb18-1083"><a href="#cb18-1083"></a><span class="in">                          # fit the model using the training dataset #</span></span>
<span id="cb18-1084"><a href="#cb18-1084"></a><span class="in">                          ############################################</span></span>
<span id="cb18-1085"><a href="#cb18-1085"></a><span class="in">                          my.feature&lt;-dt.final[methods==my.methods]$features %&gt;% strsplit(",") %&gt;% unlist</span></span>
<span id="cb18-1086"><a href="#cb18-1086"></a><span class="in">                          df.mat.tr&lt;-mat.tr[,c(my.feature,'y')] %&gt;% as.data.frame  # training set</span></span>
<span id="cb18-1087"><a href="#cb18-1087"></a><span class="in">                          my.model&lt;-glm(y~. , data = df.mat.tr, family = "binomial")</span></span>
<span id="cb18-1088"><a href="#cb18-1088"></a></span>
<span id="cb18-1089"><a href="#cb18-1089"></a><span class="in">                          ## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb18-1090"><a href="#cb18-1090"></a><span class="in">                          dt.foo1&lt;-lapply(c("12wk","20wk","28wk"), function(my.GA){</span></span>
<span id="cb18-1091"><a href="#cb18-1091"></a><span class="in">                            message(paste("preterm",my.methods,my.GA,sep=":"))</span></span>
<span id="cb18-1092"><a href="#cb18-1092"></a><span class="in">                            x&lt;-li.mat[["train"]][[my.GA]]</span></span>
<span id="cb18-1093"><a href="#cb18-1093"></a><span class="in">                            my.fold&lt;-paste0(my.GA,"(preterm)")</span></span>
<span id="cb18-1094"><a href="#cb18-1094"></a><span class="in">                            cbind(`methods`=my.methods,</span></span>
<span id="cb18-1095"><a href="#cb18-1095"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1096"><a href="#cb18-1096"></a><span class="in">                            )</span></span>
<span id="cb18-1097"><a href="#cb18-1097"></a><span class="in">                          }) %&gt;% rbindlist</span></span>
<span id="cb18-1098"><a href="#cb18-1098"></a></span>
<span id="cb18-1099"><a href="#cb18-1099"></a><span class="in">                          ## term (validation)</span></span>
<span id="cb18-1100"><a href="#cb18-1100"></a><span class="in">                          dt.foo2&lt;-lapply(c("12wk","20wk","28wk","36wk"), function(my.GA){</span></span>
<span id="cb18-1101"><a href="#cb18-1101"></a><span class="in">                            message(paste("term",my.methods,my.GA,sep=":"))</span></span>
<span id="cb18-1102"><a href="#cb18-1102"></a><span class="in">                            x&lt;-li.mat[["test"]][[my.GA]]</span></span>
<span id="cb18-1103"><a href="#cb18-1103"></a><span class="in">                            my.fold&lt;-paste0(my.GA,"(term)")</span></span>
<span id="cb18-1104"><a href="#cb18-1104"></a><span class="in">                            cbind(`methods`=my.methods,</span></span>
<span id="cb18-1105"><a href="#cb18-1105"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1106"><a href="#cb18-1106"></a><span class="in">                            )</span></span>
<span id="cb18-1107"><a href="#cb18-1107"></a><span class="in">                          }) %&gt;% rbindlist</span></span>
<span id="cb18-1108"><a href="#cb18-1108"></a><span class="in">                          </span></span>
<span id="cb18-1109"><a href="#cb18-1109"></a><span class="in">                          ## Munchel </span></span>
<span id="cb18-1110"><a href="#cb18-1110"></a><span class="in">                          message(paste("Munchel",my.methods,sep=":"))</span></span>
<span id="cb18-1111"><a href="#cb18-1111"></a><span class="in">                          x&lt;-li.mat[["munchel"]]</span></span>
<span id="cb18-1112"><a href="#cb18-1112"></a><span class="in">                          my.fold&lt;-"Munchel"</span></span>
<span id="cb18-1113"><a href="#cb18-1113"></a><span class="in">                          dt.foo3&lt;-cbind(`methods`=my.methods,</span></span>
<span id="cb18-1114"><a href="#cb18-1114"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1115"><a href="#cb18-1115"></a><span class="in">                          )</span></span>
<span id="cb18-1116"><a href="#cb18-1116"></a></span>
<span id="cb18-1117"><a href="#cb18-1117"></a><span class="in">                          rbind(dt.foo1,dt.foo2,dt.foo3)</span></span>
<span id="cb18-1118"><a href="#cb18-1118"></a><span class="in">                      }) %&gt;% rbindlist</span></span>
<span id="cb18-1119"><a href="#cb18-1119"></a><span class="in">    dt.final.result&lt;-dt.final.result[order(fold,-AUC_test)]</span></span>
<span id="cb18-1120"><a href="#cb18-1120"></a><span class="in">    dt.final.result</span></span>
<span id="cb18-1121"><a href="#cb18-1121"></a><span class="in">  })</span></span>
<span id="cb18-1122"><a href="#cb18-1122"></a><span class="in">  save(dl.final.result, file=my.RData)</span></span>
<span id="cb18-1123"><a href="#cb18-1123"></a><span class="in">}</span></span>
<span id="cb18-1124"><a href="#cb18-1124"></a><span class="in">```</span></span>
<span id="cb18-1125"><a href="#cb18-1125"></a></span>
<span id="cb18-1126"><a href="#cb18-1126"></a><span class="fu">## Internal and external validation {#sec-validation}</span></span>
<span id="cb18-1127"><a href="#cb18-1127"></a></span>
<span id="cb18-1128"><a href="#cb18-1128"></a>Having identified the winning method (as shown in @fig-fig3 A), it was applied to choose 2 to 10 predictors using the whole 28wkGA samples of the discovery dataset and the selected predictors were used to fit multivariate logistic regression models using the same training dataset (@fig-fig3 B). Finally, we evaluated the predictive performance of those 2- to 10-predictor logistic regression models using the term validation cohort and the external Munchel dataset (as shown in @fig-fig4).</span>
<span id="cb18-1129"><a href="#cb18-1129"></a></span>
<span id="cb18-1130"><a href="#cb18-1130"></a><span class="in">```{r kcv_enet_lasso_tr_val1}</span></span>
<span id="cb18-1131"><a href="#cb18-1131"></a><span class="in">#| label: kcv-winner</span></span>
<span id="cb18-1132"><a href="#cb18-1132"></a><span class="in">#| eval: false</span></span>
<span id="cb18-1133"><a href="#cb18-1133"></a><span class="in">#| code-summary: Code to run internal and external validations for 2-10 predictors chosen by the winning method of 5-fold CV.</span></span>
<span id="cb18-1134"><a href="#cb18-1134"></a><span class="in">my.RData&lt;-file.path("RData/dl.enet.models.core17.RData")</span></span>
<span id="cb18-1135"><a href="#cb18-1135"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-1136"><a href="#cb18-1136"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-1137"><a href="#cb18-1137"></a><span class="in">}else{</span></span>
<span id="cb18-1138"><a href="#cb18-1138"></a><span class="in">  li.num&lt;-2:10 %&gt;% as.list</span></span>
<span id="cb18-1139"><a href="#cb18-1139"></a><span class="in">  names(li.num)=paste0("F",2:10)</span></span>
<span id="cb18-1140"><a href="#cb18-1140"></a></span>
<span id="cb18-1141"><a href="#cb18-1141"></a><span class="in">  x&lt;-li.mat[["train"]][["28wk"]]</span></span>
<span id="cb18-1142"><a href="#cb18-1142"></a></span>
<span id="cb18-1143"><a href="#cb18-1143"></a><span class="in">  dl.enet.models&lt;-lapply(li.num, function(my.num){</span></span>
<span id="cb18-1144"><a href="#cb18-1144"></a><span class="in">    # 2. Lasso</span></span>
<span id="cb18-1145"><a href="#cb18-1145"></a><span class="in">    message(paste("Num:",my.num,"Method: LASSO"))</span></span>
<span id="cb18-1146"><a href="#cb18-1146"></a><span class="in">    dt.lasso&lt;-get_lasso_coef(x=x, "final", my.num=my.num)</span></span>
<span id="cb18-1147"><a href="#cb18-1147"></a></span>
<span id="cb18-1148"><a href="#cb18-1148"></a><span class="in">    # 3. ElasticNet</span></span>
<span id="cb18-1149"><a href="#cb18-1149"></a><span class="in">    message(paste("Num:",my.num,"Method: ENET"))</span></span>
<span id="cb18-1150"><a href="#cb18-1150"></a><span class="in">    dt.enet&lt;-get_enet_coef(x=x, "final", my.num=my.num)</span></span>
<span id="cb18-1151"><a href="#cb18-1151"></a></span>
<span id="cb18-1152"><a href="#cb18-1152"></a><span class="in">    # compile all the final models #</span></span>
<span id="cb18-1153"><a href="#cb18-1153"></a><span class="in">    rbind(dt.lasso[method=="LASSO"], dt.enet)[order(method,feature)]</span></span>
<span id="cb18-1154"><a href="#cb18-1154"></a><span class="in">  }) # end of dl.final.models</span></span>
<span id="cb18-1155"><a href="#cb18-1155"></a><span class="in">  save(dl.enet.models, file=my.RData)</span></span>
<span id="cb18-1156"><a href="#cb18-1156"></a><span class="in">} # end of if</span></span>
<span id="cb18-1157"><a href="#cb18-1157"></a></span>
<span id="cb18-1158"><a href="#cb18-1158"></a><span class="in">##</span></span>
<span id="cb18-1159"><a href="#cb18-1159"></a><span class="in">## ENet and LASSO only using Discovery and Validation datasets</span></span>
<span id="cb18-1160"><a href="#cb18-1160"></a><span class="in">## </span></span>
<span id="cb18-1161"><a href="#cb18-1161"></a><span class="in">my.RData&lt;-file.path("RData/dl.enet.result.core17.RData")</span></span>
<span id="cb18-1162"><a href="#cb18-1162"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-1163"><a href="#cb18-1163"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-1164"><a href="#cb18-1164"></a><span class="in">}else{</span></span>
<span id="cb18-1165"><a href="#cb18-1165"></a><span class="in">  mat.tr&lt;-li.mat[["train"]][["28wk"]] # training model</span></span>
<span id="cb18-1166"><a href="#cb18-1166"></a></span>
<span id="cb18-1167"><a href="#cb18-1167"></a><span class="in">  dl.enet.result&lt;-lapply(dl.enet.models, function(dt.model){</span></span>
<span id="cb18-1168"><a href="#cb18-1168"></a><span class="in">    dt.final.model&lt;-dt.model[,.(.N,features=paste(feature,collapse=",")),method][order(features)]</span></span>
<span id="cb18-1169"><a href="#cb18-1169"></a><span class="in">    dt.final&lt;-dt.final.model[,.(.N,methods=paste(method,collapse=',')),features]</span></span>
<span id="cb18-1170"><a href="#cb18-1170"></a><span class="in">    #######################################################################</span></span>
<span id="cb18-1171"><a href="#cb18-1171"></a><span class="in">    # get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb18-1172"><a href="#cb18-1172"></a><span class="in">    #######################################################################</span></span>
<span id="cb18-1173"><a href="#cb18-1173"></a><span class="in">    dt.final.result&lt;-lapply(dt.final$methods, function(my.methods){</span></span>
<span id="cb18-1174"><a href="#cb18-1174"></a><span class="in">                          ############################################</span></span>
<span id="cb18-1175"><a href="#cb18-1175"></a><span class="in">                          # fit the model using the training dataset #</span></span>
<span id="cb18-1176"><a href="#cb18-1176"></a><span class="in">                          ############################################</span></span>
<span id="cb18-1177"><a href="#cb18-1177"></a><span class="in">                          my.feature&lt;-dt.final[methods==my.methods]$features %&gt;% strsplit(",") %&gt;% unlist</span></span>
<span id="cb18-1178"><a href="#cb18-1178"></a><span class="in">                          df.mat.tr&lt;-mat.tr[,c(my.feature,'y')] %&gt;% as.data.frame  # training set</span></span>
<span id="cb18-1179"><a href="#cb18-1179"></a><span class="in">                          my.model&lt;-glm(y~. , data = df.mat.tr, family = "binomial")</span></span>
<span id="cb18-1180"><a href="#cb18-1180"></a></span>
<span id="cb18-1181"><a href="#cb18-1181"></a><span class="in">                          ## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb18-1182"><a href="#cb18-1182"></a><span class="in">                          dt.foo1&lt;-lapply(c("12wk","20wk","28wk"), function(my.GA){</span></span>
<span id="cb18-1183"><a href="#cb18-1183"></a><span class="in">                            message(paste("preterm",my.methods,my.GA,sep=":"))</span></span>
<span id="cb18-1184"><a href="#cb18-1184"></a><span class="in">                            x&lt;-li.mat[["train"]][[my.GA]]</span></span>
<span id="cb18-1185"><a href="#cb18-1185"></a><span class="in">                            my.fold&lt;-paste0(my.GA,"(preterm)")</span></span>
<span id="cb18-1186"><a href="#cb18-1186"></a><span class="in">                            cbind(`methods`=my.methods,</span></span>
<span id="cb18-1187"><a href="#cb18-1187"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1188"><a href="#cb18-1188"></a><span class="in">                            )</span></span>
<span id="cb18-1189"><a href="#cb18-1189"></a><span class="in">                          }) %&gt;% rbindlist</span></span>
<span id="cb18-1190"><a href="#cb18-1190"></a></span>
<span id="cb18-1191"><a href="#cb18-1191"></a><span class="in">                          ## term (validation)</span></span>
<span id="cb18-1192"><a href="#cb18-1192"></a><span class="in">                          dt.foo2&lt;-lapply(c("12wk","20wk","28wk","36wk"), function(my.GA){</span></span>
<span id="cb18-1193"><a href="#cb18-1193"></a><span class="in">                            message(paste("term",my.methods,my.GA,sep=":"))</span></span>
<span id="cb18-1194"><a href="#cb18-1194"></a><span class="in">                            x&lt;-li.mat[["test"]][[my.GA]]</span></span>
<span id="cb18-1195"><a href="#cb18-1195"></a><span class="in">                            my.fold&lt;-paste0(my.GA,"(term)")</span></span>
<span id="cb18-1196"><a href="#cb18-1196"></a><span class="in">                            cbind(`methods`=my.methods,</span></span>
<span id="cb18-1197"><a href="#cb18-1197"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1198"><a href="#cb18-1198"></a><span class="in">                            )</span></span>
<span id="cb18-1199"><a href="#cb18-1199"></a><span class="in">                          }) %&gt;% rbindlist</span></span>
<span id="cb18-1200"><a href="#cb18-1200"></a><span class="in">                          </span></span>
<span id="cb18-1201"><a href="#cb18-1201"></a><span class="in">                          ## Munchel </span></span>
<span id="cb18-1202"><a href="#cb18-1202"></a><span class="in">                          message(paste("Munchel",my.methods,sep=":"))</span></span>
<span id="cb18-1203"><a href="#cb18-1203"></a><span class="in">                          x&lt;-li.mat[["munchel"]]</span></span>
<span id="cb18-1204"><a href="#cb18-1204"></a><span class="in">                          my.fold&lt;-"Munchel"</span></span>
<span id="cb18-1205"><a href="#cb18-1205"></a><span class="in">                          dt.foo3&lt;-cbind(`methods`=my.methods,</span></span>
<span id="cb18-1206"><a href="#cb18-1206"></a><span class="in">                                  get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1207"><a href="#cb18-1207"></a><span class="in">                          )</span></span>
<span id="cb18-1208"><a href="#cb18-1208"></a></span>
<span id="cb18-1209"><a href="#cb18-1209"></a><span class="in">                          rbind(dt.foo1,dt.foo2,dt.foo3)</span></span>
<span id="cb18-1210"><a href="#cb18-1210"></a><span class="in">                      }) %&gt;% rbindlist</span></span>
<span id="cb18-1211"><a href="#cb18-1211"></a><span class="in">    dt.final.result&lt;-dt.final.result[order(fold,-AUC_test)]</span></span>
<span id="cb18-1212"><a href="#cb18-1212"></a><span class="in">    dt.final.result</span></span>
<span id="cb18-1213"><a href="#cb18-1213"></a><span class="in">  }) # end of dl.enet.models</span></span>
<span id="cb18-1214"><a href="#cb18-1214"></a><span class="in">  save(dl.enet.result, file=my.RData)</span></span>
<span id="cb18-1215"><a href="#cb18-1215"></a><span class="in">}</span></span>
<span id="cb18-1216"><a href="#cb18-1216"></a></span>
<span id="cb18-1217"><a href="#cb18-1217"></a><span class="in">#</span></span>
<span id="cb18-1218"><a href="#cb18-1218"></a><span class="in"># The final best models</span></span>
<span id="cb18-1219"><a href="#cb18-1219"></a><span class="in">#</span></span>
<span id="cb18-1220"><a href="#cb18-1220"></a><span class="in">my.RData&lt;-file.path("RData/dt.best.result.core17.RData")</span></span>
<span id="cb18-1221"><a href="#cb18-1221"></a><span class="in">if(file.exists(my.RData)){</span></span>
<span id="cb18-1222"><a href="#cb18-1222"></a><span class="in">  load(my.RData)</span></span>
<span id="cb18-1223"><a href="#cb18-1223"></a><span class="in">}else{</span></span>
<span id="cb18-1224"><a href="#cb18-1224"></a><span class="in">  my.targets&lt;-c("LEP","PAPPA2","LEP,PAPPA2",</span></span>
<span id="cb18-1225"><a href="#cb18-1225"></a><span class="in">                "LEP,LY6G6D,PAPPA2" # best performing LASSO 3-mRNA model</span></span>
<span id="cb18-1226"><a href="#cb18-1226"></a><span class="in">                )</span></span>
<span id="cb18-1227"><a href="#cb18-1227"></a></span>
<span id="cb18-1228"><a href="#cb18-1228"></a><span class="in">  mat.tr&lt;-li.mat[["train"]][["28wk"]] # training model</span></span>
<span id="cb18-1229"><a href="#cb18-1229"></a><span class="in">  mat.tr&lt;-cbind(mat.tr, "LEP_PAPPA2"=mat.tr[,"LEP"] * mat.tr[,"PAPPA2"])</span></span>
<span id="cb18-1230"><a href="#cb18-1230"></a></span>
<span id="cb18-1231"><a href="#cb18-1231"></a><span class="in">  #######################################################################</span></span>
<span id="cb18-1232"><a href="#cb18-1232"></a><span class="in">  # get LPOCV/AUC from the preterm dataset (NB, 28wk-preterm: training) #</span></span>
<span id="cb18-1233"><a href="#cb18-1233"></a><span class="in">  #######################################################################</span></span>
<span id="cb18-1234"><a href="#cb18-1234"></a><span class="in">  my.targets&lt;-"LEP_PAPPA2"</span></span>
<span id="cb18-1235"><a href="#cb18-1235"></a></span>
<span id="cb18-1236"><a href="#cb18-1236"></a><span class="in">  dt.best.result&lt;-lapply(my.targets, function(my.proteins){</span></span>
<span id="cb18-1237"><a href="#cb18-1237"></a><span class="in">                        ############################################</span></span>
<span id="cb18-1238"><a href="#cb18-1238"></a><span class="in">                        # fit the model using the training dataset #</span></span>
<span id="cb18-1239"><a href="#cb18-1239"></a><span class="in">                        ############################################</span></span>
<span id="cb18-1240"><a href="#cb18-1240"></a><span class="in">                        my.feature&lt;-strsplit(my.proteins,",") %&gt;% unlist</span></span>
<span id="cb18-1241"><a href="#cb18-1241"></a><span class="in">                        df.mat.tr&lt;-mat.tr[,c(my.feature,'y')] %&gt;% as.data.frame  # training set</span></span>
<span id="cb18-1242"><a href="#cb18-1242"></a><span class="in">                        my.model&lt;-glm(y~. , data = df.mat.tr, family = "binomial")</span></span>
<span id="cb18-1243"><a href="#cb18-1243"></a></span>
<span id="cb18-1244"><a href="#cb18-1244"></a><span class="in">                        ## preterm (NB, 28wk: training dataset where the model was built)</span></span>
<span id="cb18-1245"><a href="#cb18-1245"></a><span class="in">                        dt.foo1&lt;-lapply(c("12wk","20wk","28wk"), function(my.GA){</span></span>
<span id="cb18-1246"><a href="#cb18-1246"></a><span class="in">                          message(paste("preterm",my.GA,my.proteins,sep=":"))</span></span>
<span id="cb18-1247"><a href="#cb18-1247"></a><span class="in">                          x&lt;-li.mat[["train"]][[my.GA]]</span></span>
<span id="cb18-1248"><a href="#cb18-1248"></a><span class="in">                          x&lt;-cbind(x, "LEP_PAPPA2"=x[,"LEP"] * x[,"PAPPA2"])</span></span>
<span id="cb18-1249"><a href="#cb18-1249"></a><span class="in">                          my.fold&lt;-paste0(my.GA,"(preterm)")</span></span>
<span id="cb18-1250"><a href="#cb18-1250"></a><span class="in">                          get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1251"><a href="#cb18-1251"></a><span class="in">                        }) %&gt;% rbindlist</span></span>
<span id="cb18-1252"><a href="#cb18-1252"></a></span>
<span id="cb18-1253"><a href="#cb18-1253"></a><span class="in">                        ## term (validation)</span></span>
<span id="cb18-1254"><a href="#cb18-1254"></a><span class="in">                        dt.foo2&lt;-lapply(c("12wk","20wk","28wk","36wk"), function(my.GA){</span></span>
<span id="cb18-1255"><a href="#cb18-1255"></a><span class="in">                          message(paste("term",my.GA,my.proteins,sep=":"))</span></span>
<span id="cb18-1256"><a href="#cb18-1256"></a><span class="in">                          x&lt;-li.mat[["test"]][[my.GA]]</span></span>
<span id="cb18-1257"><a href="#cb18-1257"></a><span class="in">                          x&lt;-cbind(x, "LEP_PAPPA2"=x[,"LEP"] * x[,"PAPPA2"])</span></span>
<span id="cb18-1258"><a href="#cb18-1258"></a><span class="in">                          my.fold&lt;-paste0(my.GA,"(term)")</span></span>
<span id="cb18-1259"><a href="#cb18-1259"></a><span class="in">                          get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1260"><a href="#cb18-1260"></a><span class="in">                        }) %&gt;% rbindlist</span></span>
<span id="cb18-1261"><a href="#cb18-1261"></a><span class="in">                        </span></span>
<span id="cb18-1262"><a href="#cb18-1262"></a><span class="in">                        ## Munchel </span></span>
<span id="cb18-1263"><a href="#cb18-1263"></a><span class="in">                        message(paste("Munchel",my.proteins,sep=":"))</span></span>
<span id="cb18-1264"><a href="#cb18-1264"></a><span class="in">                        x&lt;-li.mat[["munchel"]]</span></span>
<span id="cb18-1265"><a href="#cb18-1265"></a><span class="in">                        x&lt;-cbind(x, "LEP_PAPPA2"=x[,"LEP"] * x[,"PAPPA2"])</span></span>
<span id="cb18-1266"><a href="#cb18-1266"></a><span class="in">                        my.fold&lt;-"Munchel"</span></span>
<span id="cb18-1267"><a href="#cb18-1267"></a><span class="in">                        dt.foo3&lt;-get_cv_glm2(x=x,my.fold=my.fold,my.model=my.model,my.feature=my.feature)</span></span>
<span id="cb18-1268"><a href="#cb18-1268"></a><span class="in">                        rbind(dt.foo1,dt.foo2,dt.foo3)</span></span>
<span id="cb18-1269"><a href="#cb18-1269"></a><span class="in">                    }) %&gt;% rbindlist</span></span>
<span id="cb18-1270"><a href="#cb18-1270"></a><span class="in">  save(dt.best.result, file=my.RData)</span></span>
<span id="cb18-1271"><a href="#cb18-1271"></a><span class="in">}</span></span>
<span id="cb18-1272"><a href="#cb18-1272"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->




</body></html>