{
  "hash": "5c2ceb48538b8eb3d751c0c6e8824c82",
  "result": {
    "engine": "knitr",
    "markdown": "# RNA-seq data processing {#sec-mtd-rna-seq}\n\n## Transcript quantification {#sec-mtd-rna-seq-quant}\n\nFor an RNA-seq quantification method applied in this study, we chose the most reliable approach based on the performance of predicting fetal sex by measuring the extent of chromosome Y encoded transcripts (see @sec-si-quant-method for detail). Based on this benchmark result, we chose [`Salmon`](https://combine-lab.github.io/salmon/) (v1.5.2) in mapping-mode to process our RNA-seq datasets. \n\n### Salmon index {#sec-mtd-salmon-index}\n\n```{#lst-salmon-index .bash lst-cap=\"A pseudo-code to run `salmon index`\" filename=\"static/shell/salmon.decoy.sh\"}\n$HOME/Install/SalmonTools/scripts/generateDecoyTranscriptome.sh \\\n  -j 32 \\\n  -m $HOME/Install/mashmap/mashmap \\\n  -g $HOME/data/genome/Homo_sapiens/Ensembl/GRCh38/Sequence/WholeGenomeFasta/genome.fa \\\n  -a $HOME/results/RNA-Seq/Placentome/gffcompare/POPS-2022/POPS-Placenta-Transcriptome/POPS-2022.GRCh38.88.Novel.Known.Freq.0.1.TPM.0.1.tr.reconstruction.gffread.gtf \\\n  -t $HOME/results/RNA-Seq/Placentome/gffcompare/POPS-2022/POPS-Placenta-Transcriptome/POPS-2022.GRCh38.88.Novel.Known.Freq.0.1.TPM.0.1.tr.reconstruction.gffread.gtf.fa \\\n  -o $HOME/data/Salmon/decoy/Homo_sapiens/Ensembl/GRCh38/POPS-2022.GRCh38.88.Novel.Known.Freq.0.1.TPM.0.1.tr.reconstruction\n\n```\n\n### Salmon quant {#sec-mtd-salmon-quant}\n\n```{#lst-salmon-quant .bash lst-cap=\"A pseudo-code to run `salmon quant` in mapping mode\" filename=\"static/shell/salmon-quant.sh\"}\nsalmon quant -p 32 \\\n             -i POPS_TR_INDEX  \\\n             -l A \\\n             -1 S1_FQ_1.fq \\\n             -2 S1_FQ_2.fq \\\n             --seqBias \\\n             --gcBias \\\n             --posBias \\\n             --discardOrphanQuasi \\\n             --writeUnmappedNames \\\n             --writeMapping \\\n             -o OUTPUT_DIR | samtools view -bS > OUTPUT_DIR/S1_salmon.bam\n\n```\n\n## Differentially expressed gene analysis {#sec-mtd-deg}\n\nThe differentially expressed gene analysis was conducted for each gestational epoch (12wk, 20wk, 28wk, and 36wk) separately, except for the 36wkGA gestation samples of the pre-term dataset which has only one PE case. \n\nFirstly, the following parameters were defined:\n```{#lst-set-config .r lst-cap=\"Set the parameters\" filename=\"static/R/config/cfRNA-2024.R\"}\n# set parameters\nmy.disease=\"PE\"\nmy.type=\"preterm\"\nmy.salmon=\"Salmon\"\nmy.salmon.index=\"POPS-2022.GRCh38.88\"\nmy.slx<-\"SLX-ILM-Plasma2021.Homo_sapiens.v1\"\n\n# set filter\nminCPM=0.1; minRead=10; minFreq=0.1; minFC=1.2\n\n# which p.adjust methods?\nadjust.methods=c(`Benjamini & Yekutieli`=\"BY\",\n            `Benjamini & Hochberg`=\"BH\",\n            `Bonferroni`=\"bonferroni\")\n\n```\n\nThe transcript-level read count matrices (e.g. quant.sf files) were imported using [`tximeta`](https://bioconductor.org/packages/release/bioc/html/tximeta.html) (v1.8.5) Bioconductor package and merged at the gene-level. \n\n\n::: {.cell}\n\n```{#lst-prep-quant-sf .r .cell-code  lst-cap=\"Code to set the `Salmon` quant files of the pre-term dataset (i.e. Discovery dataset)\" code-summary=\"Code to set the `Salmon` quant files of the pre-term dataset (i.e. Discovery dataset)\"}\ndt.foo<-data.table(`files`=system(paste0(\"ls \", \"~/results/\",my.slx,\"/\",my.salmon,\"/\",my.salmon.index,\"/*/quant.sf\"), intern=T))\ndt.foo[,names:=tstrsplit(files,\"/\",keep=8)]\ndt.colDataAll<-merge(dt.foo,dt.samples,by.x=\"names\",by.y=\"SampleID\") # n=755\n\n# pre-term\ndt.colData<-dt.colDataAll[Type==my.type] # n=279\n#dt.colData[grepl(\"-b$\",names)] # CX (CX-b): both failed; HQ (HQ-b): only HQ-b passed QC according to illumina\ndt.colData<-dt.colData[!names %in% c(\"GS-59-CX-b\",\"GS-179-HQ\")] # remove these two samples (n=277)\nli.GA<-split(dt.colData, dt.colData$GA)\n\n#tx2gene\ndt.tx2gene<-fread(\"~/results/RNA-Seq/Placentome/gffcompare/POPS-2022/POPS-Placenta-Transcriptome/POPS-2022.GRCh38.88.Novel.Known.Freq.0.1.TPM.0.1.tr.reconstruction.tx2gene.txt\", header=F,col.names=c(\"transcript_id\",\"gene_id\"))\n```\n:::\n\n::: {.cell}\n\n```{#lst-prep-dds .r .cell-code  lst-cap=\"Code to make `dds` (DESeq Data Set) object\" code-summary=\"Code to make `dds` (DESeq Data Set) object\"}\nlibrary(DESeq2)\nlibrary(edgeR)\nlibrary(\"BiocParallel\")\nregister(MulticoreParam(12))\n\n#tximeta via tx2gene\n# 36wk dataset excluded from the beginnin\ngse<-tximeta::tximeta(dt.colData[GA!=\"36wk\"],\n                      skipMeta=T,\n                      tx2gene=dt.tx2gene[,.(transcript_id,gene_id)],txOut=F)\n\n# set up `dds` at gene-level\nmy.design <- formula(~ Batch + GA + Sex + Condition)    # isa 'formula'\ndds <- DESeqDataSet(se=gse, design=my.design)\n\ndds$Group<-factor(paste0(dds$GA,dds$Condition)) # add 'Group'\ndesign(dds) <- formula(~ Batch + Sex + Group)     # isa 'formula'\n\ndds<- DESeq(dds, parallel=TRUE) # isa 'DESeqDataSet'\n```\n:::\n\n\n### `DESeq2` {#sec-mtd-deg-deseq2}\n\nWe only considered genes found in ≥10% of samples (i.e. ≥ 23) having ≥10 reads, and discarded genes detected as dispersion outliers by [`DESeq2`](https://bioconductor.org/packages/release/bioc/html/DESeq2.html) (v1.30.0).\n\n\n::: {.cell}\n\n```{#lst-set-dds .r .cell-code  lst-cap=\"Code to set up `dds` object\" code-summary=\"Code to set up `dds` object\"}\n# at leat 10 reads for at leat 10  % of the samples \nkeep <- rowSums(counts(dds) >= minRead) >= ncol(dds)*minFreq \ndds.f<- DESeq(dds[keep,], parallel=TRUE) # isa 'DESeqDataSet'\ndim(dds.f) # 15380 x 221\n```\n:::\n\n\nA total of 15,150 genes and 221 samples were used to find differentially expressed genes by adjusting the batch number, the fetal sex, and the gestion of the samples in the design matrix of DESeq2. The p-values were calculated from the null hypothesis that the fold changes were less than or equal to 20% (i.e. lfcThreshold=log2(1.2)) in case and control groups. \n\n\n::: {.cell}\n\n```{#lst-set-deg .r .cell-code  lst-cap=\"Code to find DEGs by DESeq\" code-summary=\"Code to find DEGs by DESeq\"}\n# remove dispOutlier genes\nkeep2<-!is.na(rowData(dds.f)[,\"dispOutlier\"]) & !rowData(dds.f)[,\"dispOutlier\"]\ndds.f2<- DESeq(dds.f[keep2], parallel=T)\n\ndim(dds.f2) # 15150 x 221\n\n# apply shink separately for 12wk, 20wk, and 28wk (li.GA[1:3])\nli.resLFC<-lapply(names(li.GA)[1:3],function(my.GA){ \n  my.res<-results(dds.f2, \n          independentFiltering=FALSE, #by default independant filtering at FDR (alpha) 0.1 (10%) \n          lfcThreshold=log2(minFC), \n          contrast=c(\"Group\",paste0(my.GA,c(\"Case\",\"Control\"))),\n          parallel=TRUE)  \n  lfcShrink(dds.f2, \n            res=my.res,\n            lfcThreshold=log2(minFC), # not applicable for 'asher' \n            type=\"ashr\",\n            parallel=TRUE)  \n})\nnames(li.resLFC)<-names(li.GA)[1:3]\n\ndl.resLFC<-lapply(li.resLFC, function(i)\n  data.table(`gene_id`=rownames(i), \n              as.data.frame(i))[order(pvalue)][,`:=`(\"BH\"=p.adjust(pvalue,\"BH\"),\n                                              \"BY\"=p.adjust(pvalue,\"BY\"),\n                                              \"bf\"=p.adjust(pvalue,\"bonferroni\"))]\n)\nfwrite(dl.resLFC[[\"28wk\"]], file=paste0(\"static/R/result/DEG.DSeq2.28wk.\",my.type,\".\",my.salmon.index,\".csv\"))\n```\n:::\n\n\n### `edgeR` {#sec-mtd-deg-edger}\n\nFor [edgeR](https://bioconductor.org/packages/release/bioc/html/edgeR.html) (v3.32.1) analysis, we used `makeDGEList` function of `tximeta` Bioconductor package to convert the data object of the 15,150 genes across the 221 samples as mentioned above. The gene-level count matrix was normalised by using `calcNormFactors` function of `edgeR` with `TMM` method (trimmed mean of M values) and a quasi-likelihood negative binomial generalised log-linear model (i.e. `glmQLFit`) was applied to account for the batch number, the fetal sex and the gestation information in the design matrix of edgeR. For a statistical test, we used `glmTreat` of edgeR with at least 20% fold-change (i.e. lfc=log2(1.2)).\n\n\n::: {.cell}\n\n```{#lst-set-edger .r .cell-code  lst-cap=\"Code to find DEGs by `edgeR`\" code-summary=\"Code to find DEGs by `edgeR`\"}\ngse2 <-gse[rownames(dds.f2),]\nd2<-tximeta::makeDGEList(gse2)\nd2$samples<-cbind(d2$samples,colData(gse2))\nd2$samples$group<-factor(paste0(d2$samples$GA,d2$samples$Condition)) # add 'group'\nd2$samples$GA<-droplevels(d2$samples$GA) # 36wk removed\nd2$samples$Batch<-droplevels(d2$samples$Batch) # some batches removed\n\n# additional filter\n#keep <- filterByExpr(d2)\n#keep %>% table # FALSE:13, TRUE:15137\n#d2<-d2[keep,]\n\n# TMM normalisation (default). It adds `norm.factors` d2$samples\n# NB, we have `offsets`, which take precedence over lib.size and norm.factors\nd2<-calcNormFactors(d2,method=\"TMM\") \n                                    \nplotMDS(d2, col=as.numeric(d2$samples$GA))\nplotMDS(d2, col=as.numeric(d2$samples$Condition))\n\n# design\nmy.design <- model.matrix(~ 0 + group + Sex + Batch , data=d2$samples) \t\t# isa 'matrix'\n(my.contrasts <- makeContrasts(`12wk`=group12wkCase-group12wkControl, \n                              `20wk`=group20wkCase-group20wkControl, \n                              `28wk`=group28wkCase-group28wkControl, \n                              levels=my.design)\n)\n\n# dispersion\n#dp2 = estimateDisp(d2, design=my.design, verbose=T)\ndp2 = estimateGLMCommonDisp(d2, design=my.design, verbose=T) \ndp2 = estimateGLMTrendedDisp(dp2, design=my.design, verbose=T)\ndp2 = estimateGLMTagwiseDisp(dp2, design=my.design)\n\nplotMDS(dp2)\nplotBCV(dp2)\n\n# fit\n#f = glmFit(dp2, design=my.design) # \nf = glmQLFit(dp2, design=my.design) # QL(Quasi-like) pipeline\n\nplotMD(f)\nplotQLDisp(f)\n\n# get the edgeR results\nli.res.edgeR<-lapply(names(li.GA)[1:3], function(i){\n  te <- glmTreat(f, contrast=my.contrasts[,i], lfc=log2(minFC))\n  topTags(te, n=nrow(te))    # default sort by pvalue\n})\nnames(li.res.edgeR) <-names(li.GA)[1:3] \n\ndl.res.edgeR<-lapply(li.res.edgeR, function(i)\n  data.table(`gene_id`=rownames(i),i$table)[order(PValue)][,`:=`(\"BH\"=p.adjust(PValue,\"BH\"),\n                                                                  \"BY\"=p.adjust(PValue,\"BY\"),\n                                                                  \"bf\"=p.adjust(PValue,\"bonferroni\"))]\n)\nlapply(dl.res.edgeR, function(i) i[FDR<0.05] %>% nrow)\n\nfwrite(dl.res.edgeR[[\"28wk\"]], file=paste0(\"static/R/result/DEG.edgeR.28wk.\",my.type,\".\",my.salmon.index,\".csv\"))\n```\n:::\n\n\n### The z-score matrix {#sec-zscore-mat}\n\nThe gene-level count matrix was converted as the unit of CPM (Count Per Million), in log2-scale, via the “cpm” function of edgeR and it was further transformed into a matrix of the z-score using the mean and standard deviation of logCPM from the control samples of each corresponding gestational age group.\n\n\n::: {.cell}\n\n```{#lst-cnt-cpm .r .cell-code  lst-cap=\"Code to make the z-score matrix from the discovery dataset\" code-summary=\"Code to make the z-score matrix from the discovery dataset\"}\n# CPM based on edgeR TMM  (NB, d isa \"DGEList\")\ndt.logcpm2<-merge(\n  data.table(`geneName`=rownames(d2),cpm(d2,log=T)) %>% \n    melt.data.table(id.vars=c(\"geneName\"),variable.name=\"SampleID\",value.name=\"logCPM\"),\n  dt.samples[Type==my.type,.(SampleID,GA,Condition,Group=paste(GA,Condition,sep=\"-\"))]\n  )\n\ndt.cpmZ=merge(dt.logcpm2,\n              dt.logcpm2[Condition==\"Control\",.(Mean=mean(logCPM),SD=sd(logCPM)),.(GA,geneName)]\n      ,by=c(\"GA\",\"geneName\")\n      )[,.(Group,GA,Condition,SampleID,geneName,logCPM,logCPMZ=(logCPM-Mean)/SD)]\n#save(dt.cpmZ,file=my.cpmZ.RData) # cache to use it later\n```\n:::\n\n\n### Univariate logistic regression {#sec-logreg}\n\nUsing the binary outcomes, (i.e. case and control status) as dependant variables and the z-scores as independent variables, we applied a generalised linear model for each of the 15,150 genes using the `glm` function of R `stat` package (v4.0.3). Both the [Akaike information criterion (AIC)](https://en.wikipedia.org/wiki/Akaike_information_criterion) and the [Bayesian information criterion (BIC)](https://en.wikipedia.org/wiki/Bayesian_information_criterion) were obtained from the corresponding univariable model and the area under the [ROC curve](https://en.wikipedia.org/wiki/Receiver_operating_characteristic) (AUC) was calculated using the [`pROC`](https://cran.r-project.org/web/packages/pROC/) package (v1.17.0.1). The p-values were calculated against the null hypothesis that is the odds ratio is equal to 1 and they were adjusted for multiple comparisons using [Benjamini and Hochberg method](https://en.wikipedia.org/wiki/False_discovery_rate#BH_procedure). The distribution of the p-values was tested against a uniform distribution using one-sample [Kolmogorov-Smirnov test](https://en.wikipedia.org/wiki/Kolmogorov%E2%80%93Smirnov_test), which is further explained in @sec-fig2a.\n\n\n::: {.cell}\n\n```{#lst-logreg .r .cell-code  lst-cap=\"Code for univariate logisitic regression\" code-summary=\"Code for univariate logisitic regression\"}\nthis.mat<-dt.cpmZ[,.(SampleID,geneName,logCPMZ,y=ifelse(Condition==\"Case\",1,0))] %>% \n  dcast.data.table(SampleID+y~geneName,value.var=\"logCPMZ\") %>% \n  as.matrix(rownames=\"SampleID\") # logCPMZ\n\nfor(my.GA in names(li.GA)[1:3]){ # for each 12wk, 20wk and 28wkGA\n  this.samples<-colnames(dds.f2)[colData(dds.f2)$GA==my.GA]\n  foo<-list() # per GA\n  for(my.ID in rownames(dds.f2)){\n      #message(paste(my.GA,my.ID))\n      df.mat<-this.mat[this.samples,c(\"y\",my.ID)] %>% as.data.frame\n      my.model<-glm(y ~., data=df.mat, family=\"binomial\")\n      #oddsratio::or_glm(data=df.mat, model=my.model, incr=list(OID20239=1))\n\n      # Log Odds Ratio & p-values & CI\n      #my.model %>% summary\n      #coef(summary(my.model)) # isa 'matrix'\n      foo1<-as.data.frame(coef(summary(my.model)))\n\n      #cbind(coef(my.model), confint(my.model)) # Log Odds Ratio & CI (95%)\n      #exp(cbind(coef(my.model), confint(my.model))) # Odds Ratio & CI (95%)\n      foo2<-as.data.frame(exp(cbind(coef(my.model), confint(my.model)))) # Odds Ratio & CI (95%)\n\n      foo3<-cbind(my.ID,cbind(foo1,foo2)[2,]) %>% data.table \n      colnames(foo3)<-c(\"gene_id\",\"log_odds\",\"se\",\"zval\",\"pval\",\"odds\",\"odds_lo\",\"odds_hi\")\n\n      # ROC & AUC \n      #predict(my.model,type=c(\"response\"))  # predicted probability\n      my.prob<-fitted(my.model) # same as above\n      # no probability in case of NA in the matrix\n      if(nrow(df.mat)!=length(my.prob)){\n          dt.prob<-rbind(\n          data.table(`index`=as.numeric(names(my.prob)),`prob`=my.prob),\n          data.table(`index`=as.numeric(df.mat[,my.ID]%>% is.na %>% which), `prob`=NA)\n          )[order(index)]\n          my.prob<-dt.prob$prob\n      }\n      df.mat$prob<-my.prob\n      my.roc <- pROC::roc(y ~ prob, data = df.mat, quiet=T, ci=TRUE)\n\n      foo[[my.ID]] <- \n      cbind(\n            foo3,\n            data.table(`auc`=my.roc$ci[2], \n                        `auc_lo`=my.roc$ci[1], \n                        `auc_hi`=my.roc$ci[3],\n                        `AIC`=aic(my.model),\n                        `BIC`=bic(my.model) ) \n      )\n  } # end of for   \n  dl.logregZ[[my.GA]]<-rbindlist(foo)\n\n  # apply p.adjust\n  for(i in adjust.methods){\n      dl.logregZ[[my.GA]][,paste0(\"padj.\",i):=p.adjust(pval,i)]\n  }\n} # end of for my.GA\n\n# cache to use it later\n#save(dl.logregZ, file=paste0(\"RData/dl.logregZ.\",my.type,\".\",my.salmon.index,\".RData\"))\n```\n:::\n\n\n## Selection of core differentially expressed genes {#sec-core-deg}\n\nTo select a subset of genes that best explains the outcome of samples from the 28wkGA group of the discovery cohort, we used the following four criteria: 1) the p-values from DESeq2, 2) the p-values from edgeR, 3) AIC, and 4) AUC from univariable logistic regressions. Then we selected the top 1% genes for each category (i.e. 151 genes of the lowest p-values from DESeq2 and edgeR, 151 genes having the lowest AIC, and 151 genes having the highest AUC) and constructed a Venn diagram using ggvenn (v0.1.0) R package (52). We selected a total of 17 genes satisfying all the four criteria (i.e. the intersection) and constructed a gene expression matrix (i.e. the 17 genes across the samples from the 28wkGA group of the discovery cohort) using the z-score.\n\n\n::: {.cell}\n\n```{#lst-set-core-deg .r .cell-code  lst-cap=\"Code to find the core DEGs\" code-summary=\"Code to find the core DEGs\"}\nvenn.top1pctZ<-list(`DESeq2`=dl.resLFC[[\"28wk\"]][order(pvalue)][1:151]$gene_id,\n                  `edgeR`=dl.res.edgeR[[\"28wk\"]][order(PValue)][1:151]$gene_id,\n                `AUC`=dl.logregZ[[\"28wk\"]][order(-auc)][1:151]$gene_id,\n                `AIC`=dl.logregZ[[\"28wk\"]][order(AIC)][1:151]$gene_id\n                )\n\n# the union of all\ndt.venn.top1pctZ<-lapply(names(venn.top1pctZ), function(i) data.table(i,venn.top1pctZ[[i]])) %>% \n  rbindlist %>% \n  dcast.data.table(V2~i, fun=length)\nsetnames(dt.venn.top1pctZ,\"V2\",\"Gene\")\ntop1pct.genesZ<-dt.venn.top1pctZ[AIC==1 & AUC==1 & DESeq2==1 & edgeR==1]$Gene\ncore17 <- top1pct.genesZ # used in 5-fold CV\n```\n:::\n\n\nThe Venn diagram for the 17 core DEGs is shown in @sec-fig2c.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}